/*
Сделайте это снова с помощью рекурсии
Do it Again with Recursion

Вы можете вызывать функции снаружи функции или изнутри другой функции. 

Вы даже можете вызвать функцию изнутри самой себя. Когда функция вызывает саму себя, она использует метод программирования, называемый рекурсией.

Вы можете использовать рекурсию во многих случаях, в которых вы бы использовали цикл, за исключением того, что она повторяет операторы внутри функции.

Например, простая рекурсивная функция. Однако у этой рекурсивной функции есть одна большая проблема. Можете ли вы это заметить?
Будем находить квадрат числа
*/

function squareItUp (startingNumber) {
    let square = startingNumber * startingNumber;
    console.log(square);
    squareItUp(square);
}

squareItUp(6);
/*
выведет в консоль:
4
16
256
65536
4294967296
18446744073709552000
3.402823669209385e+38
1.157920892373162e+77
1.3407807929942597e+154
Infinity
Infinity
...
*/
/*
/*
Вы видите проблему с этой функцией? Это никогда не заканчивается. Он будет просто продолжать умножать числа, пока вы не остановите его.


Запуск этой функции, вероятно, приведет к сбою вашего браузера, если не вашего компьютера. Никакого необратимого ущерба, конечно, не будет, но вам достаточно просто прочитать код и заметить здесь проблему.

Давайте функцию SquareItUp() улучшим за счет предоставления так называемого базового случая. 

Базовый случай — это условие, при котором работа рекурсивной функции выполнена и она должна остановиться. Каждая рекурсивная функция должна иметь базовый вариант.
*/

function squareItUp(startingNumber) {
    let square = startingNumber * startingNumber;
    
    if (square > 1000000) {
        console.log(square);
    } else {
        squareItUp(square);
    }
};

// еще раз вызов функции писать не надо - уже вызывали раньше - результат теперь 4294967296.

/*
Там. Так-то лучше! Но у этой функции все еще есть большая проблема. Что, если кто-то передаст в него отрицательное число, ноль или 1?
 Результатом любого из этих случаев все равно будет бесконечный цикл. 
 */

// squareItUp(-2);  // 4294967296
// squareItUp(0);    // RangeError: Maximum call stack size exceeded - память переполнена
// squareItUp(1); // RangeError: Maximum call stack size exceeded - память переполнена
// squareItUp("a");  // RangeError: Maximum call stack size exceeded - память кончилась

/*
 Чтобы защититься от такой ситуации, нам понадобится условие завершения. 
 Добавим проверку, позволяющую убедиться, что аргумент не меньше или равен 1 и что это не что-то иное, кроме числа. В обоих случаях функция немедленно остановится.
*/

function squareItUp(startingNumber) {
    // условие выхода из функции, если не валидные данные
    if ((typeof startingNumber != 'number') || (startingNumber <= 1)) {
        return -1; // выйди из функции
    }
    
    square = startingNumber * startingNumber; // Базовое условие
    if (square > 1000000) {
        console.log(square); // Печать финального значения
    } else {
        // Если базовое условие не выполнилось, то выполняй рекурсивную функцию
        squareItUp(square);
    }
};

squareItUp(2); //  4294967296
squareItUp(-2);  // 4294967296
squareItUp(0);    // RangeError: Maximum call stack size exceeded - память переполнена
squareItUp(1); // RangeError: Maximum call stack size exceeded - память переполнена
squareItUp("a");  // RangeError: Maximum call stack 
