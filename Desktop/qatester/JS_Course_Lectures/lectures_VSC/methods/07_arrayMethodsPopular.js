/*
Шпаргалка по методам массива:

Для добавления/удаления элементов:

1) push(...items) – добавляет элементы в конец,
2) pop() – извлекает элемент с конца,
3) shift() – извлекает элемент с начала,
4) unshift(...items) – добавляет элементы в начало.
5) splice(pos, deleteCount, ...items) – начиная с ) индекса pos удаляет deleteCount элементов и вставляет items.
6) slice(start, end) – создаёт новый массив, копируя в него элементы с индекса start до end (не включая end).
7) concat(...items) – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items. Если какой-то из items является массивом, тогда берутся его элементы.
Для поиска среди элементов:

8, 9) indexOf/lastIndexOf(item, pos) – ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено.
10) includes(value) – возвращает true, если в массиве имеется элемент value, в противном случае false.
11, 12) find/filter(func) – фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых через функцию возвращается true.
13) findIndex похож на find, но возвращает индекс вместо значения.

Для перебора элементов:

14) forEach(func) – вызывает func для каждого элемента. Ничего не возвращает.

Для преобразования массива:

15) map(func) – создаёт новый массив из результатов вызова func для каждого элемента.
16) sort(func) – сортирует массив «на месте», а потом возвращает его.
17) reverse() – «на месте» меняет порядок следования элементов на противоположный и возвращает изменённый массив.
18) split/join – преобразует строку в массив и обратно.
19, 20) reduce/reduceRight(func, initial) – вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая промежуточный результат между вызовами.

Дополнительно:

21) Array.isArray(arr) проверяет, является ли arr массивом.
Пожалуйста, обратите внимание, что методы push, pop, shift, unshift, sort, reverse и splice изменяют исходный массив.

Эти методы – самые используемые, их достаточно в 99% случаев. 
*/

/*
Array Basic Methods 
console.log("**Для добавления/удаления элементов**********");
1. Array length
2. Array toString()
3. Array at()
4. Array join()              - 16)
5. Array pop()                - 2)
6. Array push()               - 1)
7. Array shift()              - 3)
8. Array unshift()            - 4)
9. Array delete()
10. Array concat()            - 7)
11. Array copyWithin()
12. Array flat()
13. Array splice()            - 5)
14. Array toSpliced()
15. Array slice()             - 6)
*/

*****************************************************
Юникод Русский алфавит 
Кириллица (блок Юникода)
https://ru.wikipedia.org/wiki/%D0%9A%D0%B8%D1%80%D0%B8%D0%BB%D0%BB%D0%B8%D1%86%D0%B0_(%D0%B1%D0%BB%D0%BE%D0%BA_%D0%AE%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4%D0%B0)
ASCII
https://www.lookuptables.com/text/ascii-table
*/
console.log("1".charCodeAt(0)); // 49
console.log("A".charCodeAt(0)); // 65 англ. A
console.log("Z".charCodeAt(0)); // 90
console.log("А".charCodeAt(0)); // 1040 русская А
console.log("Я".charCodeAt(0)); // 1071
console.log("ё".charCodeAt(0)); // 1105
console.log("Ё".charCodeAt(0)); // 1025

/*
******************************************************
*/
console.log("** Массив ************************");
/*
Объект Array, как и массивы в других языках программирования, позволяет хранить коллекцию из нескольких элементов под одним именем переменной и имеет методы для выполнения общих операций с массивами.

Описание
Массивы являются спископодобными объектами, чьи прототипы содержат методы для операций обхода и изменения массива. Ни размер JavaScript-массива, ни типы его элементов не являются фиксированными. Поскольку размер массива может увеличиваться и уменьшаться в любое время, то нет гарантии, что массив окажется плотным. То есть, при работе с массивом может возникнуть ситуация, что элемент массива, к которому вы обратитесь, будет пустым и вернёт undefined.

Доступ к элементам массива
Массивы в JavaScript индексируются с нуля: первый элемент массива имеет индекс, равный 0, а индекс последнего элемента равен значению свойства массива length минус 1.
*/
console.log("*******Доступ к элементам массива*********")
const arr = ["first element", "second element", "third element"];

console.log(arr[0]);  // first element
console.log(arr[arr.length - 1]);  // third element
console.log(arr[1]);  // second element

// Длина массива - свойство length.toExponential

let fruit = [];
fruit[5] = "Манго";

console.log(fruit[5]);  // Манго
console.log(Object.keys(fruit));  // [ '5' ]
console.log(fruit.length);  // 6
// можно увеличить длину массива
fruit.length = 10;
console.log(Object.keys(fruit));  // [ '5' ]

fruit.length = 2;
console.log(Object.keys(fruit));  // [  ]

console.log(fruit.length);  // 2

// Конструктор Array().

// Array[@@species] // возвращает конструктор Array
Array[Symbol.species];
console.log(Array[Symbol.species]);  // [Function: Array]


console.log("**Для поиска среди элементов**********");


console.log("**8)Array indexOf()************************");
/*
Метод indexOf() возвращает первый индекс, по которому данный элемент может быть найден в массиве или -1, если такого индекса нет.

Синтаксис
arr.indexOf(searchElement[, fromIndex = 0])
Параметры
searchElement - Искомый элемент в массиве.

fromIndex 
Индекс, с которого начинать поиск. Если индекс больше или равен длине массива, возвращается -1, что означает, что массив даже не просматривается. Если индекс является отрицательным числом, он трактуется как смещение с конца массива. Обратите внимание: если индекс отрицателен, массив всё равно просматривается от начала к концу. Если рассчитанный индекс оказывается меньше 0, поиск ведётся по всему массиву. Значение по умолчанию равно 0, что означает, что просматривается весь массив.

Описание
Метод indexOf() сравнивает искомый элемент searchElement с элементами в массиве, используя строгое сравнение (en-US) (тот же метод используется оператором ===, тройное равно).

Примеры
Пример: использование indexOf()
В следующем примере indexOf() используется для поиска значений в массиве.
*/
const array7 = [2, 5, 9];

console.log(array7.indexOf(2)); // 0
console.log(array7.indexOf(7)); // -1
console.log(array7.indexOf(9, 2)); // 2
console.log(array7.indexOf(2, -1)); // -1
console.log(array7.indexOf(2, -3)); // 0

/*
Пример: нахождение всех вхождений элемента
В следующем примере indexOf() используется для поиска всех индексов элемента в указанном массиве, которые с помощью push() добавляются в другой массив.
*/

const indices = [];
const array = ["a", "b", "a", "c", "a", "d"];
const element = "a";
let idx = array.indexOf(element);
while (idx != -1) {
    indices.push(idx);
    idx = array.indexOf(element, idx + 1);
}

console.log(indices); // [0, 2, 4]


console.log("**9)Array lastIndexOf()*******************");

/*
Метод lastIndexOf() возвращает последний индекс, по которому данный элемент может быть найден в массиве или -1, если такого индекса нет. Массив просматривается от конца к началу, начиная с индекса fromIndex.

 пример
*/
const animals = ["Dodo", "Tiger", "Penguin", "Dodo"];

console.log(animals.lastIndexOf("Dodo"));  // 3
console.log(animals.lastIndexOf("Tiger"));  // 1


/*
Синтаксис
arr.lastIndexOf(searchElement[, fromIndex = arr.length])
Параметры
searchElement - Искомый элемент в массиве.

fromIndex
Необязательный параметр. Индекс, с которого начинать поиск в обратном направлении. Если индекс больше или равен длине массива, просматривается весь массив. Если индекс является отрицательным числом, он трактуется как смещение с конца массива. Обратите внимание: если индекс отрицателен, массив всё равно просматривается от конца к началу. Если рассчитанный индекс оказывается меньше 0, массив даже не просматривается. Значение по умолчанию равно длине массива, что означает, что просматривается весь массив.

Описание
Метод lastIndexOf() сравнивает искомый элемент searchElement с элементами в массиве, используя строгое сравнение (en-US) (тот же метод используется оператором ===, тройное равно).

Примеры
Пример: использование lastIndexOf()
В следующем примере метод lastIndexOf() используется для поиска значений в массиве.
*/
const arrayNumbers = [2, 5, 9, 2];
console.log(arrayNumbers.lastIndexOf(2)); // 3
console.log(arrayNumbers.lastIndexOf(7)); // -1
console.log(arrayNumbers.lastIndexOf(2, 3)); // 3
console.log(arrayNumbers.lastIndexOf(2, 2)); // 0
console.log(arrayNumbers.lastIndexOf(2, -2)); // 0
console.log(arrayNumbers.lastIndexOf(2, -1)); // 3
/*
Пример: нахождение всех вхождений элемента
В следующем примере метод lastIndexOf() используется для поиска всех индексов элемента в указанном массиве, которые с помощью метода push() добавляются в другой массив.
*/
const indicesLast = [];
const arrayLetters = ["a", "b", "a", "c", "a", "d"];
let elementFind = "a";
let idxLast = arrayLetters.lastIndexOf(elementFind);
while (idxLast != -1) {
    indicesLast.push(idxLast);
    idxLast = idxLast > 0 ? arrayLetters.lastIndexOf(element, idxLast - 1) : -1;
}

console.log(indicesLast);  // [4, 2, 0]

/*
Обратите внимание, что мы обрабатываем случай idxLast == 0 отдельно, поскольку элемент всегда будет найден, независимо от параметра fromIndex, если он является первым элементом в массиве. Этим он отличается от метода indexOf().
*/

console.log("**10)Array includes()**********************");
/*
Метод includes() определяет, содержит ли массив определённый элемент, возвращая в зависимости от этого true или false.

 пример
*/
const arrDigits = [1, 2, 3];

console.log(arrDigits.includes(2));  // true

const pets = ["cat", "dog", "bat"];

console.log(pets.includes("cat"));  // true
console.log(pets.includes("ca"));  // false
/*
Синтаксис
arr.includes(searchElement[fromIndex = 0])
Параметры
searchElement - Искомый элемент.

fromIndex Необязательный
Позиция в массиве, с которой начинать поиск элемента searchElement. При отрицательных значениях поиск производится начиная с индекса array.length + fromIndex по возрастанию. Значение по умолчанию равно 0.

Возвращаемое значение
Boolean.

Примеры
*/
console.log([1, 2, 3].includes(2)); // true
console.log([1, 2, 3].includes(4)); // false
console.log([1, 2, 3].includes(3, 3)); // false
console.log([1, 2, 3].includes(3, -1)); // true
console.log([1, 2, NaN].includes(NaN)); // true

/*
fromIndex больше или равен длине массива
Если fromIndex больше или равен длине массива, то возвращается false. При этом поиск не производится.
*/

const arrLetters = ["a", "b", "c"];

console.log(arrLetters.includes("c", 3)); // false
console.log(arrLetters.includes("c", 100)); // false

/*
Вычисленный индекс меньше нуля 0
Если fromIndex отрицательный, то вычисляется индекс, начиная с которого будет производиться поиск элемента searchElement. Если вычисленный индекс меньше нуля, то поиск будет производиться во всём массиве.
*/
// длина массива равна 3
// fromIndex равен -100
// вычисленный индекс равен 3 + (-100) = -97

const arrLetters2 = ["a", "b", "c"];

console.log(arrLetters2.includes("a", -100)); // true
console.log(arrLetters2.includes("b", -100)); // true
console.log(arrLetters2.includes("c", -100)); // true

/*
Использование includes() в качестве общих метода
includes() специально сделан общим. Он не требует, чтобы this являлся массивом, так что он может быть применён к другим типам объектов (например, к массивоподобным объектам). Пример ниже показывает использование метода includes() на объекте arguments.
*/

(function () {
    console.log([].includes.call(arguments, "a")); // true
    console.log([].includes.call(arguments, "d")); // false
})("a", "b", "c");


console.log("**11)Array find()************************");
/*
Метод find() возвращает значение первого найденного в массиве элемента, которое удовлетворяет условию переданному в callback функции. В противном случае возвращается undefined.

Также смотрите метод findIndex(), который возвращает индекс найденного в массиве элемента вместо его значения.

Если вам нужно найти позицию элемента или наличие элемента в массиве, используйте Array.prototype.indexOf() или Array.prototype.includes() соответственно.

Синтаксис
arr.find(callback[, thisArg])
Параметры
callback - Функция, вызывающаяся для каждого значения в массиве, принимает три аргумента:

element -Текущий обрабатываемый элемент в массиве.

index - Индекс текущего обрабатываемого элемента в массиве.

array - Массив, по которому осуществляется проход.

thisArg
Необязательный параметр. Значение, используемое в качестве this при выполнении функции callback.

Возвращаемое значение
Значение элемента из массива, если элемент прошёл проверку, иначе undefined.

Описание
Метод find вызывает переданную функцию callback один раз для каждого элемента, присутствующего в массиве, до тех пор, пока она не вернёт true. Если такой элемент найден, метод find немедленно вернёт значение этого элемента. В противном случае, метод find вернёт undefined.
Функция callback вызывается с тремя аргументами: значением элемента, индексом элемента и массивом, по которому осуществляется проход.

Если в метод find был передан параметр thisArg, при вызове callback он будет использоваться в качестве значения this. В противном случае в качестве значения this будет использоваться значение undefined.

Метод find не изменяет массив, для которого он был вызван.

Диапазон элементов, обрабатываемых методом find, устанавливается до первого вызова функции callback. Элементы, добавленные в массив после начала выполнения метода find, не будут посещены функцией callback. Если существующие, непосещение элементы массива изменяются функцией callback, их значения, переданные в функцию, будут значениями на тот момент времени когда метод find посетит их; удалённые элементы все ещё будут посещены.

Примеры

Пример: поиск простого числа в массиве
Следующий пример находит в массиве положительных чисел элемент, являющийся простым числом (либо возвращает undefined, если в массиве нет простых чисел).  101 / 101 ==> 4=2*2 9=3*3
*/

function isPrime1(element, index, array) {
    start = 2;
    while (start <= Math.sqrt(element)) {
        if (element % start++ < 1) {         // start = start + 1  // ++start
            return false;
        }
    }
    return element > 1;
}

console.log([4, 6, 8, 12].find(isPrime1)); // undefined, не найдено
console.log([4, 7, 8, 12].find(isPrime1)); // 5


console.log("**12)Array filter()************************");
/*
Метод filter() создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.

пример
*/

const words = ["spray", "elite", "exuberant", "destruction", "present"];

const result4 = words.filter((word) => word.length > 6);

console.log(result4);  // [ 'exuberant', 'destruction', 'present' ]

console.log(words.filter((word) => word === "spray"));  // может найти слово в массиве  [ 'spray' ]


console.log(words.filter((word) => word === "sprays"));  // вернет пустой массив []
/*
Синтаксис
// Стрелочная функция
filter((element) => { ... } )
filter((element, index) => { ... } )
filter((element, index, array) => { ... } )

// Колбэк-функция
filter(callbackFn)
filter(callbackFn, thisArg)

// Встроенная колбэк-функция
filter(function callbackFn(element) { ... })
filter(function callbackFn(element, index) { ... })
filter(function callbackFn(element, index, array){ ... })
filter(function callbackFn(element, index, array) { ... }, thisArg)

callbackFn - Функция-предикат, которая будет вызвана для проверки каждого элемента массива. Если функция возвращает true, то элемент остаётся в массиве, если false, то удаляется.

Принимает три аргумента

element - Текущий обрабатываемый элемент в массиве.

index Необязательный - Индекс текущего обрабатываемого элемента в массиве.

array Необязательный - Обрабатываемый массив, на котором был вызван метод filter().

thisArg Необязательный - Значение, используемое в качестве this при вызове колбэк-функции callbackFn.

Возвращаемое значение
Вернётся новый массив с элементами, которые прошли проверку. Если ни один элемент не прошёл проверку, то будет возвращён пустой массив.

Описание
Метод filter() вызывает переданную функцию callback один раз для каждого элемента, присутствующего в массиве, и создаёт новый массив со всеми значениями, для которых функция callback вернула значение, которое может быть приведено к true. Функция callback вызывается только для индексов массива с уже определёнными значениями; она не вызывается для индексов, которые были удалены или которым значения никогда не присваивались. Элементы массива, не прошедшие проверку функцией callback, просто пропускаются и не включаются в новый массив.

Функция callback вызывается с тремя аргументами:

значение элемента;
индекс элемента;
массив, по которому осуществляется проход.
Если в метод filter() был передан параметр thisArg, при вызове callback он будет использоваться в качестве значения this. В противном случае в качестве значения this будет использоваться значение undefined. В конечном итоге, значение this, наблюдаемое из функции callback, определяется согласно обычным правилам определения this.

Метод filter() не изменяет массив, для которого он был вызван.

Элементы массива, обрабатываемые методом filter(), устанавливается до первого вызова функции callback. Элементы, добавленные в массив после начала выполнения метода filter(), либо изменённые в процессе выполнения, не будут обработаны функцией callback. Соответствующим образом, если существующие элементы удаляются из массива, они также не будут обработаны

Предупреждение: одновременное изменение элементов, описанное в предыдущем параграфе, часто приводит к труднопонимаемому коду, поэтому не рекомендуется делать это (за исключением особых случаев).

Примеры
Фильтрация всех маленьких значений
Следующий пример использует filter() для создания отфильтрованного массива, все элементы которого больше или равны 10, а все меньшие 10 удалены.
*/

function isBigEnough(value) {
    return value >= 10;
}

let filtered = [12, 5, 8, 130, 44].filter(isBigEnough);
// массив filtered теперь содержит [12, 130, 44]
/*
Найти все простые числа в массиве*****
Следующий пример возвращает все простые числа в массиве:
Простые числа определяются как положительные целые числа, которые имеют ровно два делителя: единицу и само число. По определению, отрицательные числа не являются простыми.
*/
const array16 = [-3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];

function isPrime4(num) {
    for (let i = 2; num > i; i++) {
        if (num % i == 0) {
            return false;
        }
    }
    return num > 1;
}

console.log(array16.filter(isPrime4)); // [2, 3, 5, 7, 11, 13]
/*
Фильтрация неверных записей в JSON
В следующем примере метод filter() используется для создания отфильтрованного JSON-объекта, все элементы которого содержат ненулевое числовое поле id.
*/

let arr16 = [
    { id: 15 },
    { id: -1 },
    { id: 0 },
    { id: 3 },
    { id: 12.2 },
    {},
    { id: null },
    { id: NaN },
    { id: "undefined" },
];

let invalidEntries = 0;

function filterByID(item) {
    if (Number.isFinite(item.id) && item.id !== 0) {
        return true;
    }
    invalidEntries++;
    return false;
}

let arrByID = arr16.filter(filterByID);

console.log("Отфильтрованный массив\n", arrByID);
// Отфильтрованный массив
// [{ id: 15 }, { id: -1 }, { id: 3 }, { id: 12.2 }]

console.log("Количество некорректных элементов = ", invalidEntries);
// Количество некорректных элементов = 5
/*
`Number.isFinite()` - это статический метод объекта `Number` в JavaScript, который используется для определения, является ли переданное значение конечным числом. Он возвращает `true`, если значение является конечным числом, и `false` в противном случае.

В отличие от глобальной функции `isFinite()`, которая преобразует свой аргумент в число перед проверкой, метод `Number.isFinite()` проверяет только сам аргумент и возвращает `false` для значений, которые не являются числами или являются `Infinity` или `-Infinity`.
*/
Примеры:


Number.isFinite(Infinity);  // false
Number.isFinite(-Infinity); // false
Number.isFinite(NaN);       // false
Number.isFinite(123);       // true
Number.isFinite('123');     // false, потому что '123' не является числом
Number.isFinite(true);      // false, потому что true преобразуется в 1, которое является числом

/*
В примере функция `filterByID` использует `Number.isFinite(item.id)` для проверки, является ли `id` числом и конечным (не `Infinity`, не `-Infinity`, и не `NaN`), и возвращает `true`, если это так. Если `id` не является числом или является `0`, функция возвращает `false`.


/*
Поиск в массиве
В следующем примере filter() используется для фильтрации содержимого массива на основе входных данных.
*/
let fruits = ["apple", "banana", "grapes", "mango", "orange"];

/**
 * Элементы массива фильтруется на основе критериев поиска (query)
 */
function filterItems(query) {
    return fruits.filter(function (el) {
        return el.toLowerCase().indexOf(query.toLowerCase()) > -1;
    });
}

console.log(filterItems("ap")); // ['apple', 'grapes']
console.log(filterItems("an")); // ['banana', 'mango', 'orange']
/*
Этот код определяет функцию `filterItems(query)`, которая фильтрует элементы массива `fruits` на основе заданного критерия поиска `query`. Функция использует метод `filter()` для создания нового массива, содержащего только те элементы, которые удовлетворяют критериям поиска.

Вот как это работает:

1. Функция `filterItems(query)` принимает строку `query` в качестве аргумента, которая представляет собой критерий поиска.

2. Внутри функции используется метод `filter()` для фильтрации элементов массива `fruits`. Для каждого элемента массива выполняется функция обратного вызова, которая проверяет, содержит ли текущий элемент строку `query`.

3. Внутри функции обратного вызова строка `query` и текущий элемент массива `el` приводятся к нижнему регистру с помощью метода `toLowerCase()`. Это делается для обеспечения регистронезависимого поиска.

4. Затем проверяется, содержит ли приведенная к нижнему регистру строка `el` подстроку, представленную `query`. Это делается с помощью метода `indexOf()`, который возвращает индекс первого вхождения подстроки в строку или `-1`, если подстрока не найдена.

5. Если индекс, возвращаемый методом `indexOf()`, больше `-1`, это означает, что подстрока найдена в текущем элементе массива, и элемент добавляется в новый массив, создаваемый методом `filter()`.

6. В конце функция `filterItems(query)` возвращает новый массив, содержащий только те элементы, которые соответствуют критериям поиска `query`.

Этот подход позволяет эффективно фильтровать массив по критериям поиска, игнорируя регистр букв.


Реализация со стрелочной функцией:
*/
const fruits2 = ["apple", "banana", "grapes", "mango", "orange"];

/**
 * Элементы массива фильтруется на основе критериев поиска (query)
 */
const filterItems2 = (arr, query) => {
    return arr.filter(
        (el) => el.toLowerCase().indexOf(query.toLowerCase()) !== -1,
    );
};

console.log(filterItems2(fruits2, "ap")); // ['apple', 'grapes']
console.log(filterItems2(fruits2, "an")); // ['banana', 'mango', 'orange']


const fruit3 = ["apple", "banana", "grapes", "mango", "orange", "apple", "banana", "apple"];
// поиск и удаление дубликатов в массиве - если 2 и более элементов в массиве, они все будут удалены 
const doubleFree = fruit3.filter(el => fruit3.indexOf(el) === fruit3.lastIndexOf(el));
console.log(doubleFree);  // [ 'grapes', 'mango', 'orange' ]


// нахождение дубликатов
const dublicate = fruit3.filter(el => fruit3.indexOf(el) !== fruit3.lastIndexOf(el));
console.log(dublicate);  // [ 'apple', 'banana', 'apple', 'banana', 'apple' ]


// создание массива с неповторяющимися элементами
const fruit4 = ["apple", "banana", "grapes", "mango", "orange", "apple", "banana", "apple", "kiwi"];

const exclusive = fruit4.filter((el, i) => i === fruit4.indexOf(el)); // индекс текущего элемента равен индексу первого вхождения этого элемента
console.log(exclusive);  // [ 'apple', 'banana', 'grapes', 'mango', 'orange' ]

const exclusive2 = []
for (let i = 0; i < fruit4.length; i++) {
    if (i === fruit4.indexOf(fruit4[i])) {
        exclusive2.push(fruit4[i]);
        console.log(exclusive2);
    }
}
// [ 'apple', 'banana', 'grapes', 'mango', 'orange', 'kiwi' ]

// создание нового массива со всеми элементами, отвечающими условию в функции = берем элементы по нечетному индексу
const digits = [-4, 0, 876, 88, -22, 777];

const oddIndex = digits.filter((el, i) => i % 2);  // если индекс нечетный 3 % 2 = 1 === true; 0 === false

console.log(oddIndex);  // [ 0, 88, 777 ]



console.log("**13)Array findIndex()**********************");
/*
Метод findIndex() возвращает индекс в массиве, если элемент удовлетворяет условию проверяющей функции. В противном случае возвращается -1.

Также смотрите метод find(), который возвращает значение найденного в массиве элемента вместо его индекса.

Синтаксис
arr.findIndex(callback[, thisArg])

Параметры
callback - Функция, вызывающаяся для каждого значения в массиве, принимает три аргумента:

element - Текущий обрабатываемый элемент в массиве.

index - Индекс текущего обрабатываемого элемента в массиве.

array - Массив, по которому осуществляется проход.

thisArg
Необязательный параметр. Значение, используемое в качестве this при выполнении функции callback.

Описание
Метод findIndex вызывает переданную функцию callback один раз для каждого элемента, присутствующего в массиве, до тех пор, пока она не вернёт true. Если такой элемент найден, метод findIndex немедленно вернёт индекс этого элемента. В противном случае, метод findIndex вернёт -1. Функция callback вызывается только для индексов массива, имеющих присвоенные значения; она не вызывается для индексов, которые были удалены или которым значения никогда не присваивались.

Функция callback вызывается с тремя аргументами: значением элемента, индексом элемента и массивом, по которому осуществляется проход.

Если в метод findIndex был передан параметр thisArg, при вызове callback он будет использоваться в качестве значения this. В противном случае в качестве значения this будет использоваться значение undefined.

Метод findIndex не изменяет массив, для которого он был вызван.

Диапазон элементов, обрабатываемых методом findIndex, устанавливается до первого вызова функции callback. Элементы, добавленные в массив после начала выполнения метода findIndex, не будут посещены функцией callback. Если существующие, непосещение элементы массива изменяются функцией callback, их значения, переданные в функцию, будут значениями на тот момент времени, когда метод findIndex посетит их; удалённые элементы посещены не будут.

Примеры
Пример: поиск индекса простого числа в массиве
Следующий пример находит в массиве индекс элемента, являющийся простым числом (либо возвращает -1, если в массиве нет простых чисел).
*/
function isPrime2(element, index, array) {
    var start = 2;
    while (start <= Math.sqrt(element)) {
        if (element % start++ < 1) {
            return false;
        }
    }
    return element > 1;
}

console.log([4, 6, 8, 12].findIndex(isPrime2)); // -1, не найдено
console.log([4, 6, 7, 12].findIndex(isPrime2)); // 2

testingTools = [
    "management tools",
    "static testing tools",
    "test design and implementation tools",
    "test execution and coverage tools",
    "Non-fanctional testing tools",
    "DevOps tools", 
    "Collaboration tools",
    "tools supporting scalability and deployment standardization",
    "any other tool"
];

testing = ["plan", "design", "DevOps tools", "test automation"]

function isTool(element, index, array) {
    // return this.includes(element);
    for (let i = 0; i <this.length; i++) {
        if (element === this[i]) {
            return true;
        }
    }    
    return false;
}

console.log(testing.findIndex(isTool, testingTools));

console.log("**Для перебора элементов**************");


console.log("**14)Array forEach************************");
/*
Метод forEach() выполняет указанную функцию один раз для каждого элемента в массиве.

Интерактивный пример

Синтаксис
arr.forEach(function callback(currentValue, index, array) {
    //your iterator
}[, thisArg]);
Параметры
callback - Функция, которая будет вызвана для каждого элемента массива. Она принимает от одного до трёх аргументов:

currentValue - Текущий обрабатываемый элемент в массиве.

index Необязательный - Индекс текущего обрабатываемого элемента в массиве.

array Необязательный - Массив, по которому осуществляется проход.

thisArg - Необязательный параметр. Значение, используемое в качестве this при вызове функции callback.

Возвращаемое значение
undefined.

Описание
Метод forEach() выполняет функцию callback один раз для каждого элемента, находящегося в массиве в порядке возрастания. Она не будет вызвана для удалённых или пропущенных элементов массива. Однако, она будет вызвана для элементов, которые присутствуют в массиве и имеют значение undefined.

Функция callback будет вызвана с тремя аргументами:

значение элемента (value)
индекс элемента (index)
массив, по которому осуществляется проход (array)
Если в метод forEach() был передан параметр thisArg, при вызове callback он будет использоваться в качестве значения this. В противном случае, в качестве значения this будет использоваться значение undefined. В конечном итоге, значение this, наблюдаемое из функции callback, определяется согласно обычным правилам определения this, видимого из функции.

Диапазон элементов, обрабатываемых методом forEach(), устанавливается до первого вызова функции callback. Элементы, добавленные в массив после начала выполнения метода forEach(), не будут посещены функцией callback. Если существующие элементы массива изменятся, значения, переданные в функцию callback, будут значениями на тот момент времени, когда метод forEach() посетит их; удалённые элементы посещены не будут. Если уже посещённые элементы удаляются во время итерации (например, с помощью shift()), последующие элементы будут пропущены. (Смотри пример ниже)

Примечание: Не существует способа остановить или прервать цикл forEach() кроме как выбрасыванием исключения. Если вам необходимо такое поведение, метод forEach() неправильный выбор.

Досрочное прекращение может быть достигнуто с:

Простой цикл for
Циклы for...of / for...in
Array.prototype.every()
Array.prototype.some()
Array.prototype.find()
Array.prototype.findIndex()
Если нужно протестировать элементы массива на условие и нужно вернуть булево значение, вы можете воспользоваться методами every(), some(), find() или findIndex().

Метод forEach() выполняет функцию callback один раз для каждого элемента массива; в отличие от методов every() и some(), он всегда возвращает значение undefined.

Примеры
Нет операции для неинициализированных значений (разреженные массивы)
*/
const arraySparse = [1, 3, , 7];
let numCallbackRuns = 0;

arraySparse.forEach((element) => {
    console.log(element);
    numCallbackRuns++;
});

console.log("numCallbackRuns: ", numCallbackRuns);

// 1
// 3
// 7
// numCallbackRuns: 3
// комментарий: как вы видите пропущенное значение между 3 и 7 не вызывало функцию callback.

// Конвертируем цикл for в forEach

const items = ["item1", "item2", "item3"];
const copy1 = [];
const copy2 = [];

// до
for (let i = 0; i < items.length; i++) {
    copy1.push(items[i]);
}

console.log(copy1); //  [ 'item1', 'item2', 'item3' ]
// после
items.forEach(function (item) {
    copy2.push(item);
});

console.log(copy2);  // [ 'item1', 'item2', 'item3' ]
console.table(copy2);
/*

┌─────────┬─────────┐
│ (index) │ Values  │
├─────────┼─────────┤
│ 0       │ 'item1' │
│ 1       │ 'item2' │
│ 2       │ 'item3' │
└─────────┴─────────┘



Печать содержимого массива
Примечание: Для отображения содержимого массива в консоли вы можете использовать console.table(), который выводит отформатированную версию массива.

Следующий пример иллюстрирует альтернативный подход, использующий forEach().

Следующий код выводит каждый элемент массива на новой строке журнала:
*/

function logArrayElements(element, index, array) {
    console.log("a[" + index + "] = " + element);
}

// Обратите внимание на пропуск по индексу 2, там нет элемента, поэтому он не посещается
[2, 5, , 9].forEach(logArrayElements);
// логи:
// a[0] = 2
// a[1] = 5
// a[3] = 9

/*
Использование thisArg
Следующий (надуманный) пример обновляет свойства объекта, когда перебирает записи массива:
*/

function Counter() {
    this.sum = 0;
    this.count = 0;
}
Counter.prototype.add = function (array) {
    array.forEach((entry) => {
        this.sum += entry;
        ++this.count;
    }, this);
    // ^---- Note
};

const objCount = new Counter();
objCount.add([2, 5, 9]);
console.log(objCount.count);  // 3
console.log(objCount.sum);   // 16

/*
Поскольку в forEach() передан параметр thisArg (this), он затем передаётся в callback при каждом вызове. И callback использует его в качестве собственного значения this.

Примечание: Если при передаче callback функции используется выражение стрелочной функции, параметр thisArg может быть опущен, так как все стрелочные функции лексически привязываются к значению this.

Прерывание цикла
Следующий код использует Array.prototype.every() для логирования содержимого массива и останавливается при превышении значением заданного порогового значения THRESHOLD.
*/

let THRESHOLD = 12;
const vector = [5, 2, 16, 4, 3, 18, 20];
let res;

res = vector.every(function (element, index, array) {
    console.log("element:", element);
    if (element >= THRESHOLD) {
        return false;
    }

    return true;
});
console.log("res:", res);  // res: false
// логи:
// element: 5
// element: 2
// element: 16
// every() - все элементы должны соответствовать функции

res = vector.some(function (element, index, array) {
    console.log("element:", element);
    if (element >= THRESHOLD) {
        return true;
    }

    return false;
});
console.log("res:", res);  // res: true
// логи:
// element: 5
// element: 2
// element: 16
// хотя бы 1 элемент должен соответствовать функции

/*
Функция копирования объекта
Следующий код создаёт копию переданного объекта. Существует несколько способов создания копии объекта, и это один из них. Он позволяет понять, каким образом работает Array.prototype.forEach(), используя функции мета-свойств Object.* из ECMAScript 5.
*/

function copy(o) {
    let copy = Object.create(Object.getPrototypeOf(o));
    let propNames = Object.getOwnPropertyNames(o);

    propNames.forEach(function (name) {
        let desc = Object.getOwnPropertyDescriptor(o, name);
        Object.defineProperty(copy, name, desc);
    });

    return copy;
}

let o1 = { a: 1, b: 2 };
console.log(o1);  // { a: 1, b: 2 }
let o2 = copy(o1); // теперь o2 выглядит также, как и o1
console.log(o2);  // { a: 1, b: 2 }
// но это разные объекты
o2.c = 3;
console.log(o1);  // { a: 1, b: 2 }
console.table(o2);  // { a: 1, b: 2, c: 3 }

/*
Модификация массива во время итерации
В следующем примере в лог выводится "one", "two", "four".

При достижении записи, содержащей значение 'two', первая запись всего массива удаляется, в результате чего все оставшиеся записи перемещаются на одну позицию вверх. Поскольку элемент 'four' теперь находится на более ранней позиции в массиве, 'three' будет пропущен.

forEach() не делает копию массива перед итерацией.
*/

let words5 = ["one", "two", "three", "four"];
words5.forEach((word) => {
    console.log(word);
    if (word === "two") {
        words5.shift();
    }
});
// one
// two
// four

/*
Выравнивание (уплощение) массива
Следующий пример приведён только для целей обучения. Если вы хотите выравнять массив с помощью встроенных методов, вы можете использовать Array.prototype.flat()
*/

function flatten(arr) {
    const result = [];

    arr.forEach((i) => {
        if (Array.isArray(i)) {
            result.push(...flatten(i));
        } else {
            result.push(i);
        }
    });

    return result;
}

// Usage
const nested = [1, 2, 3, [4, 5, [6, 7], 8, 9]];

console.log(flatten(nested)); // [1, 2, 3, 4, 5, 6, 7, 8, 9]



console.log("**Для преобразования массива*************************");


console.log("**15)Array map()************************");
/*
Метод map() создаёт новый массив с результатом вызова указанной функции для каждого элемента массива.

Синтаксис
const new_array = arr.map(function callback( currentValue[, index[, array]]) {
    // Возвращает элемент для new_array
}[, thisArg])
Параметры
callback - Функция, вызываемая для каждого элемента массива arr. Каждый раз, когда callback выполняется, возвращаемое значение добавляется в new_array.

Функция callback, создающая элемент в новом массиве, принимает три аргумента:

currentValue - Текущий обрабатываемый элемент массива.

indexНеобязательный 
Индекс текущего обрабатываемого элемента в массиве.

arrayНеобязательный
Массив, по которому осуществляется проход.

thisArgНеобязательный
Необязательный параметр. Значение, используемое в качестве this при вызове функции callback

Возвращаемое значение
Новый массив, где каждый элемент является результатом callback функции.

Описание
Метод map вызывает переданную функцию callback один раз для каждого элемента, в порядке их появления и конструирует новый массив из результатов её вызова. Функция callback вызывается только для индексов массива, имеющих присвоенные значения, включая undefined. Она не вызывается для пропущенных элементов массива (то есть для индексов, которые никогда не были заданы, которые были удалены или которым никогда не было присвоено значение.

Функция callback вызывается с тремя аргументами: значением элемента, индексом элемента и массивом, по которому осуществляется проход.

Если в метод map был передан параметр thisArg, при вызове callback он будет использоваться в качестве значения this. В противном случае в качестве значения this будет использоваться значение undefined. В конечном итоге, значение this, наблюдаемое из функции callback, определяется согласно обычным правилам определения this, видимого из функции.

Метод map не изменяет массив, для которого он был вызван (хотя функция callback может это делать).

Диапазон элементов, обрабатываемых методом map, устанавливается до первого вызова функции callback. Элементы, добавленные в массив после начала выполнения метода map, не будут посещены функцией callback. Если существующие элементы массива изменяются функцией callback, их значения, переданные в функцию, будут значениями на тот момент времени, когда метод map посетит их; удалённые элементы посещены не будут.

Примеры
Пример: отображение массива чисел на массив квадратных корней
Следующий код берёт массив чисел и создаёт новый массив, содержащий квадратные корни чисел из первого массива.
*/

const numbers7 = [1, 4, 9];
const roots = numbers7.map(Math.sqrt);
console.log(numbers7);  // [1, 4, 9]
console.log(roots);  // [ 1, 2, 3 ]
// теперь roots равен [1, 2, 3], а numbers7 всё ещё равен [1, 4, 9]

/*
Пример: отображение массива чисел с использованием функции, содержащей аргумент
Следующий код показывает, как работает отображение, когда функция требует один аргумент. Аргумент будет автоматически присваиваться каждому элементу массива, когда map проходит по оригинальному массиву.
*/

const numbers8 = [1, 4, 9];
const doubles8 = numbers8.map((num) => num * 2);
console.log(numbers8);  // [1, 4, 9]
console.log(doubles8);  // [ 2, 8, 18 ]

// теперь doubles равен [2, 8, 18], а numbers8 всё ещё равен [1, 4, 9]
/*
Пример: обобщённое использование map
Этот пример показывает, как использовать map на объекте строки String для получения массива байт в кодировке ASCII, представляющего значения символов:
*/

const mapArr = Array.prototype.map;
const charCodes = mapArr.call("Hello World", (x) => x.charCodeAt(0));
console.log(charCodes);

// теперь charCodes равен [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]
/*
Пример: обобщённое использование map вместе с querySelectorAll
Этот пример показывает, как пройтись по коллекции объектов, собранных с помощью querySelectorAll. В данном случае мы получаем все выбранные опции на экране и печатаем их в консоль:

const elems = document.querySelectorAll("select option:checked");
const values = Array.prototype.map.call(elems, ({ value }) => value);
Более простым способом будет использование метода Array.from().

Пример: использование map для переворачивания строки
*/
const string = "12345";
const reversed = Array.prototype.map
    .call(string, (x) => x)
    .reverse()
    .join("");
// reversed равен '54321'
// Бонус: используйте '===' для проверки того, является ли строка палиндромом

/*
Более простым способом будет использование метода String.split() .

Пример: хитрый вариант использования

Распространённой практикой является использование колбэк-функции с одним аргументом (элемент, над которым производится операция). Некоторые функции также широко используется с одним аргументом, хотя они принимают дополнительные необязательные аргументы. Эти привычки могут привести к неожиданному поведению программы.
*/
// Рассмотрим пример:
["1", "2", "3"].map(parseInt);
console.log(["1", "2", "3"].map(parseInt));

// Хотя ожидаемый результат вызова равен [1, 2, 3],
// в действительности получаем [1, NaN, NaN]

// Функция parseInt часто используется с одним аргументом, но она принимает два.
// Первый аргумент является выражением, а второй - основанием системы счисления.
// В функцию callback Array.prototype.map передаёт 3 аргумента:
// элемент, его индекс и сам массив.
// Третий аргумент игнорируется parseInt, но не второй, следовательно,
// возможна путаница.

const returnInt = (element) => parseInt(element, 10);

["1", "2", "3"].map(returnInt);
// Результатом является массив чисел (как и ожидалось)

// Простейший способ добиться вышеозначенного поведения и избежать чувства "чё за!?":
["1", "2", "3"].map(Number); // [1, 2, 3]



console.log("**16)Array sort()************************");

/*
Метод sort() на месте сортирует элементы массива и возвращает отсортированный массив. Сортировка не обязательно устойчива (англ.). Порядок сортировки по умолчанию соответствует порядку кодовых точек Unicode.

Синтаксис
arr.sort([compareFunction])
Параметры
compareFunction
Необязательный параметр. Указывает функцию, определяющую порядок сортировки. Если опущен, массив сортируется в соответствии со значениями кодовых точек каждого символа Unicode, полученных путём преобразования каждого элемента в строку.

Возвращаемое значение
Отсортированный массив. Важно, что копия массива не создаётся - массив сортируется на месте.

Описание
Если функция сравнения compareFunction не предоставляется, элементы сортируются путём преобразования их в строки и сравнения строк в порядке следования кодовых точек Unicode. Например, слово "Вишня" идёт перед словом "бананы". При числовой сортировке, 9 идёт перед 80, но поскольку числа преобразуются в строки, то "80" идёт перед "9" в соответствии с порядком в Unicode.
*/

console.log("я".charCodeAt(0))  // 1103
console.log("Ё".charCodeAt(0))  // 1025

const fruit7 = ["арбузы", "бананы", "Вишня"];
console.log(fruit7.sort()); // ['Вишня', 'арбузы', 'бананы']

const scores2 = [1, 2, 10, 21];
scores2.sort(); // [1, 10, 2, 21]
console.log(scores2);

const things2 = ["слово", "Слово", "1 Слово", "2 Слова"];
things2.sort(); // ['1 Слово', '2 Слова', 'Слово', 'слово']
console.log(things2)
/*
// В Unicode, числа находятся перед буквами в верхнем регистре,
// а те, в свою очередь, перед буквами в нижнем регистре.
Если функция сравнения compareFunction предоставлена, элементы массива сортируются в соответствии с её возвращаемым значением. Если сравниваются два элемента a и b, то:

Если compareFunction(a, b) меньше 0, сортировка поставит a по меньшему индексу, чем b, то есть, a идёт первым.
Если compareFunction(a, b) вернёт 0, сортировка оставит a и b неизменными по отношению друг к другу, но отсортирует их по отношению ко всем другим элементам. Обратите внимание: стандарт ECMAscript не гарантирует данное поведение, и ему следуют не все браузеры (например, версии Mozilla по крайней мере, до 2003 года).
Если compareFunction(a, b) больше 0, сортировка поставит b по меньшему индексу, чем a.
Функция compareFunction(a, b) должна всегда возвращать одинаковое значение для определённой пары элементов a и b. Если будут возвращаться непоследовательные результаты, порядок сортировки будет не определён.
Итак, функция сравнения имеет следующую форму:

 
function compare(a, b) {
  if (a меньше b по некоторому критерию сортировки) {
    return -1;
  }
  if (a больше b по некоторому критерию сортировки) {
    return 1;
  }
  // a должно быть равным b
  return 0;
}
Для числового сравнения, вместо строкового, функция сравнения может просто вычитать b из a. 

Следующая функция будет сортировать массив по возрастанию:


function compareNumbers(a, b) {
  return a - b;
}


Метод sort можно удобно использовать с функциональными выражениями (и замыканиями):
*/

const numbers9 = [4, 2, 5, 1, 3];
numbers9.sort(function (a, b) {
    return a - b;
});
console.log(numbers9); // [1, 2, 3, 4, 5]

console.log([12, 25, 1, 2, 28].sort());  //  [ 1, 12, 2, 25, 28 ]

console.log([12, 25, 1, 2, 28].sort(function (a, b) { return a - b; }));  //  [ 1, 2, 12, 25, 28 ]

console.log([12, 25, 1, 2, 28].sort((a, b) => a - b));  // [ 1, 2, 12, 25, 28 ]

console.log(["s", "S", "sab", "zts"].sort());  // [ 'S', 's', 'sab', 'zts' ]
console.log(["s", "S", "sab", "zts"].sort((a, b) => b.localeCompare(a)));  // [ 'zts', 'sab', 'S', 's' ]

/*
Для сортировки строк по убыванию нужно использовать b.localeCompare(a)
Объекты могут быть отсортированы по значению одного из своих свойств.
*/

const items3 = [
    { name: "Edward", value: 21 },
    { name: "Sharpe", value: 37 },
    { name: "And", value: 45 },
    { name: "The", value: -12 },
    { name: "Magnetic" },
    { name: "Zeros", value: 37 },
];
items3.sort(function (a, b) {
    if (a.name > b.name) {
        return 1;
    }
    if (a.name < b.name) {
        return -1;
    }
    // a должно быть равным b
    return 0;
});

console.log(items3);
/*
выведет:
[
  { name: 'And', value: 45 },
  { name: 'Edward', value: 21 },
  { name: 'Magnetic' },
  { name: 'Sharpe', value: 37 },
  { name: 'The', value: -12 },
  { name: 'Zeros', value: 37 }
]


Примеры
Пример: создание, отображение и сортировка массива
В следующем примере создаётся четыре массива, сначала отображается первоначальный массив, а затем они сортируются. Числовые массивы сортируются сначала без, а потом с функцией сравнения.
*/

const stringArray = ["Голубая", "Горбатая", "Белуга"];
const numericStringArray = ["80", "9", "700"];
const numberArray = [40, 1, 5, 200];
const mixedNumericArray = ["80", "9", "700", 40, 1, 5, 200];

function compareNumbers(a, b) {
    return a - b;
}

// снова предполагаем, что функция печати определена
console.log("stringArray: ", stringArray.join());
console.log("Сортировка: ", stringArray.sort());

console.log("numberArray: ", numberArray.join());
console.log("Сортировка без функции сравнения: ", numberArray.sort());
console.log(
    "Сортировка с функцией compareNumbers: ",
    numberArray.sort(compareNumbers),
);

console.log("numericStringArray: ", numericStringArray.join());
console.log("Сортировка без функции сравнения: ", numericStringArray.sort());
console.log(
    "Сортировка с функцией compareNumbers: ",
    numericStringArray.sort(compareNumbers),
);

console.log("mixedNumericArray: ", mixedNumericArray.join());
console.log("Сортировка без функции сравнения: ", mixedNumericArray.sort());
console.log(
    "Сортировка с функцией compareNumbers: ",
    mixedNumericArray.sort(compareNumbers),
);

/*
Этот пример произведёт следующий вывод. Как показывает вывод, когда используется функция сравнения, числа сортируются корректно вне зависимости от того, являются ли они собственно числами или строками с числами.

stringArray: Голубая,Горбатая,Белуга
Сортировка: Белуга,Голубая,Горбатая

numberArray: 40,1,5,200
Сортировка без функции сравнения: 1,200,40,5
Сортировка с функцией compareNumbers: 1,5,40,200

numericStringArray: 80,9,700
Сортировка без функции сравнения: 700,80,9
Сортировка с функцией compareNumbers: 9,80,700

mixedNumericArray: 80,9,700,40,1,5,200
Сортировка без функции сравнения: 1,200,40,5,700,80,9
Сортировка с функцией compareNumbers: 1,5,9,40,80,200,700


Пример: сортировка не-ASCII символов
Для сортировки строк с не-ASCII символами, то есть строк с символами акцента (e, é, è, a, ä и т.д.), строк, с языками, отличными от английского: используйте String.localeCompare. Эта функция может сравнивать эти символы, чтобы они становились в правильном порядке.
*/

const items4 = ["réservé", "premier", "cliché", "communiqué", "café", "adieu"];
items4.sort(function (a, b) {
    return a.localeCompare(b);
});
console.log(items4);

// items4 равен ['adieu', 'café', 'cliché', 'communiqué', 'premier', 'réservé']

/*
Пример: сортировка c помощью map
Функция сравнения (compareFunction) может вызываться несколько раз для каждого элемента в массиве. В зависимости от природы функции сравнения, это может привести к высоким расходам ресурсов. Чем более сложна функция сравнения и чем больше элементов требуется отсортировать, тем разумнее использовать map для сортировки. 
Идея состоит в том, чтобы обойти массив один раз, чтобы извлечь фактические значения, используемые для сортировки, во временный массив, отсортировать временный массив, а затем обойти временный массив для получения правильного порядка.
*/

// массив для сортировки
const list2 = ["Дельта", "альфа", "ЧАРЛИ", "браво"];

// временный массив содержит объекты с позицией и значением сортировки
const mapped = list2.map(function (el, i) {
    return { index: i, value: el.toLowerCase() };
});

// сортируем массив, содержащий уменьшенные значения
mapped.sort(function (a, b) {
    if (a.value > b.value) {
        return 1;
    }
    if (a.value < b.value) {
        return -1;
    }
    return 0;
});

// контейнер для результа
const result7 = mapped.map(function (el) {
    return list2[el.index];
});[
    { index: 1, value: 'альфа' },
    { index: 3, value: 'браво' },
    { index: 0, value: 'дельта' },
    { index: 2, value: 'чарли' }
]

console.log(mapped); // [
//     { index: 1, value: 'альфа' },
//     { index: 3, value: 'браво' },
//     { index: 0, value: 'дельта' },
//     { index: 2, value: 'чарли' }
//   ]

console.log(result7); // [ 'альфа', 'браво', 'Дельта', 'ЧАРЛИ' ]

console.log(list2);  // [ 'Дельта', 'альфа', 'ЧАРЛИ', 'браво' ]


console.log("**17)Array reverse()************************");

/*
Метод reverse() на месте обращает порядок следования элементов массива. Первый элемент массива становится последним, а последний — первым.

пример
*/
const array5 = ["one", "two", "three"];
console.log("array5: ", array5);  // array5: [ 'one', 'two', 'three' ]

const reversed2 = array5.reverse();
console.log("reversed: ", reversed2); // reversed:  [ 'three', 'two', 'one' ]
console.log("array5: ", array5); // изменился начальный массив array5: [ 'three', 'two', 'one' ]

/*
Синтаксис
array.reverse()
Параметры
Нет.

Возвращаемое значение
Перевёрнутый массив

Описание
Метод reverse() на месте переставляет элементы массива, на котором он был вызван, изменяет массив и возвращает ссылку на него.

Примеры
Пример: обращение порядка элементов в массиве
В следующем примере создаётся массив myArray, содержащий три элемента, а затем массив переворачивается.
*/
const myArray = ["один", "два", "три"];
myArray.reverse();

console.log(myArray); // ['три', 'два', 'один']


console.log("**19)Array reduce()************************");

/*
Метод reduce() применяет функцию reducer к каждому элементу массива (слева-направо), возвращая одно результирующее значение.

 пример
*/
const numbersArr = [1, 2, 3, 4];

const initialValue = 0;
const sumWithInitial = numbersArr.reduce(
    (accumulator, currentValue) => accumulator + currentValue, initialValue,
);

console.log(sumWithInitial);  // 10
/*
Синтаксис
array.reduce(callback[, initialValue])
Параметры
callback
Функция, выполняющаяся для каждого элемента массива, принимает четыре аргумента:

accumulator
Аккумулятор, аккумулирующий значение, которое возвращает функция callback после посещения очередного элемента, либо значение initialValue, если оно предоставлено (смотрите пояснения ниже).

currentValue
Текущий обрабатываемый элемент массива.

indexНеобязательный
Индекс текущего обрабатываемого элемента массива.

arrayНеобязательный
Массив, для которого была вызвана функция reduce.

initialValueНеобязательный
Необязательный параметр. Объект, используемый в качестве первого аргумента при первом вызове функции callback.

Описание
Метод reduce() выполняет функцию callback один раз для каждого элемента, присутствующего в массиве, за исключением пустот, принимая четыре аргумента: начальное значение (или значение от предыдущего вызова callback), значение текущего элемента, текущий индекс и массив, по которому происходит итерация.

При первом вызове функции, параметры accumulator и currentValue могут принимать одно из двух значений. Если при вызове reduce() передан аргумент initialValue, то значение accumulator будет равным значению initialValue, а значение currentValue будет равным первому значению в массиве. Если аргумент initialValue не задан, то значение accumulator будет равным первому значению в массиве, а значение currentValue будет равным второму значению в массиве.

Если массив пустой и аргумент initialValue не указан, будет брошено исключение TypeError. Если массив состоит только из одного элемента (независимо от его положения в массиве) и аргумент initialValue не указан, или если аргумент initialValue указан, но массив пустой, то будет возвращено одно это значение, без вызова функции callback.

Предположим, что reduce() используется следующим образом:
*/
[0, 1, 2, 3, 4].reduce(function (previousValue, currentValue, index, array) {
    return previousValue + currentValue;
});
/*
Колбэк-функция будет вызвана четыре раза, аргументы и возвращаемое значение при каждом вызове будут следующими:

    previousValue	index   array	 
            currentValue          возвращаемое значение
первый вызов	0	1	1	[0, 1, 2, 3, 4]	1
второй вызов	1	2	2	[0, 1, 2, 3, 4]	3
третий вызов	3	3	3	[0, 1, 2, 3, 4]	6
четвёртый вызов	6	4	4	[0, 1, 2, 3, 4]	10
Значение, возвращённое методом reduce() будет равным последнему результату выполнения колбэк-функции — 10.

Если же вы зададите начальное значение initialValue, результат будет выглядеть так:
*/

[0, 1, 2, 3, 4].reduce(function (accumulator, currentValue, index, array) {
    return accumulator + currentValue;
}, 10);
/*
            accumulator	currentValue	index	array	        возвращаемое значение
первый вызов	10	        0	            0	[0, 1, 2, 3, 4]	        10
второй вызов	10	        1	            1	[0, 1, 2, 3, 4]	        11
третий вызов	11	        2	            2	[0, 1, 2, 3, 4]	        13
четвёртый вызов	13	        3	            3	[0, 1, 2, 3, 4]	        16
пятый вызов	    16	        4	            4	[0, 1, 2, 3, 4]	        20

Значение, возвращённое методом reduce() на этот раз, конечно же, будет равным 20.

Примеры
Суммирование всех значений в массиве
*/
let total = [0, 1, 2, 3].reduce(function (a, b) {
    return a + b;
});
console.log(total);  // total == 6
/*
Суммирование значений в массиве объектов
Чтобы суммировать значения, содержащиеся в массиве объектов, вы должны указать initialValue, чтобы каждый элемент смог пройти через callback.
*/
let initialValueZero = 0;
var sum2 = [{ x: 1 }, { x: 2 }, { x: 3 }].reduce(function (
    accumulator,
    currentValue,
) {
    return accumulator + currentValue.x;
}, initialValueZero);

console.log(sum2);
// sum2 == 6
/*
Тоже самое, но со стрелочной функцией:
*/
let zeroInitialValue = 0;
var sum3 = [{ x: 1 }, { x: 2 }, { x: 3 }].reduce(
    (accumulator, currentValue) => accumulator + currentValue.x,
    zeroInitialValue,
);
// sum3 == 6
/*
Разворачивание массива массивов
*/
const flattened = [
    [0, 1],
    [2, 3],
    [4, 5],
].reduce(function (a, b) {
    return a.concat(b);
});

console.log(flattened);  // flattened равен [0, 1, 2, 3, 4, 5]
/*
Пример: склеивание массивов, содержащихся в объектах массива, с использованием оператора расширения и initialValue
*/

// friends - список из объектов(друзей)
// где поле "books" - список любимых книг друга
const friends = [
    { name: "Anna", books: ["Bible", "Harry Potter"], age: 21 },
    { name: "Bob", books: ["War and peace", "Romeo and Juliet"], age: 26 },
    { name: "Alice", books: ["The Lord of the Rings", "The Shining"], age: 18 },
];

// allbooks - список, который будет содержать все книги друзей +
// дополнительный список указанный в initialValue (previous); current - текущий элемент массива=книги текущего друга
const allbooks = friends.reduce(
    function (prev, curr) {
        return [...prev, ...curr.books];
    },
    ["Alphabet"],
);

console.log(allbooks);
// allbooks = ["Alphabet", "Bible", "Harry Potter", "War and peace",
// "Romeo and Juliet", "The Lord of the Rings", "The Shining"]
// [][][]


console.log("**20)Array reduceRight()********************");
/*
Метод reduceRight() применяет функцию к аккумулятору и каждому значению массива (справа-налево), сводя его к одному значению.

Синтаксис
arr.reduceRight(callback[, initialValue])
Параметры
callback - Функция, выполняющаяся для каждого элемента массива, принимает четыре аргумента:

previousValue
Значение, возвращённое предыдущим выполнением функции callback, либо значение initialValue, если оно предоставлено (смотрите пояснения ниже).

currentValue - Текущий обрабатываемый элемент массива.

index - Индекс текущего обрабатываемого элемента массива.

array - Массив, для которого была вызвана функция reduceRight.

initialValue
Необязательный параметр. Объект, используемый в качестве первого аргумента при первом вызове функции callback.

Описание
Метод reduceRight() выполняет функцию callback один раз для каждого элемента, присутствующего в массиве, за исключением пустот, принимая четыре аргумента: начальное значение (или значение от предыдущего вызова callback), значение текущего элемента, текущий индекс и массив, по которому происходит итерация.

Вызов колбэк-функции callback будет выглядеть так:

array.reduceRight(function (previousValue, currentValue, index, array) {
  // ...
});
При первом вызове функции, параметры previousValue и currentValue могут принимать одно из двух значений. Если при вызове reduceRight() передан аргумент initialValue, то значение previousValue будет равным значению initialValue, а значение currentValue будет равным последнему значению в массиве. Если аргумент initialValue не задан, то значение previousValue будет равным последнему значению в массиве, а значение currentValue будет равным второму с конца значению в массиве.

Если массив пустой и аргумент initialValue не указан, будет брошено исключение TypeError. Если массив состоит только из одного элемента (независимо от его положения в массиве) и аргумент initialValue не указан, или если аргумент initialValue указан, но массив пустой, то будет возвращено одно это значение, без вызова функции callback.

Вот так будут выглядеть некоторый примеры прогона функции:
*/

[0, 1, 2, 3, 4].reduceRight(
    function (previousValue, currentValue, index, array) {
        return previousValue + currentValue;
    },
);
/*
Колбэк-функция будет вызвана четыре раза, аргументы и возвращаемое значение при каждом вызове будут следующими:

        previousValue	currentValue	index	    array	    возвращаемое значение
первый вызов	4	        3	            3	[0, 1, 2, 3, 4]	        7
второй вызов	7	        2	            2	[0, 1, 2, 3, 4]	        9
третий вызов	9	        1	            1	[0, 1, 2, 3, 4]	        10
четвёртый вызов	10	        0	            0	[0, 1, 2, 3, 4]	        10
Значение, возвращённое методом reduceRight() будет равным последнему результату выполнения колбэк-функции — 10.

Если же вы зададите начальное значение initialValue, результат будет выглядеть так:
*/

[0, 1, 2, 3, 4].reduceRight(function (
    previousValue,
    currentValue,
    index,
    array,
) {
    return previousValue + currentValue;
}, 10);
/*
            previousValue	currentValue	index	    array	     возвращаемое значение
первый вызов	10	            4	          4	    [0, 1, 2, 3, 4]	    14  
второй вызов	14	            3	          3	    [0, 1, 2, 3, 4]	    17
третий вызов	17	            2	          2	    [0, 1, 2, 3, 4]	    19
четвёртый вызов	19	            1	          1	    [0, 1, 2, 3, 4]	    20
пятый вызов	    20	            0	          0	    [0, 1, 2, 3, 4]	    20
Значение, возвращённое методом reduceRight() на этот раз, конечно же, будет равным 20.

Примеры
Пример: суммирование всех значений в массиве
*/
const total2 = [0, 1, 2, 3].reduceRight(function (a, b) {
    return a + b;
});
console.log(total2); // total2 == 6

/*
Пример: разворачивание массива массивов
*/
const flattened2 = [
    [0, 1],
    [2, 3],
    [4, 5],
].reduceRight(function (a, b) {
    return a.concat(b);
}, []);
console.log(flattened2); // flattened2 равен [4, 5, 2, 3, 0, 1]
