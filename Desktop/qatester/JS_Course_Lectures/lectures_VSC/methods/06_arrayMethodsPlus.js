/*
Array Basic Methods 

1. Array length
2. Array toString()
3. Array at()
4. Array join()
5. Array pop()
6. Array push()
7. Array shift()
8. Array unshift()
9. Array delete()
10. Array concat()
11. Array copyWithin()
12. Array flat()
13. Array splice()
14. Array toSpliced()
15. Array slice()
*/

/*
16. Array.of()
17. Array.fill()

Array Find and Search Methods************************

18. Array indexOf()
19. Array lastIndexOf()
20. Array includes()
21. Array find()
22. Array findIndex()
23. Array findLast()
24. Array findLastIndex()

JavaScript Sorting Arrays****************************

Alpabetic Sort**
25. Array sort()
26. Array reverse()
27. Array toSorted()
28. Array toReversed()

Sorting Objects
	
29. Numeric Sort**
30. Numeric Sort
31. Random Sort
32. Math.min()
33. Math.max()
34. Home made Min()
35. Home made Max()

Array Iteration Methods*
Array iteration methods operate on every array item:

36. Array forEach
37. Array map()
38. Array flatMap()
39. Array filter()
40. Array reduce()
41. Array reduceRight()
42. Array every()
43. Array some()
44. Array from()
45. Array keys()
46. Array entries()
47. Array with()

48. Array Spread (...)
49. Array Rest (...)
50. Array Destucting 4_55_destructing
51. isArray 3_7_isArray
*****************************************************
Юникод Русский алфавит 
Кириллица (блок Юникода)
https://ru.wikipedia.org/wiki/%D0%9A%D0%B8%D1%80%D0%B8%D0%BB%D0%BB%D0%B8%D1%86%D0%B0_(%D0%B1%D0%BB%D0%BE%D0%BA_%D0%AE%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4%D0%B0)
ASCII
https://www.lookuptables.com/text/ascii-table
*/
console.log("1".charCodeAt(0)); // 49
console.log("A".charCodeAt(0)); // 65 англ. A
console.log("Z".charCodeAt(0)); // 90
console.log("А".charCodeAt(0)); // 1040 русская А
console.log("Я".charCodeAt(0)); // 1071
console.log("ё".charCodeAt(0)); // 1105
console.log("Ё".charCodeAt(0)); // 1025

/*
******************************************************
Шпаргалка по методам массива:

Для добавления/удаления элементов:

1) push(...items) – добавляет элементы в конец,
2) pop() – извлекает элемент с конца,
3) shift() – извлекает элемент с начала,
4) unshift(...items) – добавляет элементы в начало.
5) splice(pos, deleteCount, ...items) – начиная с ) индекса pos удаляет deleteCount элементов и вставляет items.
6) slice(start, end) – создаёт новый массив, копируя в него элементы с индекса start до end (не включая end).
7) concat(...items) – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items. Если какой-то из items является массивом, тогда берутся его элементы.

Для поиска среди элементов:

8, 9) indexOf/lastIndexOf(item, pos) – ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено.
10) includes(value) – возвращает true, если в массиве имеется элемент value, в противном случае false.
11, 12) find/filter(func) – фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых через функцию возвращается true.
13) findIndex похож на find, но возвращает индекс вместо значения.

Для перебора элементов:

14) forEach(func) – вызывает func для каждого элемента. Ничего не возвращает.

Для преобразования массива:

15) map(func) – создаёт новый массив из результатов вызова func для каждого элемента.
16) sort(func) – сортирует массив «на месте», а потом возвращает его.
17) reverse() – «на месте» меняет порядок следования элементов на противоположный и возвращает изменённый массив.
18) split/join – преобразует строку в массив и обратно.
19, 20) reduce/reduceRight(func, initial) – вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая промежуточный результат между вызовами.

Дополнительно:

21) Array.isArray(arr) проверяет, является ли arr массивом.
Пожалуйста, обратите внимание, что методы push, pop, shift, unshift, sort, reverse и splice изменяют исходный массив.

Эти методы – самые используемые, их достаточно в 99% случаев. 
*/

console.log("** Массив ************************");
/*
Объект Array, как и массивы в других языках программирования, позволяет хранить коллекцию из нескольких элементов под одним именем переменной и имеет методы для выполнения общих операций с массивами.

Описание
Массивы являются спископодобными объектами, чьи прототипы содержат методы для операций обхода и изменения массива. Ни размер JavaScript-массива, ни типы его элементов не являются фиксированными. Поскольку размер массива может увеличиваться и уменьшаться в любое время, то нет гарантии, что массив окажется плотным. То есть, при работе с массивом может возникнуть ситуация, что элемент массива, к которому вы обратитесь, будет пустым и вернёт undefined.

Доступ к элементам массива
Массивы в JavaScript индексируются с нуля: первый элемент массива имеет индекс, равный 0, а индекс последнего элемента равен значению свойства массива length минус 1.
*/
console.log("*******Доступ к элементам массива*********")
const arr = ["first element", "second element", "third element"];

console.log(arr[0]);  // first element
console.log(arr[arr.length - 1]);  // third element
console.log(arr[1]);  // second element

// Длина массива - свойство length.toExponential

let fruit = [];
fruit[5] = "Манго";

console.log(fruit[5]);  // Манго
console.log(Object.keys(fruit));  // [ '5' ]
console.log(fruit.length);  // 6
// можно увеличить длину массива
fruit.length = 10;
console.log(Object.keys(fruit));  // [ '5' ]

fruit.length = 2;
console.log(Object.keys(fruit));  // [  ]

console.log(fruit.length);  // 2

// Конструктор Array().

// Array[@@species] // возвращает конструктор Array
Array[Symbol.species];
console.log(Array[Symbol.species]);  // [Function: Array]

console.log("Array.of()*******************************");
/*
Метод Array.of() создаёт новый экземпляр массива Array из произвольного числа аргументов, вне зависимости от числа или типа аргумента.

Разница между Array.of() и конструктором new Array() заключается в обработке целочисленных аргументов: 
Array.of(7) создаёт массив с одним элементом 7, 
а Array(7) создаёт пустой массив со значением свойства length равным 7 (Замечание: подразумевается 7 пустых слотов, а не слоты со значением undefined).
*/

const arrOf = Array.of(7); // [7]
const arrOf1 = Array.of(1, 2, 3); // [1, 2, 3]

const arrArr = Array(7); // массив с 7 пустыми слотами [ <7 empty items> ]
const arrArr1 = Array(1, 2, 3); // [1, 2, 3]

console.log(arrOf);
console.log(arrOf1);
console.log(arrArr);  
console.log(arrArr1);

/*
Синтаксис
Array.of(element0[, element1[, ...[, elementN]]])
Параметры
elementN - Элементы, из которых создаётся массив.

Возвращаемое значение - Новый массив Array.

Описание
Эта функция является частью стандарта ECMAScript 6.

Примеры
*/

console.log(Array.of(1)); // [1]
console.log(Array.of(1, 2, 3)); // [1, 2, 3]
console.log(Array.of(undefined)); // [undefined]
/*
Полифил
Выполнение следующего кода перед любым другим кодом создаст метод Array.of(), если он ещё не реализован в браузере.

if (!Array.of) {
  Array.of = function() {
    return Array.prototype.slice.call(arguments);
    // Or
    let vals = []
    for(let prop in arguments){
        vals.push(arguments[prop])
    }
    return vals.slice()
}
*/

console.log("Array.fill()*******************************");
/*
Метод fill() заполняет все элементы массива от начального до конечного индексов одним значением.

*/

const arr12 = [1, 2, 3, 4];
// Fill with 0 from position 2 until position 4
console.log(arr12.fill(0, 2, 4));
// Expected output: Array [1, 2, 0, 0]

// Fill with 5 from position 1
console.log(arr12.fill(5, 1));
// Expected output: Array [1, 5, 5, 5]

console.log(arr12.fill(6));
// Expected output: Array [6, 6, 6, 6]

/*
Синтаксис
arr.fill(value[, start = 0[, end = this.length]])
Параметры
value - Значение, заполняющее массив.

start - Необязательный параметр. Начальный индекс.

end - Необязательный параметр. Конечный индекс.

Возвращаемое значение
Изменённый массив.

Описание
Элементы заполняются в полузакрытом интервале [start, end).

Метод fill принимает до трёх аргументов — value, start и end. Аргументы start и end являются необязательными со значениями по умолчанию, равными 0 и length объекта this соответственно.

Если аргумент start является отрицательным, он трактуется как length+start, где length — это длина массива. Если аргумент end является отрицательным, он трактуется как length+end.

Метод fill намеренно является обобщённым, он не требует, чтобы значение this внутри него было объектом Array.

Метод fill является изменяющим методом, он изменит объект this и вернёт его, а не просто вернёт копию.

Если аргумент value является объектом, то метод fill заполнит массив ссылками на этот объект.

Примеры
*/
[1, 2, 3].fill(4);               // [4, 4, 4]
[1, 2, 3].fill(4, 1);            // [1, 4, 4]
[1, 2, 3].fill(4, 1, 2);         // [1, 4, 3]
[1, 2, 3].fill(4, 1, 1);         // [1, 2, 3]
[1, 2, 3].fill(4, 3, 3);         // [1, 2, 3]
[1, 2, 3].fill(4, -3, -2);       // [4, 2, 3]
[1, 2, 3].fill(4, NaN, NaN);     // [1, 2, 3]
[1, 2, 3].fill(4, 3, 5);         // [1, 2, 3]
Array(3).fill(4);                // [4, 4, 4]
[].fill.call({ length: 3 }, 4);  // {0: 4, 1: 4, 2: 4, length: 3}

// Объекты заполняются по ссылке.
let arr14 = Array(3).fill({}) // [{}, {}, {}];
arr14[0].hi = "hi"; // [{ hi: "hi" }, { hi: "hi" }, { hi: "hi" }]
console.log(arr14);
/*
 метод `fill()` заполняет массив ссылками на один и тот же объект. По умолчанию он заполняет массив копиями значения, которое вы передаете в качестве аргумента. Однако, если это объект или массив, то копируется только ссылка на этот объект или массив, а не его содержимое.

Поэтому в примере, массив `arr14` содержит три ссылки на один и тот же объект `{}`, и когда вы обновляете свойство `hi` у одного из объектов, это изменение отражается во всех трех объектах массива, потому что все они на самом деле ссылаются на один и тот же объект в памяти.

Чтобы заполнить массив уникальными объектами, вы можете использовать метод `map()` с передачей нового объекта на каждой итерации:
*/

let arr15 = Array(3).fill().map(() => ({}));
arr15[0].hi = "hi"; // Теперь только один объект изменен
console.log(arr15);  // [ { hi: 'hi' }, {}, {} ]
/*
Теперь `arr14` будет содержать три уникальных объекта, и изменение одного из них не отразится на остальных.
*/

console.log("**Array Find and Search Methods**********");

console.log("**Array indexOf()**Popular**********************");
/*
Метод indexOf() возвращает первый индекс, по которому данный элемент может быть найден в массиве или -1, если такого индекса нет.

Синтаксис
arr.indexOf(searchElement[, fromIndex = 0])
Параметры
searchElement - Искомый элемент в массиве.

fromIndex 
Индекс, с которого начинать поиск. Если индекс больше или равен длине массива, возвращается -1, что означает, что массив даже не просматривается. Если индекс является отрицательным числом, он трактуется как смещение с конца массива. Обратите внимание: если индекс отрицателен, массив всё равно просматривается от начала к концу. Если рассчитанный индекс оказывается меньше 0, поиск ведётся по всему массиву. Значение по умолчанию равно 0, что означает, что просматривается весь массив.

Описание
Метод indexOf() сравнивает искомый элемент searchElement с элементами в массиве, используя строгое сравнение (en-US) (тот же метод используется оператором ===, тройное равно).

Примеры
Пример: использование indexOf()
В следующем примере indexOf() используется для поиска значений в массиве.
*/
const array7 = [2, 5, 9];

console.log(array7.indexOf(2)); // 0
console.log(array7.indexOf(7)); // -1
console.log(array7.indexOf(9, 2)); // 2
console.log(array7.indexOf(2, -1)); // -1
console.log(array7.indexOf(2, -3)); // 0

/*
Пример: нахождение всех вхождений элемента
В следующем примере indexOf() используется для поиска всех индексов элемента в указанном массиве, которые с помощью push() добавляются в другой массив.
*/

const indices = [];
const array = ["a", "b", "a", "c", "a", "d"];
const element = "a";
let idx = array.indexOf(element);
while (idx != -1) {
  indices.push(idx);
  idx = array.indexOf(element, idx + 1);
}

console.log(indices); // [0, 2, 4]


console.log("**Array lastIndexOf()**Popular*****************");

/*
Метод lastIndexOf() возвращает последний индекс, по которому данный элемент может быть найден в массиве или -1, если такого индекса нет. Массив просматривается от конца к началу, начиная с индекса fromIndex.

 пример
*/
const animals = ["Dodo", "Tiger", "Penguin", "Dodo"];

console.log(animals.lastIndexOf("Dodo"));  // 3
console.log(animals.lastIndexOf("Tiger"));  // 1


/*
Синтаксис
arr.lastIndexOf(searchElement[, fromIndex = arr.length])
Параметры
searchElement - Искомый элемент в массиве.

fromIndex
Необязательный параметр. Индекс, с которого начинать поиск в обратном направлении. Если индекс больше или равен длине массива, просматривается весь массив. Если индекс является отрицательным числом, он трактуется как смещение с конца массива. Обратите внимание: если индекс отрицателен, массив всё равно просматривается от конца к началу. Если рассчитанный индекс оказывается меньше 0, массив даже не просматривается. Значение по умолчанию равно длине массива, что означает, что просматривается весь массив.

Описание
Метод lastIndexOf() сравнивает искомый элемент searchElement с элементами в массиве, используя строгое сравнение (en-US) (тот же метод используется оператором ===, тройное равно).

Примеры
Пример: использование lastIndexOf()
В следующем примере метод lastIndexOf() используется для поиска значений в массиве.
*/
const arrayNumbers = [2, 5, 9, 2];
console.log(arrayNumbers.lastIndexOf(2)); // 3
console.log(arrayNumbers.lastIndexOf(7)); // -1
console.log(arrayNumbers.lastIndexOf(2, 3)); // 3
console.log(arrayNumbers.lastIndexOf(2, 2)); // 0
console.log(arrayNumbers.lastIndexOf(2, -2)); // 0
console.log(arrayNumbers.lastIndexOf(2, -1)); // 3
/*
Пример: нахождение всех вхождений элемента
В следующем примере метод lastIndexOf() используется для поиска всех индексов элемента в указанном массиве, которые с помощью метода push() добавляются в другой массив.
*/
const indicesLast = [];
const arrayLetters = ["a", "b", "a", "c", "a", "d"];
let elementFind = "a";
let idxLast = arrayLetters.lastIndexOf(elementFind);
while (idxLast != -1) {
  indicesLast.push(idxLast);
  idxLast = idxLast > 0 ? arrayLetters.lastIndexOf(element, idxLast - 1) : -1;
}

console.log(indicesLast);  // [4, 2, 0]

/*
Обратите внимание, что мы обрабатываем случай idxLast == 0 отдельно, поскольку элемент всегда будет найден, независимо от параметра fromIndex, если он является первым элементом в массиве. Этим он отличается от метода indexOf().
*/

console.log("**Array includes()**Popular********************");
/*
Метод includes() определяет, содержит ли массив определённый элемент, возвращая в зависимости от этого true или false.

 пример
*/
const arrDigits = [1, 2, 3];

console.log(arrDigits.includes(2));  // true

const pets = ["cat", "dog", "bat"];

console.log(pets.includes("cat"));  // true
console.log(pets.includes("ca"));  // false
/*
Синтаксис
arr.includes(searchElement[fromIndex = 0])
Параметры
searchElement - Искомый элемент.

fromIndex Необязательный
Позиция в массиве, с которой начинать поиск элемента searchElement. При отрицательных значениях поиск производится начиная с индекса array.length + fromIndex по возрастанию. Значение по умолчанию равно 0.

Возвращаемое значение
Boolean.

Примеры
*/
console.log([1, 2, 3].includes(2)); // true
console.log([1, 2, 3].includes(4)); // false
console.log([1, 2, 3].includes(3, 3)); // false
console.log([1, 2, 3].includes(3, -1)); // true
console.log([1, 2, NaN].includes(NaN)); // true

/*
fromIndex больше или равен длине массива
Если fromIndex больше или равен длине массива, то возвращается false. При этом поиск не производится.
*/

const arrLetters = ["a", "b", "c"];

console.log(arrLetters.includes("c", 3)); // false
console.log(arrLetters.includes("c", 100)); // false

/*
Вычисленный индекс меньше нуля 0
Если fromIndex отрицательный, то вычисляется индекс, начиная с которого будет производиться поиск элемента searchElement. Если вычисленный индекс меньше нуля, то поиск будет производиться во всём массиве.
*/
// длина массива равна 3
// fromIndex равен -100
// вычисленный индекс равен 3 + (-100) = -97

const arrLetters2 = ["a", "b", "c"];

console.log(arrLetters2.includes("a", -100)); // true
console.log(arrLetters2.includes("b", -100)); // true
console.log(arrLetters2.includes("c", -100)); // true

/*
Использование includes() в качестве общих метода
includes() специально сделан общим. Он не требует, чтобы this являлся массивом, так что он может быть применён к другим типам объектов (например, к массивоподобным объектам). Пример ниже показывает использование метода includes() на объекте arguments.
*/

(function () {
  console.log([].includes.call(arguments, "a")); // true
  console.log([].includes.call(arguments, "d")); // false
})("a", "b", "c");


console.log("**Array find()**Popular**********************");
/*
Метод find() возвращает значение первого найденного в массиве элемента, которое удовлетворяет условию переданному в callback функции. В противном случае возвращается undefined.

Также смотрите метод findIndex(), который возвращает индекс найденного в массиве элемента вместо его значения.

Если вам нужно найти позицию элемента или наличие элемента в массиве, используйте Array.prototype.indexOf() или Array.prototype.includes() соответственно.

Синтаксис
arr.find(callback[, thisArg])
Параметры
callback - Функция, вызывающаяся для каждого значения в массиве, принимает три аргумента:

element -Текущий обрабатываемый элемент в массиве.

index - Индекс текущего обрабатываемого элемента в массиве.

array - Массив, по которому осуществляется проход.

thisArg
Необязательный параметр. Значение, используемое в качестве this при выполнении функции callback.

Возвращаемое значение
Значение элемента из массива, если элемент прошёл проверку, иначе undefined.

Описание
Метод find вызывает переданную функцию callback один раз для каждого элемента, присутствующего в массиве, до тех пор, пока она не вернёт true. Если такой элемент найден, метод find немедленно вернёт значение этого элемента. В противном случае, метод find вернёт undefined.
Функция callback вызывается с тремя аргументами: значением элемента, индексом элемента и массивом, по которому осуществляется проход.

Если в метод find был передан параметр thisArg, при вызове callback он будет использоваться в качестве значения this. В противном случае в качестве значения this будет использоваться значение undefined.

Метод find не изменяет массив, для которого он был вызван.

Диапазон элементов, обрабатываемых методом find, устанавливается до первого вызова функции callback. Элементы, добавленные в массив после начала выполнения метода find, не будут посещены функцией callback. Если существующие, непосещение элементы массива изменяются функцией callback, их значения, переданные в функцию, будут значениями на тот момент времени когда метод find посетит их; удалённые элементы все ещё будут посещены.

Примеры

Пример: поиск простого числа в массиве
Следующий пример находит в массиве положительных чисел элемент, являющийся простым числом (либо возвращает undefined, если в массиве нет простых чисел).
*/

function isPrime1(element, index, array) {
   start = 2;
  while (start <= Math.sqrt(element)) {
    if (element % start++ < 1) {
      return false;
    }
  }
  return element > 1;
}

console.log([4, 6, 8, 12].find(isPrime1)); // undefined, не найдено
console.log([4, 5, 8, 12].find(isPrime1)); // 5


console.log("**Array findIndex()**Popular********************");
/*
Метод findIndex() возвращает индекс в массиве, если элемент удовлетворяет условию проверяющей функции. В противном случае возвращается -1.

Также смотрите метод find(), который возвращает значение найденного в массиве элемента вместо его индекса.

Синтаксис
arr.findIndex(callback[, thisArg])

Параметры
callback - Функция, вызывающаяся для каждого значения в массиве, принимает три аргумента:

element - Текущий обрабатываемый элемент в массиве.

index - Индекс текущего обрабатываемого элемента в массиве.

array - Массив, по которому осуществляется проход.

thisArg
Необязательный параметр. Значение, используемое в качестве this при выполнении функции callback.

Описание
Метод findIndex вызывает переданную функцию callback один раз для каждого элемента, присутствующего в массиве, до тех пор, пока она не вернёт true. Если такой элемент найден, метод findIndex немедленно вернёт индекс этого элемента. В противном случае, метод findIndex вернёт -1. Функция callback вызывается только для индексов массива, имеющих присвоенные значения; она не вызывается для индексов, которые были удалены или которым значения никогда не присваивались.

Функция callback вызывается с тремя аргументами: значением элемента, индексом элемента и массивом, по которому осуществляется проход.

Если в метод findIndex был передан параметр thisArg, при вызове callback он будет использоваться в качестве значения this. В противном случае в качестве значения this будет использоваться значение undefined.

Метод findIndex не изменяет массив, для которого он был вызван.

Диапазон элементов, обрабатываемых методом findIndex, устанавливается до первого вызова функции callback. Элементы, добавленные в массив после начала выполнения метода findIndex, не будут посещены функцией callback. Если существующие, непосещение элементы массива изменяются функцией callback, их значения, переданные в функцию, будут значениями на тот момент времени, когда метод findIndex посетит их; удалённые элементы посещены не будут.

Примеры
Пример: поиск индекса простого числа в массиве
Следующий пример находит в массиве индекс элемента, являющийся простым числом (либо возвращает -1, если в массиве нет простых чисел).
*/
function isPrime2(element, index, array) {
  var start = 2;
  while (start <= Math.sqrt(element)) {
    if (element % start++ < 1) {
      return false;
    }
  }
  return element > 1;
}

console.log([4, 6, 8, 12].findIndex(isPrime2)); // -1, не найдено
console.log([4, 6, 7, 12].findIndex(isPrime2)); // 2

testingTools = [
    "management tools", 
    "static testing tools", 
    "test design and implementation tools", 
    "test execution and coverage tools", 
    "Non-fanctional testing tools", 
    // "DevOps tools", 
    "Collaboration tools", 
    "tools supporting scalability and deployment standardization", 
    "any other tool"
];

testing = ["plan", "design", "DevOps tools", "test automation"]

function isTool(element, index, array) {
    return this.includes(element);
    // for (let i = 0; i <this.length; i++) {
    //     if (element === this[i]) {
    //         return true;
    //     }
    // }    
    // return false;
}

console.log(testing.findIndex(isTool, testingTools));

console.log("**Array findLast()***********************");
/*
Метод findLast()  выполняет итерацию по массиву в обратном порядке и возвращает значение первого элемента, удовлетворяющего предоставленной функции тестирования. Если ни один элемент не удовлетворяет функции тестирования, возвращается неопределенное значение.

Если вам нужно найти:

первый элемент, который соответствует, используйте find().
индекс последнего соответствующего элемента в массиве, используйте findLastIndex().
индекс значения, используйте indexOf(). (Это похоже на findIndex(), но проверяет каждый элемент на равенство значению вместо использования функции тестирования.)

Если значение существует в массиве, используйте include(). Опять же, он проверяет каждый элемент на равенство значению вместо использования функции тестирования.
если какой-либо элемент удовлетворяет предоставленной функции тестирования, используйте some().
*/
const digits3 = [5, 12, 50, 130, 44];

const found = digits3.findLast((el) => el > 45);

console.log(found);  // 130;
/*
Синтаксис
findLast(callbackFn)
findLast(callbackFn, thisArg)

Параметры
функция обратного вызова callback Fn
Функция, выполняемая для каждого элемента массива. Он должен возвращать истинное значение, чтобы указать, что соответствующий элемент был найден, и ложное значение в противном случае. Функция вызывается со следующими аргументами:

элемент - Текущий элемент массива, который обрабатывается.

индекс - Индекс текущего обрабатываемого элемента в массиве.

множество - Был вызван массив findLast().

thisArg Необязательный
Значение, которое будет использоваться при выполнении callbackFn. 

Возвращаемое значение
Последний элемент (с самым высоким индексом) в массиве, который удовлетворяет предоставленной функции тестирования; undefined, если соответствующий элемент не найден.

Описание
Метод findLast() является итеративным методом. Он вызывает предоставленную функцию callbackFn один раз для каждого элемента массива в порядке убывания индекса, пока callbackFn не вернет истинное значение. findLast() затем возвращает этот элемент и прекращает обход массива. Если callbackFn никогда не возвращает истинное значение, findLast() возвращает undefined. 

callbackFn вызывается для каждого индекса массива, а не только для тех, которым присвоены значения. Пустые слоты в разреженных массивах ведут себя так же, как и undefined.

Метод findLast() является универсальным. Он ожидает только, что это значение будет иметь свойство длины и свойства с целочисленными ключами.

Примеры
Найти последний объект в массиве, соответствующий свойствам элемента
В этом примере показано, как можно создать тест на основе свойств элементов массива.
*/
const inventory = [
  { name: "apples", quantity: 2 },
  { name: "bananas", quantity: 0 },
  { name: "fish", quantity: 1 },
  { name: "cherries", quantity: 5 },
];

// return true inventory stock is low
// возвращаем истинну true, если запас на складе низкий
function isNotEnough(item) {
  return item.quantity < 2;
}

console.log(inventory.findLast(isNotEnough));
// { name: "fish", quantity: 1 }
console.log(inventory.find(isNotEnough));
//{ name: 'bananas', quantity: 0 }
/*
Использование стрелочной функции и деструктуризации
Предыдущий пример можно написать с использованием стрелочной функции и деструктуризации объекта:
*/

const result5 = inventory.findLast(({ quantity }) =>  quantity < 2);

console.log(result5);  // { name: 'fish', quantity: 1 }
/*
Найти последнее простое число в массиве
В следующем примере возвращается последний элемент массива, который является простым числом или undefined, если простого числа нет.
*/

function isPrime3(element) {
    if (element % 2 === 0 || element < 2) {
        return false;
    } 
    for (let factor = 3; factor <= Math.sqrt(element); factor += 2) {
        if (element % factor === 0) {
            return false;
        }
    }
    return true;
}

console.log([4, 6, 8, 12].findLast(isPrime3)); // undefined, не найдено
console.log([4, 5, 7, 8, 9, 11, 12].findLast(isPrime3)); // 11
/*
Использование третьего аргумента callbackFn
Аргумент массива полезен, если вы хотите получить доступ к другому элементу массива, особенно если у вас нет существующей переменной, ссылающейся на массив. В следующем примере сначала используется filter() для извлечения положительных значений, а затем используется findLast() для поиска последнего элемента, значение которого меньше, чем у его положительных соседей.
*/
const numbers3 = [3, -1, 1, 4, 1, 5, 9, 2, 6];
const lastTrough = numbers3
   .filter((num) => num > 0)  // [3,1,4,1,5,9,2,6]
   .findLast((num, idx, arr) => {
     // Без аргумента arr невозможно легко получить доступ к
     // промежуточный массив без сохранения его в переменную.
     if (idx > 0 && num >= arr[idx - 1]) return false;
     if (idx < arr.length - 1 && num >= arr[idx + 1]) return false;
     return true;
   });

console.log(lastTrough); // 2
/*
Использование findLast() для разреженных массивов
Пустые слоты в разреженных массивах посещаются и обрабатываются так же, как undefined.
*/
// Объявляем массив без элементов с индексами 2, 3 и 4
const numbers4 = [0, 1, , , , 5, 6];

// Показывает все индексы, а не только те, которым присвоены значения
numbers4.findLast((value, index) => {
   console.log(`Посещенный индекс ${index} со значением ${value}`);
});
// Посещенный индекс 6 со значением 6
// Посещенный индекс 5 со значением 5
// Посетили индекс 4 со значением undefined
// Посещенный индекс 3 со значением undefined
// Посещенный индекс 2 со значением undefined
// Посещенный индекс 1 со значением 1
// Посещенный индекс 0 со значением 0

// Показывает все индексы, включая удаленные
numbers4.findLast((value, index) => {
   // Удалить элемент 5 на первой итерации
   if (index === 6) {
     console.log(`Удаление из массива элемента[5] со значением ${numbers4[5]}`);
     delete numbers4[5];
   }
   // Элемент 5 все еще посещается, хотя и удален
   console.log(`Посещенный индекс ${index} со значением ${value}`);
});
// Удаление массива[5] со значением 5
// Посещенный индекс 6 со значением 6
// Посещенный индекс 5 со значением undefined
// Посещенный индекс 4 со значением undefined
// Посещенный индекс 3 со значением undefined
// Посещенный индекс 2 со значением undefined
// Посещенный индекс 1 со значением 1
// Посещенный индекс 0 со значением 0
/*
Вызов findLast() для объектов, не являющихся массивами
Метод findLast() считывает свойство length этого объекта, а затем обращается к каждому свойству, ключ которого представляет собой неотрицательное целое число, меньше длины.
*/
const arrayLike = {
   length: 3,
   0: 2,
   1: 7.3, // игнорируется функцией findLast(), поскольку не целое число
   two: 4, // игнорируется функцией findLast(), поскольку ключ не число
   3: 3, // игнорируется функцией findLast(), поскольку длина равна 3
};
console.log(
   Array.prototype.findLast.call(arrayLike, (x) => Number.isInteger(x)),
); // 2



console.log("**Array findLastIndex()******************");
/*
Метод findLastIndex() выполняет итерацию массива в обратном порядке и возвращает индекс первого элемента, который удовлетворяет предоставленной функции тестирования. Если ни один элемент не удовлетворяет функции тестирования, возвращается -1.

См. также метод findLast(), который возвращает значение последнего элемента, удовлетворяющего функции тестирования (а не его индекс).
*/
const digits5 = [5, 12, 50, 130, 44];

const isLargeNumber = (element) => element > 45;

console.log(digits5.findLastIndex(isLargeNumber));  // 3
/*
Синтаксис

findLastIndex(callbackFn)
findLastIndex(callbackFn, thisArg)
Параметры
обратный вызовFn
Функция, выполняемая для каждого элемента массива. Она должна возвращать истинное значение, чтобы указать, что соответствующий элемент был найден, и ложное значение в противном случае. Функция вызывается со следующими аргументами:

элемент - Текущий элемент массива, который обрабатывается.

индекс - Индекс текущего обрабатываемого элемента в массиве.

массив - Был вызван массив с findLastIndex().

thisArg Необязательный
Значение, которое будет использоваться при выполнении callbackFn. См. итерационные методы.

Возвращаемое значение
Индекс последнего элемента (с наибольшим индексом) в массиве, который прошел проверку. В противном случае -1, если соответствующий элемент не найден.

Описание
Метод findLastIndex() является итеративным методом. Он вызывает предоставленную функцию callbackFn один раз для каждого элемента массива в порядке убывания индекса, пока callbackFn не вернет истинное значение. findLastIndex() затем возвращает индекс этого элемента и прекращает обход массива. Если callbackFn никогда не возвращает истинное значение, findLastIndex() возвращает -1.

callbackFn вызывается для каждого индекса массива, а не только для тех, которым присвоены значения. Пустые слоты в разреженных массивах ведут себя так же, как и undefined.

Метод findLastIndex() является универсальным. Он ожидает только, что это значение будет иметь свойство длины и свойства с целочисленными ключами.

Примеры
Найти индекс последнего простого числа в массиве
В следующем примере возвращается индекс последнего элемента массива, который является простым числом, или -1, если простого числа нет.
*/
function isPrime5(element) {
   if (element % 2 === 0 || element < 2) {
     return false;
   }
   for (let factor = 3; factor <= Math.sqrt(element); factor += 2) {
     if (element % factor === 0) {
       return false;
     }
   }
   return true;
}

console.log([4, 6, 8, 12].findLastIndex(isPrime5)); // -1, не найдено
console.log([4, 5, 7, 8, 9, 11, 12].findLastIndex(isPrime5)); // 5
/*
Использование третьего аргумента callbackFn
Аргумент массива полезен, если вы хотите получить доступ к другому элементу массива, особенно если у вас нет существующей переменной, ссылающейся на массив. В следующем примере сначала используется filter() для извлечения положительных значений, а затем используется findLastIndex() для поиска последнего элемента, размер которого меньше, чем у его соседей.
*/
const numbers5 = [3, -1, 1, 4, 1, 5, 9, 2, 6];
const lastTrough2 = numbers5
   .filter((num) => num > 0)
   .findLastIndex((num, idx, arr) => {
     // Без аргумента arr невозможно легко получить доступ к
     // промежуточному массиву без сохранения его в переменную.
     if (idx > 0 && num >= arr[idx - 1]) return false;
     if (idx < arr.length - 1 && num >= arr[idx + 1]) return false;
     return true;
   });
console.log(lastTrough2); // 6

/*
Использование findLastIndex() для разреженных массивов
Вы можете найти неопределенное значение в разреженном массиве и получить индекс пустого слота.
*/
console.log([1, , 3].findLastIndex((x) => x === undefined)); // 1

/*
Вызов findLastIndex() для объектов, не являющихся массивами
Метод findLastIndex() считывает свойство length этого объекта, а затем обращается к каждому свойству, ключ которого представляет собой неотрицательное целое число, меньшее длины.
*/

const arrayLike2 = {
   length: 3,
   0: 5,
   1: 7.3,
   2: 4,
   3: 3, // игнорируется функцией findLastIndex(), поскольку длина равна 3
};
console.log(
   Array.prototype.findLastIndex.call(arrayLike2, (x) => Number.isInteger(x)),
); // 2 // индекс = ключ


console.log("**JavaScript Sorting Arrays**************");

console.log("**Alpabetic Sort*************************");

console.log("**Array sort()**Popular**********************");

/*
Метод sort() на месте сортирует элементы массива и возвращает отсортированный массив. Сортировка не обязательно устойчива (англ.). Порядок сортировки по умолчанию соответствует порядку кодовых точек Unicode.

Синтаксис
arr.sort([compareFunction])
Параметры
compareFunction
Необязательный параметр. Указывает функцию, определяющую порядок сортировки. Если опущен, массив сортируется в соответствии со значениями кодовых точек каждого символа Unicode, полученных путём преобразования каждого элемента в строку.

Возвращаемое значение
Отсортированный массив. Важно, что копия массива не создаётся - массив сортируется на месте.

Описание
Если функция сравнения compareFunction не предоставляется, элементы сортируются путём преобразования их в строки и сравнения строк в порядке следования кодовых точек Unicode. Например, слово "Вишня" идёт перед словом "бананы". При числовой сортировке, 9 идёт перед 80, но поскольку числа преобразуются в строки, то "80" идёт перед "9" в соответствии с порядком в Unicode.
*/

console.log("я".charCodeAt(0))  // 1103
console.log("Ё".charCodeAt(0))  // 1025

const fruit7 = ["арбузы", "бананы", "Вишня"];
console.log(fruit7.sort()); // ['Вишня', 'арбузы', 'бананы']

const scores2 = [1, 2, 10, 21];
scores2.sort(); // [1, 10, 2, 21]
console.log(scores2);

const things2 = ["слово", "Слово", "1 Слово", "2 Слова"];
things2.sort(); // ['1 Слово', '2 Слова', 'Слово', 'слово']
console.log(things2)
/*
// В Unicode, числа находятся перед буквами в верхнем регистре,
// а те, в свою очередь, перед буквами в нижнем регистре.
Если функция сравнения compareFunction предоставлена, элементы массива сортируются в соответствии с её возвращаемым значением. Если сравниваются два элемента a и b, то:

Если compareFunction(a, b) меньше 0, сортировка поставит a по меньшему индексу, чем b, то есть, a идёт первым.
Если compareFunction(a, b) вернёт 0, сортировка оставит a и b неизменными по отношению друг к другу, но отсортирует их по отношению ко всем другим элементам. Обратите внимание: стандарт ECMAscript не гарантирует данное поведение, и ему следуют не все браузеры (например, версии Mozilla по крайней мере, до 2003 года).
Если compareFunction(a, b) больше 0, сортировка поставит b по меньшему индексу, чем a.
Функция compareFunction(a, b) должна всегда возвращать одинаковое значение для определённой пары элементов a и b. Если будут возвращаться непоследовательные результаты, порядок сортировки будет не определён.
Итак, функция сравнения имеет следующую форму:

 
function compare(a, b) {
  if (a меньше b по некоторому критерию сортировки) {
    return -1;
  }
  if (a больше b по некоторому критерию сортировки) {
    return 1;
  }
  // a должно быть равным b
  return 0;
}
Для числового сравнения, вместо строкового, функция сравнения может просто вычитать b из a. 

Следующая функция будет сортировать массив по возрастанию:


function compareNumbers(a, b) {
  return a - b;
}


Метод sort можно удобно использовать с функциональными выражениями (и замыканиями):
*/

const numbers9 = [4, 2, 5, 1, 3];
numbers9.sort(function (a, b) {
  return a - b;
});
console.log(numbers9); // [1, 2, 3, 4, 5]

console.log([12, 25, 1, 2, 28].sort());  //  [ 1, 12, 2, 25, 28 ]

console.log([12, 25, 1, 2, 28].sort(function(a, b){ return a - b;}));  //  [ 1, 2, 12, 25, 28 ]

console.log([12, 25, 1, 2, 28].sort((a, b) => a - b));  // [ 1, 2, 12, 25, 28 ]

console.log(["s", "S", "sab", "zts"].sort());  // [ 'S', 's', 'sab', 'zts' ]
console.log(["s", "S", "sab", "zts"].sort((a, b) => b.localeCompare(a)));  // [ 'zts', 'sab', 'S', 's' ]

/*
Для сортировки строк по убыванию нужно использовать b.localeCompare(a)
Объекты могут быть отсортированы по значению одного из своих свойств.
*/

const items3 = [
  { name: "Edward", value: 21 },
  { name: "Sharpe", value: 37 },
  { name: "And", value: 45 },
  { name: "The", value: -12 },
  { name: "Magnetic" },
  { name: "Zeros", value: 37 },
];
items3.sort(function (a, b) {
  if (a.name > b.name) {
    return 1;
  }
  if (a.name < b.name) {
    return -1;
  }
  // a должно быть равным b
  return 0;
});

console.log(items3);
/*
выведет:
[
  { name: 'And', value: 45 },
  { name: 'Edward', value: 21 },
  { name: 'Magnetic' },
  { name: 'Sharpe', value: 37 },
  { name: 'The', value: -12 },
  { name: 'Zeros', value: 37 }
]


Примеры
Пример: создание, отображение и сортировка массива
В следующем примере создаётся четыре массива, сначала отображается первоначальный массив, а затем они сортируются. Числовые массивы сортируются сначала без, а потом с функцией сравнения.
*/

const stringArray = ["Голубая", "Горбатая", "Белуга"];
const numericStringArray = ["80", "9", "700"];
const numberArray = [40, 1, 5, 200];
const mixedNumericArray = ["80", "9", "700", 40, 1, 5, 200];

function compareNumbers(a, b) {
  return a - b;
}

// снова предполагаем, что функция печати определена
console.log("stringArray: ", stringArray.join());
console.log("Сортировка: ", stringArray.sort());

console.log("numberArray: ", numberArray.join());
console.log("Сортировка без функции сравнения: ", numberArray.sort());
console.log(
  "Сортировка с функцией compareNumbers: ",
  numberArray.sort(compareNumbers),
);

console.log("numericStringArray: ", numericStringArray.join());
console.log("Сортировка без функции сравнения: ", numericStringArray.sort());
console.log(
  "Сортировка с функцией compareNumbers: ",
  numericStringArray.sort(compareNumbers),
);

console.log("mixedNumericArray: ", mixedNumericArray.join());
console.log("Сортировка без функции сравнения: ", mixedNumericArray.sort());
console.log(
  "Сортировка с функцией compareNumbers: ",
  mixedNumericArray.sort(compareNumbers),
);

/*
Этот пример произведёт следующий вывод. Как показывает вывод, когда используется функция сравнения, числа сортируются корректно вне зависимости от того, являются ли они собственно числами или строками с числами.

stringArray: Голубая,Горбатая,Белуга
Сортировка: Белуга,Голубая,Горбатая

numberArray: 40,1,5,200
Сортировка без функции сравнения: 1,200,40,5
Сортировка с функцией compareNumbers: 1,5,40,200

numericStringArray: 80,9,700
Сортировка без функции сравнения: 700,80,9
Сортировка с функцией compareNumbers: 9,80,700

mixedNumericArray: 80,9,700,40,1,5,200
Сортировка без функции сравнения: 1,200,40,5,700,80,9
Сортировка с функцией compareNumbers: 1,5,9,40,80,200,700


Пример: сортировка не-ASCII символов
Для сортировки строк с не-ASCII символами, то есть строк с символами акцента (e, é, è, a, ä и т.д.), строк, с языками, отличными от английского: используйте String.localeCompare. Эта функция может сравнивать эти символы, чтобы они становились в правильном порядке.
*/

const items4 = ["réservé", "premier", "cliché", "communiqué", "café", "adieu"];
items4.sort(function (a, b) {
  return a.localeCompare(b);
});
console.log(items4);

// items4 равен ['adieu', 'café', 'cliché', 'communiqué', 'premier', 'réservé']

/*
Пример: сортировка c помощью map
Функция сравнения (compareFunction) может вызываться несколько раз для каждого элемента в массиве. В зависимости от природы функции сравнения, это может привести к высоким расходам ресурсов. Чем более сложна функция сравнения и чем больше элементов требуется отсортировать, тем разумнее использовать map для сортировки. 
Идея состоит в том, чтобы обойти массив один раз, чтобы извлечь фактические значения, используемые для сортировки, во временный массив, отсортировать временный массив, а затем обойти временный массив для получения правильного порядка.
*/

// массив для сортировки
const list2 = ["Дельта", "альфа", "ЧАРЛИ", "браво"];

// временный массив содержит объекты с позицией и значением сортировки
const mapped = list2.map(function (el, i) {
  return { index: i, value: el.toLowerCase() };
});

// сортируем массив, содержащий уменьшенные значения
mapped.sort(function (a, b) {
  if (a.value > b.value) {
    return 1;
  }
  if (a.value < b.value) {
    return -1;
  }
  return 0;
});

// контейнер для результа
const result7 = mapped.map(function (el) {
  return list2[el.index];
});[
    { index: 1, value: 'альфа' },
    { index: 3, value: 'браво' },
    { index: 0, value: 'дельта' },
    { index: 2, value: 'чарли' }
  ]

console.log(mapped); // [
//     { index: 1, value: 'альфа' },
//     { index: 3, value: 'браво' },
//     { index: 0, value: 'дельта' },
//     { index: 2, value: 'чарли' }
//   ]

console.log(result7); // [ 'альфа', 'браво', 'Дельта', 'ЧАРЛИ' ]

console.log(list2);  // [ 'Дельта', 'альфа', 'ЧАРЛИ', 'браво' ]


console.log("**Array reverse()**Popular**********************");

/*
Метод reverse() на месте обращает порядок следования элементов массива. Первый элемент массива становится последним, а последний — первым.

пример
*/
const array5 = ["one", "two", "three"];
console.log("array5: ", array5);  // array5: [ 'one', 'two', 'three' ]

const reversed2 = array5.reverse();
console.log("reversed: ", reversed2); // reversed:  [ 'three', 'two', 'one' ]
console.log("array5: ", array5); // изменился начальный массив array5: [ 'three', 'two', 'one' ]

/*
Синтаксис
array.reverse()
Параметры
Нет.

Возвращаемое значение
Перевёрнутый массив

Описание
Метод reverse() на месте переставляет элементы массива, на котором он был вызван, изменяет массив и возвращает ссылку на него.

Примеры
Пример: обращение порядка элементов в массиве
В следующем примере создаётся массив myArray, содержащий три элемента, а затем массив переворачивается.
*/
const myArray = ["один", "два", "три"];
myArray.reverse();

console.log(myArray); // ['три', 'два', 'один']


console.log("**Array toSorted()***********************");

/*
Метод toSorted() — это копирующая версия метода sort(). Он возвращает новый массив, элементы которого отсортированы по возрастанию.

Синтаксис

toSorted()
toSorted(compareFn)
Параметры
compareFn Необязательный
Задает функцию, определяющую порядок сортировки. Если этот параметр опущен, элементы массива преобразуются в строки, а затем сортируются в соответствии со значением кодовой точки Юникода каждого символа.

a - Первый элемент для сравнения.

b - Второй элемент для сравнения.

Возвращаемое значение
Новый массив, элементы которого отсортированы по возрастанию.

Описание
Дополнительную информацию о compareFnпараметре см. sort()

При использовании с разреженными массивами метод toSorted() перебирает пустые слоты, как если бы они имели значение undefined.

Метод toSorted()является универсальным . Он ожидает только, что this значение будет иметь length свойство и свойства с целочисленным ключом.

Примеры
Сортировка массива
*/
const months2 = ["Mar", "Jan", "Feb", "Dec"];
const sortedMonths2 = months2.toSorted();
console.log(sortedMonths2); // ['Dec', 'Feb', 'Jan', 'Mar']
console.log(months2); // ['Mar', 'Jan', 'Feb', 'Dec']

const values2 = [1, 10, 21, 2];
const sortedValues2 = values2.toSorted((a, b) => a - b);
console.log(sortedValues2); // [1, 2, 10, 21]
console.log(values2); // [1, 10, 21, 2]

/*
Дополнительные примеры использования см sort().

Использование toSorted() для разреженных массивов
Пустые слоты сортируются так, как если бы они имели значение undefined. Они всегда сортируются до конца массива и compareFn для них не вызываются.
*/

console.log(["a", "c", , "b"].toSorted()); // ['a', 'b', 'c', undefined]
console.log([, undefined, "a", "b"].toSorted()); // ["a", "b", undefined, undefined]

/*
Вызов toSorted() для объектов, не являющихся массивами

Метод toSorted() считывает length свойство this. Затем он собирает все существующие свойства с целочисленными ключами в диапазоне от 0 до length - 1, сортирует их и записывает в новый массив.
*/

const arrayLike4 = {
  length: 3,
  unrelated: "foo",
  0: 5,
  2: 4,
  3: 3, // ignored by toSorted() since length is 3
};
console.log(Array.prototype.toSorted.call(arrayLike4));
// [4, 5, undefined]


console.log("**Array toReversed()*********************");

/*
Метод toReversed()  является копирующим аналогом метода reverse(). Он возвращает новый массив с элементами в обратном порядке.

Синтаксис
toReversed()
Параметры
Нет.

Возвращаемое значение
Новый массив, содержащий элементы в обратном порядке.

Описание
Метод toReversed() транспонирует элементы вызывающего объекта массива в обратном порядке и возвращает новый массив.

При использовании в разреженных массивах метод toReversed() перебирает пустые слоты, как если бы они имели неопределенное значение.

Метод toReversed() является универсальным. Он ожидает только, что это значение будет иметь свойство длины и свойства с целочисленными ключами.

Примеры
Перестановка элементов в массиве
В следующем примере создается элемент массива, содержащий три элемента, а затем создается новый массив, обратный элементам. Массив элементов остается неизменным.
*/

const digits7 = [1, 2, 3];
console.log(digits7); // [1, 2, 3]

const reversedDigits = digits7.toReversed();
console.log(reversedDigits); // [3, 2, 1]
console.log(digits7); // [1, 2, 3]

/*
Использование toReversed() для разреженных массивов
Возвращаемое значение toReversed() никогда не бывает разреженным. Пустые слоты в возвращаемом массиве становятся неопределенными.
*/

console.log([1, , 3].toReversed()); // [ 3, undefined, 1 ]
console.log([1, , 3, 4].toReversed()); // [ 4, 3, undefined, 1 ]

/*
Вызов toReversed() для объектов, не являющихся массивами

Метод toReversed() считывает свойство length этого объекта this. Затем он посещает каждое свойство, имеющее целочисленный ключ между length-1 до 0 в порядке убывания, добавляя значение текущего свойства в конец возвращаемого массива.
*/

const arrayLike3 = {
   length: 3,
   unrelated: "foo",
   2: 4,
};
console.log(Array.prototype.toReversed.call(arrayLike3)); // [ 4, undefined, undefined ]
// Индексы '0' и '1' отсутствуют, поэтому они становятся неопределенными undefined


console.log("**Sorting Objects************************");
	
console.log("**Numeric Sort**************************");
console.log("**Numeric Sort************************");
console.log("**Random Sort************************");
console.log("**Math.min()************************");
console.log("**Math.max()************************");
console.log("**Home made Min()************************");
console.log("**Home made Max()************************");

console.log("**Array Iteration Methods****************");
// Array iteration methods operate on every array item:

console.log("**Array forEach**Popular**********************");
/*
Метод forEach() выполняет указанную функцию один раз для каждого элемента в массиве.

Интерактивный пример

Синтаксис
arr.forEach(function callback(currentValue, index, array) {
    //your iterator
}[, thisArg]);
Параметры
callback - Функция, которая будет вызвана для каждого элемента массива. Она принимает от одного до трёх аргументов:

currentValue - Текущий обрабатываемый элемент в массиве.

index Необязательный - Индекс текущего обрабатываемого элемента в массиве.

array Необязательный - Массив, по которому осуществляется проход.

thisArg - Необязательный параметр. Значение, используемое в качестве this при вызове функции callback.

Возвращаемое значение
undefined.

Описание
Метод forEach() выполняет функцию callback один раз для каждого элемента, находящегося в массиве в порядке возрастания. Она не будет вызвана для удалённых или пропущенных элементов массива. Однако, она будет вызвана для элементов, которые присутствуют в массиве и имеют значение undefined.

Функция callback будет вызвана с тремя аргументами:

значение элемента (value)
индекс элемента (index)
массив, по которому осуществляется проход (array)
Если в метод forEach() был передан параметр thisArg, при вызове callback он будет использоваться в качестве значения this. В противном случае, в качестве значения this будет использоваться значение undefined. В конечном итоге, значение this, наблюдаемое из функции callback, определяется согласно обычным правилам определения this, видимого из функции.

Диапазон элементов, обрабатываемых методом forEach(), устанавливается до первого вызова функции callback. Элементы, добавленные в массив после начала выполнения метода forEach(), не будут посещены функцией callback. Если существующие элементы массива изменятся, значения, переданные в функцию callback, будут значениями на тот момент времени, когда метод forEach() посетит их; удалённые элементы посещены не будут. Если уже посещённые элементы удаляются во время итерации (например, с помощью shift()), последующие элементы будут пропущены. (Смотри пример ниже)

Примечание: Не существует способа остановить или прервать цикл forEach() кроме как выбрасыванием исключения. Если вам необходимо такое поведение, метод forEach() неправильный выбор.

Досрочное прекращение может быть достигнуто с:

Простой цикл for
Циклы for...of / for...in
Array.prototype.every()
Array.prototype.some()
Array.prototype.find()
Array.prototype.findIndex()
Если нужно протестировать элементы массива на условие и нужно вернуть булево значение, вы можете воспользоваться методами every(), some(), find() или findIndex().

Метод forEach() выполняет функцию callback один раз для каждого элемента массива; в отличие от методов every() и some(), он всегда возвращает значение undefined.

Примеры
Нет операции для неинициализированных значений (разреженные массивы)
*/
const arraySparse = [1, 3, , 7];
let numCallbackRuns = 0;

arraySparse.forEach((element) => {
  console.log(element);
  numCallbackRuns++;
});

console.log("numCallbackRuns: ", numCallbackRuns);

// 1
// 3
// 7
// numCallbackRuns: 3
// комментарий: как вы видите пропущенное значение между 3 и 7 не вызывало функцию callback.

// Конвертируем цикл for в forEach

const items = ["item1", "item2", "item3"];
const copy1 = [];
const copy2 = [];

// до
for (let i = 0; i < items.length; i++) {
  copy1.push(items[i]);
}

console.log(copy1); //  [ 'item1', 'item2', 'item3' ]
// после
items.forEach(function (item) {
  copy2.push(item);
});

console.log(copy2);  // [ 'item1', 'item2', 'item3' ]
console.table(copy2); 
/*

┌─────────┬─────────┐
│ (index) │ Values  │
├─────────┼─────────┤
│ 0       │ 'item1' │
│ 1       │ 'item2' │
│ 2       │ 'item3' │
└─────────┴─────────┘



Печать содержимого массива
Примечание: Для отображения содержимого массива в консоли вы можете использовать console.table(), который выводит отформатированную версию массива.

Следующий пример иллюстрирует альтернативный подход, использующий forEach().

Следующий код выводит каждый элемент массива на новой строке журнала:
*/

function logArrayElements(element, index, array) {
  console.log("a[" + index + "] = " + element);
}

// Обратите внимание на пропуск по индексу 2, там нет элемента, поэтому он не посещается
[2, 5, , 9].forEach(logArrayElements);
// логи:
// a[0] = 2
// a[1] = 5
// a[3] = 9

/*
Использование thisArg
Следующий (надуманный) пример обновляет свойства объекта, когда перебирает записи массива:
*/

function Counter() {
  this.sum = 0;
  this.count = 0;
}
Counter.prototype.add = function (array) {
  array.forEach((entry) => {
    this.sum += entry;
    ++this.count;
  }, this);
  // ^---- Note
};

const objCount = new Counter();
objCount.add([2, 5, 9]);
console.log(objCount.count);  // 3
console.log(objCount.sum);   // 16

/*
Поскольку в forEach() передан параметр thisArg (this), он затем передаётся в callback при каждом вызове. И callback использует его в качестве собственного значения this.

Примечание: Если при передаче callback функции используется выражение стрелочной функции, параметр thisArg может быть опущен, так как все стрелочные функции лексически привязываются к значению this.

Прерывание цикла
Следующий код использует Array.prototype.every() для логирования содержимого массива и останавливается при превышении значением заданного порогового значения THRESHOLD.
*/

let THRESHOLD = 12;
const vector = [5, 2, 16, 4, 3, 18, 20];
let res;

res = vector.every(function (element, index, array) {
  console.log("element:", element);
  if (element >= THRESHOLD) {
    return false;
  }

  return true;
});
console.log("res:", res);  // res: false
// логи:
// element: 5
// element: 2
// element: 16
// every() - все элементы должны соответствовать функции

res = vector.some(function (element, index, array) {
  console.log("element:", element);
  if (element >= THRESHOLD) {
    return true;
  }

  return false;
});
console.log("res:", res);  // res: true
// логи:
// element: 5
// element: 2
// element: 16
// хотя бы 1 элемент должен соответствовать функции

/*
Функция копирования объекта
Следующий код создаёт копию переданного объекта. Существует несколько способов создания копии объекта, и это один из них. Он позволяет понять, каким образом работает Array.prototype.forEach(), используя функции мета-свойств Object.* из ECMAScript 5.
*/

function copy(o) {
  let copy = Object.create(Object.getPrototypeOf(o));
  let propNames = Object.getOwnPropertyNames(o);

  propNames.forEach(function (name) {
    let desc = Object.getOwnPropertyDescriptor(o, name);
    Object.defineProperty(copy, name, desc);
  });

  return copy;
}

let o1 = { a: 1, b: 2 };
console.log(o1);  // { a: 1, b: 2 }
let o2 = copy(o1); // теперь o2 выглядит также, как и o1
console.log(o2);  // { a: 1, b: 2 }
// но это разные объекты
o2.c = 3;
console.log(o1);  // { a: 1, b: 2 }
console.table(o2);  // { a: 1, b: 2, c: 3 }

/*
Модификация массива во время итерации
В следующем примере в лог выводится "one", "two", "four".

При достижении записи, содержащей значение 'two', первая запись всего массива удаляется, в результате чего все оставшиеся записи перемещаются на одну позицию вверх. Поскольку элемент 'four' теперь находится на более ранней позиции в массиве, 'three' будет пропущен.

forEach() не делает копию массива перед итерацией.
*/

let words5 = ["one", "two", "three", "four"];
words5.forEach((word) => {
  console.log(word);
  if (word === "two") {
    words5.shift();
  }
});
// one
// two
// four

/*
Выравнивание (уплощение) массива
Следующий пример приведён только для целей обучения. Если вы хотите выравнять массив с помощью встроенных методов, вы можете использовать Array.prototype.flat()
*/

function flatten(arr) {
  const result = [];

  arr.forEach((i) => {
    if (Array.isArray(i)) {
      result.push(...flatten(i));
    } else {
      result.push(i);
    }
  });

  return result;
}

// Usage
const nested = [1, 2, 3, [4, 5, [6, 7], 8, 9]];

console.log(flatten(nested)); // [1, 2, 3, 4, 5, 6, 7, 8, 9]

console.log("**Array map()**Popular**********************");
/*
Метод map() создаёт новый массив с результатом вызова указанной функции для каждого элемента массива.

Синтаксис
const new_array = arr.map(function callback( currentValue[, index[, array]]) {
    // Возвращает элемент для new_array
}[, thisArg])
Параметры
callback - Функция, вызываемая для каждого элемента массива arr. Каждый раз, когда callback выполняется, возвращаемое значение добавляется в new_array.

Функция callback, создающая элемент в новом массиве, принимает три аргумента:

currentValue - Текущий обрабатываемый элемент массива.

indexНеобязательный 
Индекс текущего обрабатываемого элемента в массиве.

arrayНеобязательный
Массив, по которому осуществляется проход.

thisArgНеобязательный
Необязательный параметр. Значение, используемое в качестве this при вызове функции callback

Возвращаемое значение
Новый массив, где каждый элемент является результатом callback функции.

Описание
Метод map вызывает переданную функцию callback один раз для каждого элемента, в порядке их появления и конструирует новый массив из результатов её вызова. Функция callback вызывается только для индексов массива, имеющих присвоенные значения, включая undefined. Она не вызывается для пропущенных элементов массива (то есть для индексов, которые никогда не были заданы, которые были удалены или которым никогда не было присвоено значение.

Функция callback вызывается с тремя аргументами: значением элемента, индексом элемента и массивом, по которому осуществляется проход.

Если в метод map был передан параметр thisArg, при вызове callback он будет использоваться в качестве значения this. В противном случае в качестве значения this будет использоваться значение undefined. В конечном итоге, значение this, наблюдаемое из функции callback, определяется согласно обычным правилам определения this, видимого из функции.

Метод map не изменяет массив, для которого он был вызван (хотя функция callback может это делать).

Диапазон элементов, обрабатываемых методом map, устанавливается до первого вызова функции callback. Элементы, добавленные в массив после начала выполнения метода map, не будут посещены функцией callback. Если существующие элементы массива изменяются функцией callback, их значения, переданные в функцию, будут значениями на тот момент времени, когда метод map посетит их; удалённые элементы посещены не будут.

Примеры
Пример: отображение массива чисел на массив квадратных корней
Следующий код берёт массив чисел и создаёт новый массив, содержащий квадратные корни чисел из первого массива.
*/

const numbers7 = [1, 4, 9];
const roots = numbers7.map(Math.sqrt);
console.log(numbers7);  // [1, 4, 9]
console.log(roots);  // [ 1, 2, 3 ]
// теперь roots равен [1, 2, 3], а numbers7 всё ещё равен [1, 4, 9]

/*
Пример: отображение массива чисел с использованием функции, содержащей аргумент
Следующий код показывает, как работает отображение, когда функция требует один аргумент. Аргумент будет автоматически присваиваться каждому элементу массива, когда map проходит по оригинальному массиву.
*/

const numbers8 = [1, 4, 9];
const doubles8 = numbers8.map((num) => num * 2);
console.log(numbers8);  // [1, 4, 9]
console.log(doubles8);  // [ 2, 8, 18 ]

// теперь doubles равен [2, 8, 18], а numbers8 всё ещё равен [1, 4, 9]
/*
Пример: обобщённое использование map
Этот пример показывает, как использовать map на объекте строки String для получения массива байт в кодировке ASCII, представляющего значения символов:
*/

const mapArr = Array.prototype.map;
const charCodes = mapArr.call("Hello World", (x) => x.charCodeAt(0));
console.log(charCodes);

// теперь charCodes равен [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]
/*
Пример: обобщённое использование map вместе с querySelectorAll
Этот пример показывает, как пройтись по коллекции объектов, собранных с помощью querySelectorAll. В данном случае мы получаем все выбранные опции на экране и печатаем их в консоль:

const elems = document.querySelectorAll("select option:checked");
const values = Array.prototype.map.call(elems, ({ value }) => value);
Более простым способом будет использование метода Array.from().

Пример: использование map для переворачивания строки
*/
const string = "12345";
const reversed = Array.prototype.map
  .call(string, (x) => x)
  .reverse()
  .join("");
// reversed равен '54321'
// Бонус: используйте '===' для проверки того, является ли строка палиндромом

/*
Более простым способом будет использование метода String.split() .

Пример: хитрый вариант использования

Распространённой практикой является использование колбэк-функции с одним аргументом (элемент, над которым производится операция). Некоторые функции также широко используется с одним аргументом, хотя они принимают дополнительные необязательные аргументы. Эти привычки могут привести к неожиданному поведению программы.
*/
// Рассмотрим пример:
["1", "2", "3"].map(parseInt);
console.log(["1", "2", "3"].map(parseInt));

// Хотя ожидаемый результат вызова равен [1, 2, 3],
// в действительности получаем [1, NaN, NaN]

// Функция parseInt часто используется с одним аргументом, но она принимает два.
// Первый аргумент является выражением, а второй - основанием системы счисления.
// В функцию callback Array.prototype.map передаёт 3 аргумента:
// элемент, его индекс и сам массив.
// Третий аргумент игнорируется parseInt, но не второй, следовательно,
// возможна путаница.

const returnInt = (element) => parseInt(element, 10);

["1", "2", "3"].map(returnInt);
// Результатом является массив чисел (как и ожидалось)

// Простейший способ добиться вышеозначенного поведения и избежать чувства "чё за!?":
["1", "2", "3"].map(Number); // [1, 2, 3]


console.log("**Array flatMap()************************");
/*
Метод flatMap() сначала применяет функцию к каждому элементу, а затем преобразует полученный результат в одномерную структуру и помещает в новый массив. Это идентично map функции, с последующим применением функции flat с параметром depth ( глубина ) равным 1, но flatMap часто бывает полезным, так как работает немного более эффективно.

Синтаксис
var new_array = arr.flatMap(function callback(currentValue[, index[, array]]) {
    // возвращает элемент для new_array
}[, thisArg])
Параметры
callback - Функция которая производит элементы нового массива, принимает три аргумента:

currentValue - Текущий обрабатываемый элемент массива.

index Необязательный - Индекс обрабатываемого элемента в массиве.

array Необязательный - Массив по которому осуществляется обход.

thisArg Необязательный - Значение используемое в качестве this при вызове функции callback.

Возвращаемое значение
Новый массив, каждый элемент которого является результатом выполнения функции callback и "поднят" на уровень 1.

Описание
Смотрите0 Array map() для детального описания callback функции. Метод flatMap идентичен методу map с последующим вызовом flat с параметром depth 1.

Примеры
map и flatMap
*/

let arrNum1 = [1, 2, 3, 4];

const onlyMap = arrNum1.map((x) => [x * 2]);  
console.log(onlyMap);  // [[2], [4], [6], [8]]
const flatAndMap = arrNum1.flatMap((x) => [x * 2]); 
console.log(flatAndMap);  // [2, 4, 6, 8]
// выравнивается только один уровень
const flatAndMap2 = arrNum1.flatMap((x) => [[x * 2]]); 

console.log(flatAndMap2);  // [[2], [4], [6], [8]]
/*
Хотя результат полученный в примере выше можно было получить используя просто map, ниже мы рассмотрим пример где flatMap является более эффективным.

Давайте сгенерируем список слов из списка предложений.
*/

let arrSentence = ["it's Sunny in", "", "California"];

const arrMapSplit = arrSentence.map((x) => x.split(" ")); 
console.log(arrMapSplit);  // [["it's","Sunny","in"],[""],["California"]]
const arrFlatMapSplit = arrSentence.flatMap((x) => x.split(" "));
console.log(arrFlatMapSplit);  // ["it's","Sunny","in", "", "California"]

/*
Обратите внимание, длина списка вывода может отличаться от длины списка ввода.

//=> [1, 2, 3, 4, 5, 6, 7, 8, 9]

Альтернативное решение
reduce and concat
*/

let arr20 = [1, 2, 3, 4];
const arr21= arr20.flatMap((x) => [x * 2]);
console.log(arr21);  // [2, 4, 6, 8]
// is equivalent to
const arr22 = arr20.reduce((acc, x) => acc.concat([x * 2]), []);
console.log(arr22);  //=> [ 2, 4, 6, 8 ]


console.log("**Array filter()**Popular**********************");
/*
Метод filter() создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.

пример
*/

const words = ["spray", "elite", "exuberant", "destruction", "present"];

const result4 = words.filter((word) => word.length > 6);

console.log(result4);  // [ 'exuberant', 'destruction', 'present' ]

console.log(words.filter((word) => word === "spray"));  // может найти слово в массиве  [ 'spray' ]


console.log(words.filter((word) => word === "sprays"));  // вернет пустой массив []
/*
Синтаксис
// Стрелочная функция
filter((element) => { ... } )
filter((element, index) => { ... } )
filter((element, index, array) => { ... } )

// Колбэк-функция
filter(callbackFn)
filter(callbackFn, thisArg)

// Встроенная колбэк-функция
filter(function callbackFn(element) { ... })
filter(function callbackFn(element, index) { ... })
filter(function callbackFn(element, index, array){ ... })
filter(function callbackFn(element, index, array) { ... }, thisArg)

callbackFn - Функция-предикат, которая будет вызвана для проверки каждого элемента массива. Если функция возвращает true, то элемент остаётся в массиве, если false, то удаляется.

Принимает три аргумента

element - Текущий обрабатываемый элемент в массиве.

index Необязательный - Индекс текущего обрабатываемого элемента в массиве.

array Необязательный - Обрабатываемый массив, на котором был вызван метод filter().

thisArg Необязательный - Значение, используемое в качестве this при вызове колбэк-функции callbackFn.

Возвращаемое значение
Вернётся новый массив с элементами, которые прошли проверку. Если ни один элемент не прошёл проверку, то будет возвращён пустой массив.

Описание
Метод filter() вызывает переданную функцию callback один раз для каждого элемента, присутствующего в массиве, и создаёт новый массив со всеми значениями, для которых функция callback вернула значение, которое может быть приведено к true. Функция callback вызывается только для индексов массива с уже определёнными значениями; она не вызывается для индексов, которые были удалены или которым значения никогда не присваивались. Элементы массива, не прошедшие проверку функцией callback, просто пропускаются и не включаются в новый массив.

Функция callback вызывается с тремя аргументами:

значение элемента;
индекс элемента;
массив, по которому осуществляется проход.
Если в метод filter() был передан параметр thisArg, при вызове callback он будет использоваться в качестве значения this. В противном случае в качестве значения this будет использоваться значение undefined. В конечном итоге, значение this, наблюдаемое из функции callback, определяется согласно обычным правилам определения this.

Метод filter() не изменяет массив, для которого он был вызван.

Элементы массива, обрабатываемые методом filter(), устанавливается до первого вызова функции callback. Элементы, добавленные в массив после начала выполнения метода filter(), либо изменённые в процессе выполнения, не будут обработаны функцией callback. Соответствующим образом, если существующие элементы удаляются из массива, они также не будут обработаны

Предупреждение: одновременное изменение элементов, описанное в предыдущем параграфе, часто приводит к труднопонимаемому коду, поэтому не рекомендуется делать это (за исключением особых случаев).

Примеры
Фильтрация всех маленьких значений
Следующий пример использует filter() для создания отфильтрованного массива, все элементы которого больше или равны 10, а все меньшие 10 удалены.
*/

function isBigEnough(value) {
  return value >= 10;
}

let filtered = [12, 5, 8, 130, 44].filter(isBigEnough);
// массив filtered теперь содержит [12, 130, 44]
/*
Найти все простые числа в массиве*****
Следующий пример возвращает все простые числа в массиве:
Простые числа определяются как положительные целые числа, которые имеют ровно два делителя: единицу и само число. По определению, отрицательные числа не являются простыми.
*/
const array16 = [-3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];

function isPrime4(num) {
  for (let i = 2; num > i; i++) {
    if (num % i == 0) {
      return false;
    }
  }
  return num > 1;
}

console.log(array16.filter(isPrime4)); // [2, 3, 5, 7, 11, 13]
/*
Фильтрация неверных записей в JSON
В следующем примере метод filter() используется для создания отфильтрованного JSON-объекта, все элементы которого содержат ненулевое числовое поле id.
*/

let arr16 = [
  { id: 15 },
  { id: -1 },
  { id: 0 },
  { id: 3 },
  { id: 12.2 },
  {},
  { id: null },
  { id: NaN },
  { id: "undefined" },
];

let invalidEntries = 0;

function filterByID(item) {
  if (Number.isFinite(item.id) && item.id !== 0) {
    return true;
  }
  invalidEntries++;
  return false;
}

let arrByID = arr16.filter(filterByID);

console.log("Отфильтрованный массив\n", arrByID);
// Отфильтрованный массив
// [{ id: 15 }, { id: -1 }, { id: 3 }, { id: 12.2 }]

console.log("Количество некорректных элементов = ", invalidEntries);
// Количество некорректных элементов = 5
/*
`Number.isFinite()` - это статический метод объекта `Number` в JavaScript, который используется для определения, является ли переданное значение конечным числом. Он возвращает `true`, если значение является конечным числом, и `false` в противном случае.

В отличие от глобальной функции `isFinite()`, которая преобразует свой аргумент в число перед проверкой, метод `Number.isFinite()` проверяет только сам аргумент и возвращает `false` для значений, которые не являются числами или являются `Infinity` или `-Infinity`.
*/
Примеры:


Number.isFinite(Infinity);  // false
Number.isFinite(-Infinity); // false
Number.isFinite(NaN);       // false
Number.isFinite(123);       // true
Number.isFinite('123');     // false, потому что '123' не является числом
Number.isFinite(true);      // false, потому что true преобразуется в 1, которое является числом

/*
В примере функция `filterByID` использует `Number.isFinite(item.id)` для проверки, является ли `id` числом и конечным (не `Infinity`, не `-Infinity`, и не `NaN`), и возвращает `true`, если это так. Если `id` не является числом или является `0`, функция возвращает `false`.


/*
Поиск в массиве
В следующем примере filter() используется для фильтрации содержимого массива на основе входных данных.
*/
let fruits = ["apple", "banana", "grapes", "mango", "orange"];

/**
 * Элементы массива фильтруется на основе критериев поиска (query)
 */
function filterItems(query) {
    return fruits.filter(function (el) {
      return el.toLowerCase().indexOf(query.toLowerCase()) > -1;
    });
  }
  
  console.log(filterItems("ap")); // ['apple', 'grapes']
  console.log(filterItems("an")); // ['banana', 'mango', 'orange']
/*
Этот код определяет функцию `filterItems(query)`, которая фильтрует элементы массива `fruits` на основе заданного критерия поиска `query`. Функция использует метод `filter()` для создания нового массива, содержащего только те элементы, которые удовлетворяют критериям поиска.

Вот как это работает:

1. Функция `filterItems(query)` принимает строку `query` в качестве аргумента, которая представляет собой критерий поиска.

2. Внутри функции используется метод `filter()` для фильтрации элементов массива `fruits`. Для каждого элемента массива выполняется функция обратного вызова, которая проверяет, содержит ли текущий элемент строку `query`.

3. Внутри функции обратного вызова строка `query` и текущий элемент массива `el` приводятся к нижнему регистру с помощью метода `toLowerCase()`. Это делается для обеспечения регистронезависимого поиска.

4. Затем проверяется, содержит ли приведенная к нижнему регистру строка `el` подстроку, представленную `query`. Это делается с помощью метода `indexOf()`, который возвращает индекс первого вхождения подстроки в строку или `-1`, если подстрока не найдена.

5. Если индекс, возвращаемый методом `indexOf()`, больше `-1`, это означает, что подстрока найдена в текущем элементе массива, и элемент добавляется в новый массив, создаваемый методом `filter()`.

6. В конце функция `filterItems(query)` возвращает новый массив, содержащий только те элементы, которые соответствуют критериям поиска `query`.

Этот подход позволяет эффективно фильтровать массив по критериям поиска, игнорируя регистр букв.


Реализация со стрелочной функцией:
*/
const fruits2 = ["apple", "banana", "grapes", "mango", "orange"];

/**
 * Элементы массива фильтруется на основе критериев поиска (query)
 */
const filterItems2 = (arr, query) => {
    return arr.filter(
      (el) => el.toLowerCase().indexOf(query.toLowerCase()) !== -1,
    );
  };
  
  console.log(filterItems2(fruits2, "ap")); // ['apple', 'grapes']
  console.log(filterItems2(fruits2, "an")); // ['banana', 'mango', 'orange']


  const fruit3 = ["apple", "banana", "grapes", "mango", "orange", "apple", "banana", "apple"];
  // поиск и удаление дубликатов в массиве - если 2 и более элементов в массиве, они все будут удалены 
const doubleFree = fruit3.filter(el => fruit3.indexOf(el) === fruit3.lastIndexOf(el));
console.log(doubleFree);  // [ 'grapes', 'mango', 'orange' ]


// нахождение дубликатов
const dublicate = fruit3.filter(el => fruit3.indexOf(el) !== fruit3.lastIndexOf(el));
console.log(dublicate);  // [ 'apple', 'banana', 'apple', 'banana', 'apple' ]


// создание массива с неповторяющимися элементами
const fruit4 = ["apple", "banana", "grapes", "mango", "orange", "apple", "banana", "apple", "kiwi"];

const exclusive = fruit4.filter((el, i) => i === fruit4.indexOf(el)); // индекс текущего элемента равен индексу первого вхождения этого элемента
console.log(exclusive);  // [ 'apple', 'banana', 'grapes', 'mango', 'orange' ]

const exclusive2 = []
for (let i = 0; i < fruit4.length; i++) {
    if(i === fruit4.indexOf(fruit4[i])) {
            exclusive2.push(fruit4[i]);
            console.log(exclusive2);
    }
}
// [ 'apple', 'banana', 'grapes', 'mango', 'orange', 'kiwi' ]

// создание нового массива со всеми элементами, отвечающими условию в функции = берем элементы по нечетному индексу
const digits = [-4, 0, 876, 88, -22, 777];

const oddIndex = digits.filter((el, i) => i % 2);  // если индекс нечетный 3 % 2 = 1 === true; 0 === false

console.log(oddIndex);  // [ 0, 88, 777 ]


console.log("**Array reduce()**Popular**********************");

/*
Метод reduce() применяет функцию reducer к каждому элементу массива (слева-направо), возвращая одно результирующее значение.

 пример
*/
const numbersArr = [1, 2, 3, 4];

const initialValue = 0;
const sumWithInitial = numbersArr.reduce(
    (accumulator, currentValue) => accumulator + currentValue, initialValue,
);

console.log(sumWithInitial);  // 10
/*
Синтаксис
array.reduce(callback[, initialValue])
Параметры
callback
Функция, выполняющаяся для каждого элемента массива, принимает четыре аргумента:

accumulator
Аккумулятор, аккумулирующий значение, которое возвращает функция callback после посещения очередного элемента, либо значение initialValue, если оно предоставлено (смотрите пояснения ниже).

currentValue
Текущий обрабатываемый элемент массива.

indexНеобязательный
Индекс текущего обрабатываемого элемента массива.

arrayНеобязательный
Массив, для которого была вызвана функция reduce.

initialValueНеобязательный
Необязательный параметр. Объект, используемый в качестве первого аргумента при первом вызове функции callback.

Описание
Метод reduce() выполняет функцию callback один раз для каждого элемента, присутствующего в массиве, за исключением пустот, принимая четыре аргумента: начальное значение (или значение от предыдущего вызова callback), значение текущего элемента, текущий индекс и массив, по которому происходит итерация.

При первом вызове функции, параметры accumulator и currentValue могут принимать одно из двух значений. Если при вызове reduce() передан аргумент initialValue, то значение accumulator будет равным значению initialValue, а значение currentValue будет равным первому значению в массиве. Если аргумент initialValue не задан, то значение accumulator будет равным первому значению в массиве, а значение currentValue будет равным второму значению в массиве.

Если массив пустой и аргумент initialValue не указан, будет брошено исключение TypeError. Если массив состоит только из одного элемента (независимо от его положения в массиве) и аргумент initialValue не указан, или если аргумент initialValue указан, но массив пустой, то будет возвращено одно это значение, без вызова функции callback.

Предположим, что reduce() используется следующим образом:
*/
[0, 1, 2, 3, 4].reduce(function (previousValue, currentValue, index, array) {
  return previousValue + currentValue;
});
/*
Колбэк-функция будет вызвана четыре раза, аргументы и возвращаемое значение при каждом вызове будут следующими:

    previousValue	index   array	 
            currentValue          возвращаемое значение
первый вызов	0	1	1	[0, 1, 2, 3, 4]	1
второй вызов	1	2	2	[0, 1, 2, 3, 4]	3
третий вызов	3	3	3	[0, 1, 2, 3, 4]	6
четвёртый вызов	6	4	4	[0, 1, 2, 3, 4]	10
Значение, возвращённое методом reduce() будет равным последнему результату выполнения колбэк-функции — 10.

Если же вы зададите начальное значение initialValue, результат будет выглядеть так:
*/

[0, 1, 2, 3, 4].reduce(function (accumulator, currentValue, index, array) {
  return accumulator + currentValue;
}, 10);
/*
accumulator	currentValue	index	array	возвращаемое значение
первый вызов	10	0	0	[0, 1, 2, 3, 4]	10
второй вызов	10	1	1	[0, 1, 2, 3, 4]	11
третий вызов	11	2	2	[0, 1, 2, 3, 4]	13
четвёртый вызов	13	3	3	[0, 1, 2, 3, 4]	16
пятый вызов	    16	4	4	[0, 1, 2, 3, 4]	20

Значение, возвращённое методом reduce() на этот раз, конечно же, будет равным 20.

Примеры
Суммирование всех значений в массиве
*/
let total = [0, 1, 2, 3].reduce(function (a, b) {
  return a + b;
});
console.log(total);  // total == 6
/*
Суммирование значений в массиве объектов
Чтобы суммировать значения, содержащиеся в массиве объектов, вы должны указать initialValue, чтобы каждый элемент смог пройти через callback.
*/
let initialValueZero = 0;
var sum2 = [{ x: 1 }, { x: 2 }, { x: 3 }].reduce(function (
  accumulator,
  currentValue,
) {
  return accumulator + currentValue.x;
}, initialValueZero);

console.log(sum2);
// sum2 == 6
/*
Тоже самое, но со стрелочной функцией:
*/
let zeroInitialValue = 0;
var sum3 = [{ x: 1 }, { x: 2 }, { x: 3 }].reduce(
  (accumulator, currentValue) => accumulator + currentValue.x,
  zeroInitialValue,
);
// sum3 == 6
/*
Разворачивание массива массивов
*/
const flattened = [
  [0, 1],
  [2, 3],
  [4, 5],
].reduce(function (a, b) {
  return a.concat(b);
});

console.log(flattened);  // flattened равен [0, 1, 2, 3, 4, 5]
/*
Пример: склеивание массивов, содержащихся в объектах массива, с использованием оператора расширения и initialValue
*/

// friends - список из объектов(друзей)
// где поле "books" - список любимых книг друга
const friends = [
  { name: "Anna", books: ["Bible", "Harry Potter"], age: 21 },
  { name: "Bob", books: ["War and peace", "Romeo and Juliet"], age: 26 },
  { name: "Alice", books: ["The Lord of the Rings", "The Shining"], age: 18 },
];

// allbooks - список, который будет содержать все книги друзей +
// дополнительный список указанный в initialValue (previous); current - текущий элемент массива=книги текущего друга
const allbooks = friends.reduce(
  function (prev, curr) {
    return [...prev, ...curr.books];
  },
  ["Alphabet"],
);

console.log(allbooks);
// allbooks = ["Alphabet", "Bible", "Harry Potter", "War and peace",
// "Romeo and Juliet", "The Lord of the Rings", "The Shining"]


console.log("**Array reduceRight()**Popular******************");
/*
Метод reduceRight() применяет функцию к аккумулятору и каждому значению массива (справа-налево), сводя его к одному значению.

Синтаксис
arr.reduceRight(callback[, initialValue])
Параметры
callback - Функция, выполняющаяся для каждого элемента массива, принимает четыре аргумента:

previousValue
Значение, возвращённое предыдущим выполнением функции callback, либо значение initialValue, если оно предоставлено (смотрите пояснения ниже).

currentValue - Текущий обрабатываемый элемент массива.

index - Индекс текущего обрабатываемого элемента массива.

array - Массив, для которого была вызвана функция reduceRight.

initialValue
Необязательный параметр. Объект, используемый в качестве первого аргумента при первом вызове функции callback.

Описание
Метод reduceRight() выполняет функцию callback один раз для каждого элемента, присутствующего в массиве, за исключением пустот, принимая четыре аргумента: начальное значение (или значение от предыдущего вызова callback), значение текущего элемента, текущий индекс и массив, по которому происходит итерация.

Вызов колбэк-функции callback будет выглядеть так:

array.reduceRight(function (previousValue, currentValue, index, array) {
  // ...
});
При первом вызове функции, параметры previousValue и currentValue могут принимать одно из двух значений. Если при вызове reduceRight() передан аргумент initialValue, то значение previousValue будет равным значению initialValue, а значение currentValue будет равным последнему значению в массиве. Если аргумент initialValue не задан, то значение previousValue будет равным последнему значению в массиве, а значение currentValue будет равным второму с конца значению в массиве.

Если массив пустой и аргумент initialValue не указан, будет брошено исключение TypeError. Если массив состоит только из одного элемента (независимо от его положения в массиве) и аргумент initialValue не указан, или если аргумент initialValue указан, но массив пустой, то будет возвращено одно это значение, без вызова функции callback.

Вот так будут выглядеть некоторый примеры прогона функции:
*/

[0, 1, 2, 3, 4].reduceRight(
  function (previousValue, currentValue, index, array) {
    return previousValue + currentValue;
  },
);
/*
Колбэк-функция будет вызвана четыре раза, аргументы и возвращаемое значение при каждом вызове будут следующими:

        previousValue	currentValue	index	    array	    возвращаемое значение
первый вызов	4	        3	            3	[0, 1, 2, 3, 4]	        7
второй вызов	7	        2	            2	[0, 1, 2, 3, 4]	        9
третий вызов	9	        1	            1	[0, 1, 2, 3, 4]	        10
четвёртый вызов	10	        0	            0	[0, 1, 2, 3, 4]	        10
Значение, возвращённое методом reduceRight() будет равным последнему результату выполнения колбэк-функции — 10.

Если же вы зададите начальное значение initialValue, результат будет выглядеть так:
*/

[0, 1, 2, 3, 4].reduceRight(function (
  previousValue,
  currentValue,
  index,
  array,
) {
  return previousValue + currentValue;
}, 10);
/*
            previousValue	currentValue	index	    array	     возвращаемое значение
первый вызов	10	            4	          4	    [0, 1, 2, 3, 4]	    14  
второй вызов	14	            3	          3	    [0, 1, 2, 3, 4]	    17
третий вызов	17	            2	          2	    [0, 1, 2, 3, 4]	    19
четвёртый вызов	19	            1	          1	    [0, 1, 2, 3, 4]	    20
пятый вызов	    20	            0	          0	    [0, 1, 2, 3, 4]	    20
Значение, возвращённое методом reduceRight() на этот раз, конечно же, будет равным 20.

Примеры
Пример: суммирование всех значений в массиве
*/
const total2 = [0, 1, 2, 3].reduceRight(function (a, b) {
  return a + b;
});
console.log(total2); // total2 == 6

/*
Пример: разворачивание массива массивов
*/
const flattened2 = [
  [0, 1],
  [2, 3],
  [4, 5],
].reduceRight(function (a, b) {
  return a.concat(b);
}, []);
console.log(flattened2); // flattened2 равен [4, 5, 2, 3, 0, 1]

console.log("**Array every()************************");
/*
Метод every() проверяет, удовлетворяют ли все элементы массива условию, заданному в передаваемой функции.

Примечание: метод возвращает true при любом условии для пустого массива.

Синтаксис
arr.every(callback(currentValue[, index[, array]])[, thisArg])
Параметры
callback - Функция проверки каждого элемента, принимает три аргумента:

currentValue - Текущий обрабатываемый элемент массива.

index Необязательный - Индекс текущего обрабатываемого элемента массива.

array Необязательный - Массив, по которому осуществляется проход.

thisArg Необязательный
Необязательный параметр. Значение, используемое в качестве this при выполнении функции callback.

Возвращаемое значение
true если функция проверки возвращает truthy значение для каждого элемента массива. Иначе, false.

Описание
Метод every() вызывает переданную функцию callback один раз для каждого элемента, присутствующего в массиве до тех пор, пока не найдёт такой, для которого callback вернёт ложное значение (значение, становящееся равным false при приведении его к типу Boolean). Если такой элемент найден, метод every() немедленно вернёт false. В противном случае, если callback вернёт true для всех элементов массива, метод every() вернёт true. Функция callback вызывается только для индексов массива, имеющих присвоенные значения; она не вызывается для индексов, которые были удалены или которым значения никогда не присваивались.

Функция callback вызывается с тремя аргументами: значением элемента, индексом элемента и массивом, по которому осуществляется проход.

Если в метод every() был передан параметр thisArg, при вызове callback он будет использоваться в качестве значения this. В противном случае в качестве значения this будет использоваться значение undefined. В конечном итоге, значение this, наблюдаемое из функции callback, определяется согласно обычным правилам определения this, видимого из функции.

Метод every() не изменяет массив, для которого он был вызван.

Диапазон элементов, обрабатываемых методом every(), устанавливается до первого вызова функции callback. Элементы, добавленные в массив после начала выполнения метода every(), не будут посещены функцией callback. 

Если существующие элементы массива изменятся, значения, переданные в функцию callback, будут значениями на тот момент времени, когда метод every() посетит их; удалённые элементы посещены не будут.

Метод every() действует подобно квантору всеобщности в математике. В частности, он вернёт true для пустого массива. Это так называемая бессодержательная истина (vacuously true) — все элементы пустого множества (англ.) удовлетворяют любому заданному условию.

Примеры
Пример: проверка размера всех элементов массива
Следующий пример проверяет, являются ли все элементы массива числами, большими 10.
*/

function isBigEnough(element, index, array) {
  return element >= 10;
}
[12, 5, 8, 130, 44].every(isBigEnough); // false
[12, 54, 18, 130, 44].every(isBigEnough); // true

/*
Пример: использование стрелочных функций
Стрелочные функции предоставляют более краткий синтаксис для подобных проверок.
 */
[12, 5, 8, 130, 44].every((elem) => elem >= 10); // false
[12, 54, 18, 130, 44].every((elem) => elem >= 10); // true

console.log("**Array some()************************");

/*
Метод some() проверяет, удовлетворяет ли какой-либо элемент массива условию, заданному в передаваемой функции.

Примечание: метод возвращает false при любом условии для пустого массива.

 пример
 */
const numArr = [1, 2, 3, 4, 5];
// проверим , есть ли в массиве numArr четные элементы
const even = (element) => element % 2 === 0;

console.log(numArr.some(even));  // true

 /*
Синтаксис
arr.some(callback(element[, index[, array]])[, thisArg])

Параметры
callback
Функция проверки каждого элемента, принимает три аргумента:

element - Текущий обрабатываемый элемент массива.

indexНеобязательный
Индекс текущего обрабатываемого элемента массива.

arrayНеобязательный
Массив, по которому осуществляется проход.

thisArgНеобязательный
Значение, используемое в качестве this при выполнении функции callback.

Возвращаемое значение
true, если функция проверки возвращает truthy значение хотя бы для одного элемента массива. Иначе, false.

Описание
Метод some() вызывает переданную функцию callback один раз для каждого элемента, присутствующего в массиве до тех пор, пока не найдёт такой, для которого callback вернёт истинное значение (значение, становящееся равным true при приведении его к типу Boolean). Если такой элемент найден, метод some() немедленно вернёт true. В противном случае, если callback вернёт false для всех элементов массива, метод some() вернёт false. Функция callback вызывается только для индексов массива, имеющих присвоенные значения; она не вызывается для индексов, которые были удалены или которым значения никогда не присваивались.

Функция callback вызывается с тремя аргументами: значением элемента, индексом элемента и массивом, по которому осуществляется проход.

Если в метод some() был передан параметр thisArg, при вызове callback он будет использоваться в качестве значения this. В противном случае в качестве значения this будет использоваться значение undefined. В конечном итоге, значение this, наблюдаемое из функции callback, определяется согласно обычным правилам определения this, видимого из функции.

Метод some() не изменяет массив, для которого он был вызван.

Диапазон элементов, обрабатываемых методом some(), устанавливается до первого вызова функции callback. Элементы, добавленные в массив после начала выполнения метода some(), не будут посещены функцией callback. Если существующие элементы массива изменятся, значения, переданные в функцию callback, будут значениями на тот момент времени, когда метод some() посетит их; удалённые элементы посещены не будут.

Примеры
Проверка значений элементов массива
Следующий пример проверяет наличие в массиве элемента, который больше 10.
*/
 function isBiggerThan10(element, index, array) {
  return element > 10;
}
console.log([2, 5, 8, 1, 4].some(isBiggerThan10)); // false
console.log([12, 5, 8, 1, 4].some(isBiggerThan10)); // true

/*
Проверка элементов массива с использованием стрелочных функций
Стрелочные функции предоставляют более краткий синтаксис для подобных проверок.
*/
 
console.log([2, 5, 8, 1, 4].some((elem) => elem > 10)); // false
console.log([12, 5, 8, 1, 4].some((elem) => elem > 10)); // true

/*
Проверка наличия элемента в массиве
Чтобы имитировать функцию метода includes(), эта пользовательская функция возвращает true, если элемент существует в массиве:
*/
const fruit5 = ["apple", "banana", "mango", "guava"];

function checkAvailability(arr, val) {
  return arr.some(function (arrVal) {
    return val === arrVal;
  });
}

console.log(checkAvailability(fruit5, "kela")); // false
console.log(checkAvailability(fruit5, "banana")); // true

/*
Проверка наличия элемента в массиве с использованием стрелочной функции
*/
 
const fruit6 = ["apple", "banana", "mango", "guava"];

function checkAvailability(arr, val) {
  return arr.some((arrVal) => val === arrVal);
}

console.log(checkAvailability(fruit6, "kela")); // false
console.log(checkAvailability(fruit6, "banana")); // true

/*
Приведение значения к логическому типу
 */
const TRUTHY_VALUES = [true, "true", 1];

function getBoolean(value) {
  "use strict";

  if (typeof value === "string") {
    value = value.toLowerCase().trim();
  }

  return TRUTHY_VALUES.some(function (t) {
    return t === value;
  });
}

console.log(getBoolean(false)); // false
console.log(getBoolean("false")); // false
console.log(getBoolean(1)); // true
console.log(getBoolean("true")); // true


console.log("**Array from()************************");
/*
Метод Array.from() создаёт новый экземпляр Array из массивоподобного или итерируемого объекта.
*/

const test = Array.from("testing");  
console.log(test); // ['t', 'e', 's', 't', 'i', 'n', 'g']
const testUI = Array.from(test, (el) => el.toUpperCase());
console.log(testUI); // ['T', 'E', 'S','T', 'I', 'N','G']


/*
Синтаксис
Array.from(arrayLike[, mapFn[, thisArg]])


Параметры
arrayLike - Массивоподобный или итерируемый объект, преобразуемый в массив.

mapFn Необязательный -Отображающая функция, вызываемая для каждого элемента массива.

thisArg Необязательный - Значение, используемое в качестве this при выполнении функции mapFn.

Возвращаемое значение - Новый экземпляр Array

Описание
Array.from() позволяет вам создавать массивы из:

массивоподобных объектов (объектов со свойством length и элементами по индексным ключам) или
итерируемых объектов (объектов, из которых вы можете достать их элементы, например Map (en-US) или Set).

*/

console.log("**Array keys()************************");

/*
Метод keys() возвращает новый итератор массива Array Iterator, содержащий ключи каждого индекса в массиве.

пример
*/
const alpha = ["a", "b", "c"];

const iterator = alpha.keys();

for (const key of iterator) {
    console.log(key);
}

/*
Синтаксис
arr.keys()
Примеры
Пример: базовое использование
*/
let arr2 = ["a", "b", "c"];
let iterator2 = arr2.keys();

console.log(iterator2.next()); // { value: 0, done: false }
console.log(iterator2.next()); // { value: 1, done: false }
console.log(iterator2.next()); // { value: 2, done: false }
console.log(iterator2.next()); // { value: undefined, done: true }

/*
Пример: итератор, возвращаемый методом keys(), не пропускает дырки в массиве
*/
let alphaEmpty = ["a", , "c"];
let sparseKeys = Object.keys(alphaEmpty);
let denseKeys = [...alphaEmpty.keys()];
console.log(sparseKeys); // [ '0', '2' ]
console.log(denseKeys); // [0, 1, 2]



console.log("**Array entries()************************");
/*
Возвращает новый объект array iterator, который содержит пары ключ/значение для каждого индекса в массиве.

синтаксис 
arr.entries()
*/

const arr55 = ["a", "b", "c"];  
const eArr = arr55.entries();
console.log(eArr.next().value);  // [ 0, 'a' ]
console.log(arr55);  // [ 'a', 'b', 'c' ]
console.log(eArr);  //  Object [Array Iterator] {}
console.log(eArr.next().value);  // [ 1, 'b' ]
console.log(eArr.next().value);  // [ 2, 'c' ]
console.log(eArr.next().value);  // undefined
console.log(eArr.next());  // { value: undefined, done: true }

// Чтобы пройтись опять по массиву - нужно создать новый итератор

const eArr2 = arr55.entries()

// можем пройтись циклом

while (true) {
    const result = eArr2.next()
    console.log(result);
    if (result.done) break;
}

/* выведет 
 value: [ 0, 'a' ], done: false }
{ value: [ 1, 'b' ], done: false }
{ value: [ 2, 'c' ], done: false }
{ value: undefined, done: true }
*/

/*
`next()` - это метод объекта итератора (iterator), который возвращает следующий элемент последовательности. 

Когда вы вызываете `eArr.next()`, он возвращает объект с двумя свойствами: `value` и `done`. Свойство `value` содержит текущий элемент итератора, а свойство `done` указывает, достигнут ли конец итерации (true, если достигнут конец, и false в противном случае).

В примере `eArr` - это итератор для массива `arr55`. При каждом вызове `next()` возвращает следующий элемент массива в виде массива `[индекс, значение]`. Когда все элементы итерированы, вызов `next()` возвращает объект, у которого свойство `done` равно true и свойство `value` равно undefined.

Таким образом, в вашем примере выводится следующая последовательность:

1. `eArr.next().value` возвращает `[0, 'a']`, так как первый элемент массива `arr55` имеет индекс 0 и значение 'a'.
2. `eArr.next().value` возвращает `[1, 'b']`, так как следующий элемент имеет индекс 1 и значение 'b'.
3. `eArr.next().value` возвращает `[2, 'c']`, так как следующий элемент имеет индекс 2 и значение 'c'.
4. `eArr.next().value` возвращает `undefined`, так как достигнут конец итерации, и больше нет элементов для возвращения.

Где применяется:
В практике метод `entries()` для массивов может быть полезен во многих случаях. 
Одним из таких случаев может быть необходимость выполнить итерацию по элементам массива вместе с их индексами для выполнения каких-то операций или обработки данных. Примеры:

1. Итерация с использованием индексов для поиска конкретных элементов:
   
   Предположим, у вас есть массив объектов пользователей, и вы хотите найти всех пользователей старше 18 лет. Метод `entries()` поможет вам итерироваться по массиву с доступом как к элементу, так и к его индексу:
*/
   
   const users = [
       { name: "Alice", age: 25 },
       { name: "Bob", age: 17 },
       { name: "Charlie", age: 20 }
   ];

   for (let [index, user] of users.entries()) {
       if (user.age > 18) {
           console.log(`User ${user.name} at index ${index} is older than 18.`);
       }
   }
   
/*
2. Итерация и обновление значений в массиве:

   Иногда вам может понадобиться изменить значения в массиве на основе их индекса. Например, у вас есть массив чисел, и вы хотите удвоить все числа, находящиеся на нечетных индексах:
*/
   
   const numbers = [1, 2, 3, 4, 5, 6];

   for (let [index, value] of numbers.entries()) {
       if (index % 2 !== 0) {
           numbers[index] *= 2; // Удваиваем значение на нечетных индексах
       }
   }

   console.log(numbers); // Output: [1, 4, 3, 8, 5, 12]
  
/*
3. Создание нового объекта на основе значений и индексов массива:

   Вы можете использовать метод `entries()` для создания нового объекта на основе значений и индексов массива. Например, создайте объект, содержащий индексы как ключи и значения как элементы массива:
*/
  
   const arr7 = ["apple", "banana", "cherry"];
   const obj = Object.fromEntries(arr7.entries());
   console.log(obj); // Output: {0: "apple", 1: "banana", 2: "cherry"}
  
/*
использования метода `entries()` - он полезен в тех случаях, когда вам нужно иметь доступ к индексам элементов массива во время его итерации для выполнения различных операций.
*/



console.log("**Array with()************************");

/*
Метод with() — это копирующая версия использования скобочной записи для изменения значения данного индекса. Он возвращает новый массив, в котором элемент по заданному индексу заменен заданным значением.

Синтаксис

arrayInstance.with(index, value)
Параметры
index
Индекс, отсчитываемый от нуля, для изменения массива, преобразованный в целое число .

Отрицательный индекс отсчитывается от конца массива — если -array.length <= index < 0 используется index + array.length.
Если индекс после нормализации выходит за пределы, RangeError выдается.

value - Любое значение, которое будет присвоено данному индексу.

Возвращаемое значение
Новый массив, в котором элемент по указанному индексу index заменен на value.

Исключения
RangeError
Выбрасывается, если index >= array.length или index < -array.length.

Описание
Метод with() изменяет значение заданного индекса в массиве, возвращая новый массив, в котором элемент по заданному индексу заменен заданным значением. Исходный массив не изменяется. Это позволяет вам связывать методы массива во время выполнения манипуляций.

Комбинируя with() с at(), вы можете как записывать, так и читать (соответственно) массив, используя отрицательные индексы.

Этот with() метод никогда не создает разреженный массив . Если исходный массив разрежен, пустые слоты будут заменены undefined в новом массиве.

Метод with() является универсальным . Он ожидает только, что this значение будет иметь length свойство и свойства с целочисленным ключом.

Примеры
Создание нового массива с измененным одним элементом
     indices |0 |1 |2*|3 |4|   */
const arr3 = [1, 2, 3, 4, 5];
console.log(arr3.with(2, 6)); // [1, 2, 6, 4, 5]
console.log(arr3); // [1, 2, 3, 4, 5]
/*
Объединение методов массива
С помощью этого with() метода вы можете обновить один элемент массива, а затем применить другие методы массива.
*/

const arr4 = [1, 2, 3, 4, 5];
console.log(arr4.with(2, 6).map((x) => x ** 2)); // [1, 4, 36, 16, 25]

/*
Использование with() для разреженных массивов
Метод with() всегда создает плотный массив - a dense array.
*/

const arr5 = [1, , 3, 4, , 6];
console.log(arr5.with(0, 2)); // [2, undefined, 3, 4, undefined, 6]
/*
Вызов with() для объектов, не являющихся массивами

Метод with() создает и возвращает новый массив. Он считывает length свойство this, а затем обращается к каждому свойству, ключ которого представляет собой неотрицательное целое число меньше length. При доступе к каждому свойству this элементу массива, имеющему индекс, равный ключу свойства, присваивается значение свойства. Наконец, значение массива at index установлено в value.
*/

const arrayLike5 = {
  length: 3,
  unrelated: "foo",
  0: 5,
  2: 4,
  3: 3, // ignored by with() since length is 3
};
console.log(Array.prototype.with.call(arrayLike5, 0, 1));
// [ 1, undefined, 4 ]


console.log("**Array Spread (...) как можно идти вглубь массива************************");
/*
Для литералов массива или строк:

[...iterableObj, '4', 'five', 6];


Spread syntax позволяет расширить доступные для итерации элементы (например, массивы или строки) в местах
 - для функций: где ожидаемое количество аргументов для вызовов функций равно нулю или больше нуля
 - для элементов (литералов массива)
 - для выражений объектов: в местах, где количество пар "ключ-значение" должно быть равно нулю или больше (для объектных литералов)

 пример
*/
function sum5(x, y, z) {
    return x + y + z;
}

const numbers11 = [1, 2, 3];

console.log(sum5(...numbers11));  // 6

console.log(sum5.apply(null, numbers11));  // 6

/*
 Синтаксис
Для вызовов функций:

myFunction(...iterableObj);
Для литералов массива или строк:

[...iterableObj, '4', 'five', 6];
Для литералов объекта (новое в ECMAScript 2018):

let objClone = { ...obj };

Примеры

Spread в вызовах функций
Замена apply
Обычно используют Function.prototype.apply в случаях, когда хотят использовать элементы массива в качестве аргументов функции.
*/

function myFunction2(x, y, z) {}
let args = [0, 1, 2];
myFunction2.apply(null, args);

/*
С spread syntax вышеприведённое можно записать как:
*/

function myFunction3(x, y, z) {}
let args = [0, 1, 2];
myFunction3(...args);
/*
Любой аргумент в списке аргументов может использовать spread syntax, и его можно использовать несколько раз.
*/

function myFunction4(v, w, x, y, z) {}
var args = [0, 1];
myFunction4(-1, ...args, 2, ...[3]);

/*
Apply для new
Вызывая конструктор через ключевое слово new, невозможно использовать массив и apply напрямую (apply выполняет [[Call]], а не [[Construct]]).Однако благодаря spread syntax, массив может быть с лёгкостью использован со словом new:
*/

let dateFields = [1970, 0, 1]; // 1 Jan 1970
let d = new Date(...dateFields);
/*
Чтобы использовать new с массивом параметров без spread syntax, вам потребуется использование частичного применения:
*/

function applyAndNew(constructor, args) {
  function partial() {
    return constructor.apply(this, args);
  }
  if (typeof constructor.prototype === "object") {
    partial.prototype = Object.create(constructor.prototype);
  }
  return partial;
}

function myConstructor() {
  console.log("arguments.length: " + arguments.length);
  console.log(arguments);
  this.prop1 = "val1";
  this.prop2 = "val2";
}

let myArguments = ["hi", "how", "are", "you", "mr", null];
let myConstructorWithArguments = applyAndNew(myConstructor, myArguments);

console.log(new myConstructorWithArguments());
// (internal log of myConstructor):           arguments.length: 6
// (internal log of myConstructor):           ["hi", "how", "are", "you", "mr", null]
// (log of "new myConstructorWithArguments"): {prop1: "val1", prop2: "val2"}

/*
Spread в литералах массива
Более мощный литерал массива
Без spread syntax, применение синтаксиса литерала массива для создания нового массива на основе существующего недостаточно и требуется императивный код вместо комбинации методов push, splice, concat и т.д. С spread syntax реализация становится гораздо более лаконичной:
*/

let parts = ["shoulders", "knees"];
let lyrics = ["head", ...parts, "and", "toes"];
// ["head", "shoulders", "knees", "and", "toes"]

/*
Аналогично развёртыванию в массиве аргументов, ... может быть использован повсеместно и многократно в литерале массива.

Копирование массива
*/

let arr30 = [1, 2, 3];
var arr31 = [...arr30]; // like arr.slice()
arr31.push(4);

// arr31 becomes [1, 2, 3, 4]
// arr30 remains unaffected
/*
Примечание: Spread syntax на самом деле переходит лишь на один уровень глубже при копировании массива. Таким образом, он может не подходить для копирования многоразмерных массивов, как показывает следующий пример: (также как и c Object.assign()) и синтаксис spred
*/

const abc = [[1], [2], [3]];
const bcd = [...abc];
bcd.shift().shift(); // 1
// О нет. Теперь на массив "аbc" относятся также: а
//[[], [2], [3]]

/*
Лучший способ конкатенации массивов
Для конкатенации массива часто используется Array.concat:
*/

let arr32 = [0, 1, 2];
let arr33 = [3, 4, 5];
// Append all items from arr32 onto arr33
arr32 = arr32.concat(arr33);
/*
С использованием spread syntax:
*/
let arr34 = [0, 1, 2];
var arr35 = [3, 4, 5];
arr34 = [...arr34, ...arr35];
/*
Array.unshift часто используется для вставки массива значений в начало существующего массива. Без spread syntax:
*/

let arr36 = [0, 1, 2];
var arr37 = [3, 4, 5];
// Prepend all items from arr37 onto arr36
Array.prototype.unshift.apply(arr36, arr37); // arr36 is now [3, 4, 5, 0, 1, 2]

/*
С использованием spread syntax [Следует отметить, что такой способ создаёт новый массив arr36. В отличие от Array.unshift, исходный массив не мутируется]:
*/


let arr38 = [0, 1, 2];
let arr39 = [3, 4, 5];
arr38 = [...arr39, ...arr38]; // arr38 is now [3, 4, 5, 0, 1, 2]

/*
Spread в литералах объекта
Предложение Rest/Spread Properties for ECMAScript (стадия 4) добавляет свойства spread в литералы объекта. Оно копирует собственные перечисляемые свойства данного объекта в новый объект.

Поверхностное копирование (без прототипа) или объединение объектов теперь возможно с использованием более короткого, чем Object.assign(), синтаксиса.
*/

let obj5 = { foo: "bar", x: 42 };
let obj6 = { foo: "baz", y: 13 };

let clonedObj = { ...obj5 };
// Object { foo: "bar", x: 42 }

let mergedObj = { ...obj5, ...obj6 };
// Object { foo: "baz", x: 42, y: 13 }

/*
Обратите внимание, что Object.assign() запускает setters, а spread syntax нет.

Обратите внимание, что вы не можете заменить или имитировать функцию Object.assign():
*/

let obj7 = { foo: "bar", x: 42 };
let obj8 = { foo: "baz", y: 13 };
const merge = (...objects) => ({ ...objects });

let mergedObj2 = merge(obj7, obj8);
// Object { 0: { foo: 'bar', x: 42 }, 1: { foo: 'baz', y: 13 } }

let mergedObj3 = merge({}, obj7, obj8);
// Object { 0: {}, 1: { foo: 'bar', x: 42 }, 2: { foo: 'baz', y: 13 } }

/*
В приведённом выше примере оператор распространения не работает так, как можно было бы ожидать: он распространяет массив аргументов в литерал объекта благодаря параметру rest.

Только для итерируемых объектов

Spread syntax ( кроме случаев spread properties) может быть применён только к итерируемым объектам (iterable objects) :
*/


let obj9 = { key1: "value1" };
let array9 = [...obj9]; // TypeError: obj9 is not iterable

/*
Spread с большим количеством значений
При использовании spread оператора в вызовах функций необходимо быть внимательным к возможному переполнению в ядре JavaScript. Существует ограничение по максимально возможному количеству аргументов функции. См. apply() для уточнения.

Rest синтаксис (параметры)
Синтаксис для rest оператора выглядит таким же как и для spread оператора, однако он используется для деструктуризации массивов и объектов. Фактически, rest оператор противоположен spread оператору: 
последний spread - раскладывает массив на элементы, тогда как первый rest - собирает много элементов в один. См. rest parameters. 

*/


console.log("**Array Rest (...) **********************");

/*
Синтаксис остаточных параметров функции rest parameters позволяет представлять неограниченное множество аргументов в виде массива.

 пример
*/
function sum4 (...theArgs) {
    let totalSum = 0;
    for (const arg of theArgs) {
        totalSum += arg;
    }
    return totalSum;
}

console.log(sum4(1, 2, 3));  // 6
console.log(sum4(1, 2, 3, 4));  // 10

/*
Синтаксис

function(a, b, ...theArgs) {
  // ...код 
}

Описание
Если последний именованный аргумент функции имеет префикс ..., он автоматически становится массивом с элементами от 0 до theArgs.length-1 в соответствии с актуальным количеством аргументов, переданных в функцию.
*/

function myFun(a, b, ...manyMoreArgs) {
  console.log("a: ", a);
  console.log("b: ", b);
  console.log("manyMoreArgs: ", manyMoreArgs);
}

myFun("один", "два", "три", "четыре", "пять", "шесть");

// Console Output:
// a: один
// b: два
// manyMoreArgs: [три, четыре, пять, шесть]

/*
Отличия остаточных параметров от объекта arguments
Существует три основных отличия остаточных параметров от объекта arguments:

1) остаточные параметры включают только те, которым не задано отдельное имя, в то время как объект arguments содержит все аргументы, передаваемые в функцию;
2) объект arguments не является массивом, в то время как остаточные параметры являются экземпляром Array и методы sort, map, forEach или pop могут непосредственно у них использоваться;
3) объект arguments имеет дополнительную функциональность, специфичную только для него (например, свойство callee).


Из аргументов в массив

Остаточные параметры были введены для уменьшения количества шаблонного кода:

// До появления остаточных параметров "arguments" конвертировали в обычный массив используя:

function f(a, b) {
  var normalArray = Array.prototype.slice.call(arguments);
  // -- или --
  var normalArray = [].slice.call(arguments);
  // -- или --
  var normalArray = Array.from(arguments);

  var first = normalArray.shift(); // OK, даёт первый аргумент
  var first = arguments.shift(); // ERROR (arguments не является обычным массивом)
}

// Теперь мы можем легко получить остаточные параметры как обычный массив

function f(...args) {
  var normalArray = args;
  var first = normalArray.shift(); // OK, даёт первый аргумент
}


Деструктуризация остаточных параметров

Остаточные параметры могут быть деструктурированы (только массивы). Это означает, что их данные могут быть заданы как отдельные значения. Смотрите Деструктурирующее присваивание.
*/
function f(...[a, b, c]) {
  return a + b + c;
}

console.log(f(1))          // NaN (b и c равны undefined)
console.log(f(1, 2, 3))    // 6
console.log(f(1, 2, 3, 4)) // 6 (четвёртый параметр не деструктурирован)

/*
Примеры
В этом примере первый аргумент задан как "a", второй как "b", так что эти аргументы используются как обычно. Однако третий аргумент "manyMoreArgs" будет массивом, который содержит 3-й, 4-й, 5-й, 6-й ... n-й аргументы, которые передаст пользователь.
*/
 
function myFunc(a, b, ...manyMoreArgs) {
  console.log("a: ", a);
  console.log("b: ", b);
  console.log("manyMoreArgs: ", manyMoreArgs);
}

myFunc("один", "два", "три", "четыре", "пять", "шесть");

// a: один
// b: два
// manyMoreArgs: [три, четыре, пять, шесть]
/*
Ниже... даже если передано одно значение последним аргументом, оно всё равно помещается в массив.
*/

// использование той же функции, что и в примере выше

myFunc("один", "два", "три");

// a: один
// b: два
// manyMoreArgs: [три]
/*
Ниже... третий аргумент не был передан, но "manyMoreArgs" всё ещё массив (хотя и пустой).
*/

// использование той же функции, что и в примере выше

myFunc("один", "два");

// a: один
// b: два
// manyMoreArgs: []
/*
Поскольку theArgs является массивом, количество элементов в нём определяется свойством length:
*/

function fun1(...theArgs) {
  console.log(theArgs.length);
}

fun1(); // 0
fun1(5); // 1
fun1(5, 6, 7); // 3
/*
В следующем примере, остаточные параметры используются для сбора всех аргументов после первого в массив. Каждый из них умножается на первый параметр и возвращается массив:
*/

function multiply(multiplier, ...theArgs) {
  return theArgs.map(function (element) {
    return multiplier * element;
  });
}

const arr6 = multiply(2, 1, 2, 3);
console.log(arr6); // [2, 4, 6]
/*
Методы Array могут быть использованы на остаточных параметрах, но не на объекте arguments:
*/

function sortRestArgs(...theArgs) {
  var sortedArgs = theArgs.sort();
  return sortedArgs;
}

console.log(sortRestArgs(5, 3, 7, 1)); // 1, 3, 5, 7

function sortArgumentsErr() {
  var sortedArgs = arguments.sort();
  return sortedArgs; // это никогда не выполнится
}

console.log(sortArgumentsErr(5, 3, 7, 1)); // TypeError (arguments.sort is not a function)

/*
Чтобы использовать методы Array на объекте arguments, нужно преобразовать его в настоящий массив.
*/

function sortArguments() {
  var args = Array.from(arguments);
  var sortedArgs = args.sort();
  return sortedArgs;
}
console.log(sortArguments(5, 3, 7, 1)); // 1, 3, 5, 7
