/*
Map and Set
Отображения и наборы

В ЕSб введены две популярные структуры данных: отображения (map) и наборы
(set). 
Отображения подобны объектам, они способны сопоставлять ключи со значениями, а наборы подобны массивам за исключением того, что дубликаты не допускаются.

Map - Отображения **************************************

До появления ЕSб, когда требовалось сопоставить ключам значения, использовались объекты, поскольку объекты позволяют сопоставить строковые ключи со значениями объектов любых типов. Однако при использовании объектов для этой цели возникает много проблем.
• Прототипы, лежащие в основе объектов, способны создать сопоставления, о которых вы и не предполагали.
• Нет никакого простого способа узнать количество сопоставлений, находящихся в объекте.
• Ключи должны быть строками или символами, сопоставить со значениями объекты невозможно.
• Объекты не гарантируют порядка своих свойств.

Объект Мар ликвидирует эти недочеты и является превосходным выбором для сопоставления ключей со значениями (даже если ключи - строки). Предположим, например,
что у вас есть объекты пользователей, которые необходимо сопоставить с ролями.
*/

const u1 = { name: "Cynthia" };
const u2 = { name: "Jackson" };
const u3 = { name: "Olive" };
const u4 = { name: "James" };

// Сначала создадим отображение Map

const userRoles = new Map();

/*
Затем используем отображение для назначения пользователям ролей с использованием ее метода set () .

*/
userRoles.set(u1, "User");
userRoles.set(u2, "User");
userRoles.set(u3, "Admin");

console.log(userRoles);
/*
// бедный Джеймс . . . мы не назначили ему роль

Метод set () допускает также цепочки, что позволяет сэкономить на вводе.
*/

userRoles.clear();
console.log(userRoles);

userRoles
    .set(u1, "User")
    .set(u2, "User")
    .set(u3, "Admin");

    console.log(userRoles);

/*
Вы можете также передать в конструктор массив массивов.
*/
const userRoles2 = new Map([
    [u1, "User"],
    [u2, "User"],
    [u3, "Admin"],
]);

/*
Теперь, если необходимо выяснить роль пользователя u2, можно использовать
метод get () .
*/
userRoles2.get(u2);  // 
console.log(userRoles2.get(u2));  // User
console.log(userRoles.get(u2));   // User

/*
Вызов метода get для ключа, отсутствующего в отображении, возвратит значение
undefined. Кроме того, вы можете использовать метод 
has ( ) для определения наличия в отображении заданного ключа.
*/

console.log(userRoles2.has(u4));   //  false
console.log(userRoles2.get(u4));   // undefined
console.log(userRoles.has(u1));   // true
console.log(userRoles.get(u1));   // User

/*
Вызов метода set ( ) для ключа, уже присутствующего в отображении, приведет
к замене его значения.
*/
userRoles2.set(u1, "Admin");
console.log(userRoles2.get(u1));  // Admin

/*
Свойство size возвращает количество элементов в отображении map.
*/
console.log(userRoles2.size);  // 3 

/*
- Метод keys () позволяет получить ключи в отображении, 
- метод values () - возвратить значения, а 
- метод entries () - получить элементы в виде массивов, в которых первый элемент - ключ, а второй - значение. Все эти методы возвращают
итерируемый объект, который может быть перебран в цикле for ... of. 
*/
for (let u of userRoles2.keys()) {
    console.log(u);
    console.log(u.name);
}

for(let r of userRoles2.values()) {
    console.log(r);
}

for (let ur of userRoles2.entries()) {
    console.log(`${ur[0].name} : ${ur[1]}`);
}

/*
 обратите внимание : чтобы сделать этот перебор еще более
 естественным, мы можем использовать деструктуризацию:
*/
for (let [u, r] of userRoles.entries()) {
    console.log(`${u.name} : ${r}`);
}

console.log(userRoles.entries());
/*
выведет:

[Map Entries] {
  [ { name: 'Cynthia' }, 'User' ],
  [ { name: 'Jackson' }, 'User' ],
  [ { name: 'Olive' }, 'Admin' ]
}

// метод entries () - это стандартный итератор для отображений, так
// вы можете сократить предыдущий пример :
*/
for(let [u, r] of userRoles) {
    console.log(`${u.name} : ${r}`);
}

/*

Если вместо итерируемого объекта необходим массив, вы можете использовать
оператор расширения.
*/
[...userRoles.values()];
console.log([...userRoles2.values()]);  // [ 'Admin', 'User', 'Admin' ]

/*
Чтобы удалить одиночный элемент из отображения, используйте метод delete ( ) .
*/
// userRoles2.delete(u2);

console.log(userRoles2.delete(u2));  // true
userRoles2.size;  
console.log(userRoles2.size);  // 2


/*
Наконец, если вы хотите удалить все элементы из отображения, то можете сделать это, используя метод clear ( ) .
*/
userRoles2.clear();
console.log(userRoles2.size);  // 0

/*

Слабые отображения*************************************


Объект WeakМap идентичен объекту Мар, кроме следующего.

• Его ключи должны быть объектами.

• Ключи в WeakМap допускают сборку мусора.

• Объект WeakМap не может быть перебран или очищен.

Обычно JavaScript хранит объект в памяти, пока где-нибудь есть ссылка на него.
Например, если у вас будет объект, который является ключом в Мар, то JavaScript
будет хранить этот объект в памяти, пока объект Мар существует. 
С WeakМap все не так. 
Из-за этого объект WeakMap не может быть перебран (есть слишком большая опасность, что при переборе произойдет доступ к объекту, который уже был уничтожен в процессе сборки мусора).

Благодаря этим свойствам объект WeakMap применяется для хранения закрытых ключей в экземплярах объекта.
*/

const SecretHolder = (function() {
    const secrets = new WeakMap();
    return class {
        setSecret(secret) {
            secrets.set(this, secret);
        }
        getSecret() {
            return secrets.get(this);
        }
    }
})();

/*

Здесь мы поместили свой объект WeakMap в немедленно вызываемое функциональное выражение (IIFE) наравне с классом, который его использует. 
Вне IIFE мы получаем класс SecretHolder, экземпляры которого способны хранить секреты. 
Мы можем установить секрет, только используя метод setSecret, а получить к нему доступ - только через метод getSecret.
*/
const a = new SecretHolder();
const b = new SecretHolder();

console.log(a);  // {}
console.log(b);  // {}

a.setSecret("secret A");
b.setSecret("secret B");

console.log(a);  // {} - потому что доступ только через getSecret()
console.log(b);  // {} - потому что доступ только через getSecret()

console.log(a.getSecret());   //  secret A
console.log(b.getSecret());   //  secret B

/*

Мы могли бы использовать обычный объект Мар, но сообщенные его экземплярам SecretHolder секреты никогда не будут уничтожены в процессе сборки мусора!


Сборка мусора - это процесс в языках программирования с автоматическим управлением памятью, таких как JavaScript, который отслеживает и удаляет объекты, которые больше не используются в программе, чтобы освободить память и предотвратить утечки памяти.

В JavaScript механизм сборки мусора автоматически отслеживает ссылки на объекты и определяет, когда объект больше не доступен для использования. Объект считается доступным для сборки мусора, если на него нет ссылок из глобальной области видимости или из других объектов. Когда объект больше не доступен, он помечается как подлежащий сборке мусора.

В вашем коде, где используется WeakMap, объекты, хранящиеся в WeakMap, могут быть удалены сборщиком мусора, если на них больше нет ни одной другой ссылки, кроме ссылки из WeakMap. Это происходит потому, что WeakMap хранит слабые ссылки на объекты, которые не предотвращают удаление объектов сборщиком мусора, если на них больше нет сильных ссылок.

В приведенном примере класс SecretHolder использует WeakMap для хранения секретов, что позволяет объектам SecretHolder хранить секреты, при этом сами секреты могут быть удалены сборщиком мусора, если на объект SecretHolder больше нет других ссылок. Это позволяет избежать утечек памяти, поскольку секреты будут автоматически удалены, когда объект SecretHolder больше не будет использоваться в программе.
***********

Пример создания WeakMap без использования функций и классов:

// Создание объектов, которые будут использоваться в качестве ключей WeakMap
*/

const key1 = {};
const key2 = {};

// Создание WeakMap
const weakMap = new WeakMap();

// Добавление элементов в WeakMap
weakMap.set(key1, "значение для ключа 1");
weakMap.set(key2, "значение для ключа 2");

console.log(weakMap);  // WeakMap { <items unknown> }


// Получение значений из WeakMap
console.log(weakMap.get(key1)); // "значение для ключа 1"
console.log(weakMap.get(key2)); // "значение для ключа 2"

// Удаление элемента из WeakMap
weakMap.delete(key1);

// Получение значения, которое было удалено
console.log(weakMap.get(key1)); // undefined


/*
Здесь мы создаем два объекта `key1` и `key2`, которые будут использоваться в качестве ключей в WeakMap. 
Затем мы создаем WeakMap `weakMap` и добавляем в нее элементы с использованием метода `set()`. 
Мы также можем получать значения из WeakMap с помощью метода `get()` и удалять элементы с помощью метода `delete()`. 
Важно отметить, что объекты `key1` и `key2` не будут предотвращать сборку мусора, даже если на них больше нет других ссылок, потому что они хранятся в WeakMap как слабые ссылки.

В данном примере ключи `key1` и `key2` будут доступны только до тех пор, пока на них есть хотя бы одна сильная ссылка в программе. В данном случае, когда мы создаем объекты `key1` и `key2`, у нас есть сильные ссылки на них, потому что они непосредственно присваиваются переменным `key1` и `key2`.

Однако, если мы удалим все ссылки на объекты `key1` и `key2`, то они станут недоступными и будут удалены сборщиком мусора, даже если они используются в качестве ключей в WeakMap. Другими словами, наличие ключей в WeakMap не предотвращает их удаление сборщиком мусора, если на них больше нет сильных ссылок из других частей программы.
*/


// weakMap.clear();  // TypeError: weakMap.clear is not a function
console.log(weakMap.size);  // undefined

/*
Когда вы вызываете `weakMap.size`, возвращается значение `undefined`, потому что свойство `size` не определено для объектов WeakMap в JavaScript.

WeakMap - это специальный тип коллекции, предоставляемый JavaScript, который не обладает свойством `size`, как, например, у Map. Это связано с тем, что объекты, хранящиеся в WeakMap, могут быть удалены сборщиком мусора, когда на них больше нет сильных ссылок, и следовательно, точное количество элементов в WeakMap в определенный момент времени может быть недоступно.



О другом пример:
*/

let key11 = {};
let key12 = {};

const weakMap22 = new WeakMap();
weakMap22.set(key11, "значение для ключа 11");
weakMap22.set(key12, "значение для ключа 12");

// Удаление всех ссылок на объекты key11 и key12
key11 = null;
key12 = null;

// Здесь объекты key11 и key12 больше не доступны
// Они будут удалены сборщиком мусора, и их значения в WeakMap станут недоступными

/*
После того, как мы установили `key11` и `key12` в `null`, на них не осталось никаких сильных ссылок, и они становятся доступными для сборщика мусора.

Название "слабая ссылка" (weak reference) связано с тем, что объекты, хранящиеся в WeakMap (или в WeakSet), не помешают сборщику мусора удалять сами эти объекты из памяти, если на них больше нет сильных ссылок.

В контексте WeakMap (и WeakSet), "слабые" ссылки означают, что они не увеличивают счетчик ссылок на объекты, на которые они указывают. То есть, когда все сильные ссылки на объект удаляются (например, когда переменная, содержащая ссылку на объект, уничтожается), объект может быть автоматически удален из памяти, даже если он используется в качестве ключа в WeakMap.

Это особенно полезно для ситуаций, когда вы хотите связать данные с объектом, но не хотите, чтобы сам объект предотвращался от удаления сборщиком мусора, когда он больше не нужен. Например, если объекты используются в качестве ключей в слабой коллекции данных (как в случае с WeakMap), и вам не нужно дополнительно управлять их удалением из этой коллекции.
*/


/*
Set Наборы***********************************************


Набор (set) - это коллекция данных, в которой дубликаты недопустимы. Используя наш предыдущий пример, мы можем назначить пользователя на несколько ролей. 

Например, у всех пользователей могла бы быть роль "User", а у администраторов - и "User", и "Adrnin". Однако для пользователя нет никакого логического
смысла иметь одну и ту же роль многократно. 

Набор - идеальная структура данных для этого случая.
Сначала создайте экземпляр объекта Set.
*/
const roles = new Set(); 
/*
Если мы теперь хотим добавить роль пользователя, можем воспользоваться методом add ( ) .
*/

roles.add("User");
console.log(roles);  // Set(1) { 'User' }

/*

Чтобы сделать этого пользователя администратором, вызовите метод add () снова.
*/

roles.add("Admin");

console.log(roles);  // Set(2) { 'User', 'Admin' }
/*
Как и у Мар, у объекта Set есть свойство size.
*/
roles.size;

console.log(roles.size);  // 2

/*
Достоинство наборов в том, что мы не должны выяснять, находится ли уже нечто в наборе, прежде чем его добавим. При попытке добавить в набор нечто, что уже там
находится, ничего не происходит.
*/
roles.add("User");

console.log(roles.size);  // 2

/*
Чтобы удалить роль, мы просто вызываем метод delete (), который возвращает true, если роль была в наборе, и false - в противном случае.
*/
console.log(roles.delete("Admin"));  // true
console.log(roles);  // Set(1) { 'User' }
console.log(roles.delete("Admin"));  //  false

/*
Слабые наборы ******************************************


Слабые наборы могут содержать только объекты, и эти объекты удаляются в процессе сборки мусора. Как и в WeakМap, значения в WeakSet не могут быть перебраны,
что делает слабые наборы очень редко применяемыми. Фактически единственный подходящий случай использования для слабых наборов - это когда необходимо
определять, есть ли данный объект в наборе.

Например, у Санта Клауса мог бы быть WeakSet по имени naughty (непослушные), чтобы он мог решить, кому достанется уголь.
*/

const naughty = new WeakSet();
const children = [
    {name: "Suzy"},
    {name: "Derek"},
]

naughty.add(children[1]);

for(let child of children) {
    if (naughty.has(child)) {
        console.log(`Уголь для ${child.name}!`);
    } else {
        console.log(`Подарки для ${child.name}!`);
    }
}

/*

Расставаясь с объектной привычкой********************
Если вы - опытный программист JavaScript, который является новичком в ЕSб,
возможно, вы уже привыкли использовать объекты для сопоставления значений.
И без сомнения, вы изучили все нюансы применения объектов в виде отображений,
позволяющие обойти подводные камни. 
Но теперь у вас есть реальные отображения map,
и вы должны использовать их! Аналогично вы, вероятно, привыкли использовать
объекты с логическими значениями в качестве наборов set; вам также больше не нужно
делать это. Когда вы создаете объект, остановитесь и спросите себя: "Я использую
этот объект, только чтобы получить отображение?" Если ответ - "Да': то рассмотрите возможность использования вместо него объекта Мар.

*/

