/*
Исключения и обработка ошибок

Все мы хотели бы жить в мире без ошибок, но у нас такой роскоши нет. Большинство даже тривиальных приложений подвержено ошибкам, являющимся результатом
обстоятельств, которые вы не предвидели. 

Первый шаг к созданию надежного, высококачественного программного обеспечения - это признать, что в нем будут ошибки.

Второй шаг - предвидение этих ошибок и их обработка разумным способом.

Обработка исключений ( exception handling) - это механизм, который позволяет
справляться с ошибками контролируемым способом. 

Обработка исключений, в отличие от обработки ошибок (error handling), предназначена, чтобы справляться с исключительными обстоятельствами, т.е. не с теми ошибками, которые вы ожидаете,
а с непредвиденными.

Грань между ожидаемыми и непредвиденными ошибками (исключениями) весьма расплывчата и очень ситуативна. От приложения, которое предназначено для использования широкой неподготовленной публикой, можно ожидать намного более
непредсказуемого поведения, чем от приложения, предназначенного для использования квалифицированными пользователями.

Примером ожидаемой ошибки является ввод в форме неправильного адреса электронной почты: люди все время делают опечатки. 

Непредвиденной ошибкой могло
бы быть исчерпание дискового пространства или невозможность доступа к обычно
всегда работающей службе.


Объект Error*******************************************

В JavaScript есть встроенный объект Error, который удобен для обработки ошибок любого вида (исключений и ожидаемых). 
Создавая экземпляр объекта Error, вы
можете присвоить ему сообщение об ошибке.
*/
const err = new Error("Ошибочный email"); 

/*
Создание экземпляра Error само по себе ничего не делает. Оно лишь предоставляет вам средство для сообщения об ошибке. 
Вообразите функцию, которая проверяет адреса электронной почты. Если функция сработала успешно, она возвращает адрес электронной почты как строку. Если это не так, она возвращает экземпляр объекта Error. 

Для простоты будем считать нечто, содержащее символ @ , допустимым адресом электронной почты .
*/
function validateEmail(email) {
    return email.match(/@/) ?
    email :
    new Error(`Ошибочный email: ${email}`);
}

/*
Чтобы определить, был ли возвращен экземпляр объекта Error, мы можем использовать оператор typeof. Предоставленное нами сообщение об ошибке будет
присвоено свойству message.
*/

const email = "jane@doe.com" ;
// const email = "janedoe.com" ;
// const email = null ;
// const email = undefined ;
// const email = {email: "jane@doe.com"};

const validatedEmail = validateEmail ( email) ;

if (validatedEmail instanceof Error ) {
    console.error(`Oшибкa : ${validatedEmail.message}`);
} else {
    console.log(`Корректный email : ${validatedEmail}`);
}

/*
Хотя это вполне допустимый и полезный способ использования экземпляра
объекта Error, он чаще используется в процессе обработки исключений, который
мы рассмотрим далее.


Обработка искпючений с испопьзованием
бпоков try и саtch************************************

Для обработки исключений используется конструкция операторов try ... catch.

Идея в том, что осуществляется "попытка" (try) что-то сделать, и если при этом произойдет какое-либо исключение, оно будет "перехвачено" (catch). 

Функция validateEmail
в нашем предыдущем примере обрабатывает ожидаемую ошибку, когда некто пропускает символ @ в адресе электронной почты, 
но есть также возможность возникновения и непредвиденной ошибки: непутевый программист может присвоить переменной
email нечто отличное от строки. 

Как следует из предыдущего примера, присвоение переменной email значения null, числа или объекта (чего угодно, кроме строки) приводит  к ошибке. 
В результате программа сразу же прекращает свое выполнение, что весьма
недружественно по отношению к пользователю. Чтобы обезопасить себя от непредвиденной ошибки мы можем поместить свой код в блок оператора try ... catch.
*/

const emailTry = null;  // oyps

// const emailTry = "jane@doe.com"
// const emailTry = "janedoe.com"

try {
    const validatedEmailTry = validateEmail(emailTry);
    if(validatedEmailTry instanceof Error) {
        console.error(`Ошибка: ${validatedEmailTry.message}`)
    } else {
        console.log(`Корректный email: ${validatedEmailTry}`);
    } 
} catch(err) {
    console.error(`Ошибка поймана: ${err.massage}`);
}

console.log("Проверка завершена!");
/*

Поскольку мы перехватываем ошибку, наша программа не будет аварийно завершать работу. В данном случае в обработчике ошибок мы просто выводим соответствующее сообщение и продолжаем работу. Однако что делать, если для продолжения работы программы требуется правильный адрес электронной почты? 
Очевидно,
что в таком случае нужно обработать ошибку более изящно и красиво завершить работу программы.

Обратите внимание, что поток выполнения покидает блок catch, как только происходит ошибка; 
т.е. оператор if, который следует за вызовом validateEmail (), не
будет выполнен. 
В блоке try у вас может быть столько операторов, сколько нужно;
первый из них, который закончится ошибкой, передаст управление блоку catch. 
Если
никаких ошибок нет, блок catch не выполняется, и программа продолжает работу.



Генерирование ошибки**********************************

В нашем предыдущем примере мы использовали оператор 
try ... catch 
для обработки ошибок, которые возникали в самом движке JavaScript (когда мы пытались вызвать метод match для чего-то, что не является строкой). 

Вы можете также сгенерировать ошибку самостоятельно, чтобы задействовать механизм обработки исключений.

В отличие от других языков с обработкой исключений, в JavaScript при генерации ошибки вы можете использовать любое значение: число, строку или любой другой
тип. 

Однако обычно оператору throw передают экземпляр объекта Error. 
Большинство блоков catch ожидает экземпляра объекта Error. 
Имейте в виду, что вы не всегда можете контролировать, где будет обработана сгенерированная вами ошибка
(функции, которые вы пишете, могут быть использованы другими программистами,
вполне резонно ожидающими, что в процессе генерации ошибки оператору throw
передается экземпляр объекта Error).

Например, создавая приложение по оплате счетов для банка, вы могли бы генерировать исключения, если остаток на счете не покрывает платеж (это действительно
исключительный случай, поскольку проверка на такую ситуацию должна осуществляться прежде, чем начнется оплата по счету).
*/
class BankAccount {
    constructor(balance) {
        this.balance = balance;
    }

    transfer(payee, amount) {
        if (amount > this.balance) {
            throw new Error("Недостаточно денег на счету для перевода");
        }
        // Выполняем перевод денег на счет получателя (payee)
        this.balance -= amount;
        payee.balance += amount;
        console.log(`Перевод ${amount} с вашего счета на счет получателя выполнен успешно.`);
    }
}

function billPay(amount, payee, account) {
    if (amount > account.balance) {
        throw new Error("Недостаточно денег");
    }
    account.transfer(payee, amount);
}

// Создаем объекты счетов
const account1 = new BankAccount(1000);
const account2 = new BankAccount(500);

// Выполняем перевод средств с первого счета на второй
billPay(100, account2, account1);  // Перевод 100 с вашего счета на счет получателя выполнен успешно.

console.log("Баланс первого счета:", account1.balance); // Ожидаемый вывод: 900
console.log("Баланс второго счета:", account2.balance); // Ожидаемый вывод: 600

/*
function billPay ( amount, рауее, account ) {
    if(amount > account.balance ) {
        throw new Error ( "Maлo денег.") ;
    }
    account . trans fer ( payee , amount );
}
    
При выполнении оператора throw текущая функция немедленно прекращает свою работу. 

Поэтому в нашем примере вызова метода account.transfer не будет, что нам и требовалось.


Обработка исключений и стек вызовов*********************

Типичная программа вызывает функции, а эти функции, в свою очередь, вызывают другие функции, а эти функции - следующие функции и т.д. 

Интерпретатор JavaScript должен отслеживать их все. 

Если функция а вызывает функцию Ь, 
а функция Ь вызывает функцию с, 
то, когда функция с завершает работу, управление возвращается функции Ь, 
а когда завершается функция Ь, управление возвращается
функции а. 

Поэтому, когда выполняется функция с, функции а и Ь "ожидают".

Эти вложенные функции, которые еще не завершили работу, формируют стек вызовов 

( call stack).

Если в функции с происходит ошибка, то что будет с функциями а и b?
 Очевидно, что в функции Ь также возникнет ошибка, поскольку в ней может использоваться значение, возвращаемое функцией с. 
 Это в свою очередь вызовет ошибку в функции а, поскольку в ней также может использоваться значение, возвращаемое функцией Ь. 
 
 По существу, ошибка будет распространяться по стеку вызовов вверх, пока не будет перехвачена и обработана.

Ошибки могут быть перехвачены и обработаны на любом уровне в стеке вызовов. 
Если они так и не будут перехвачены, интерпретатор JavaScript просто остановит программу. 

Это явление называется необработанным исключением 
(unhandled exception) или не перехваченным исключением 

(uncaught exception), оно всегда приводит к аварийному завершению программы. 

С учетом количества мест, где может произойти ошибка, перехват всех возможных ошибок, способных привести к аварийному завершению программы, становится трудоемким и громоздким.

Когда ошибка перехватывается, стек вызовов предоставляет полезную информацию для диагностики проблемы. 

Например, если функция а вызывает функцию Ь, которая вызывает функцию с и ошибка происходит в функции с,
 то стек вызовов говорит нам не только о том, 
 что ошибка произошла в функции с, 
 но и что она произошла, когда эта функция была вызвана функцией Ь, 
 когда она была вызвана функцией а. 

Это полезная информация, если функция с вызывается из многих разных мест в вашей программе. 

В большинстве реализаций JavaScript экземпляры объекта Error содержат свойство
stack, которое является строковым представлением стека (это нестандартное средство JavaScript, но оно доступно в большинстве систем). 

Вооружившись этими знаниями,
мы можем написать пример, который демонстрирует обработку исключений.
*/

function a () {
    console.log( ' a : вызываем b' ) ;
    b() ;
    console.log( 'a: готово ' );
}

function b() {
    console.log( 'b: вызываем c' ) ;
    c();
    console.log( 'b: готово ' );
}

function c() {
    console.log( ' c : генерируем ошибку ' );
    throw new Error('c ошибка ');
    console.log('c : готово ' );
}

function d () {
    console.log( 'd: вызываем c ' ) ;
    c() ;
    console.log( ' d : готово ' );
}    

try {
    a();
} catch ( err) {
    console.log(err.stack ) ;
}

try {
    d();
} catch ( err) {
    console.log(err.stack) ;
}


/*
Запуск этого примера в Firefox приводит к следующему выводу на консоль.
а: вызываем Ь
Ь: вызываем с
с: генерируем ошибку
c@debugger eval code:lЗ:l
b@debugger eval code:8:4
a@debugger eval code:3:4
@debugger eval code:23:4

d: вызываем с
с: генерируем ошибку
c@debugger eval code:lЗ:l
d@debugger eval code:1 8:4
@debugger eval code:29:4

Строки со знаком @ означают трассировку стека, которая начинается с "самой глубокой" функции (с) и завершается без функции вообще (сам браузер). 
Как можно заметить, имеется две разных трассировки стека. 

В первой мы видим, что функция с была вызвана из Ь, а та, в свою очередь, была вызвана из а. 
Во второй видно, что функция с была вызвана непосредственно из d.


Конструкция try ... catch ... finally******************

Иногда в коде блока try задействуется некий ресурс, такой как подключение
к серверу НТТР или открытие файла. 

Вне зависимости от ошибки мы должны освободить этот ресурс, чтобы он не был постоянно связан с нашей программой. 
Поскольку блок try может содержать любое количество операторов, в каждом из которых может возникнуть ошибка, поэтому блок try не самое безопасное место для освобождения ресурса (поскольку ошибка может произойти прежде, чем представится шанс сделать это). 

Также небезопасно освобождать ресурс в блоке catch, поскольку он не выполняется, если не будет ошибки. 

Это именно та ситуация, которая требует
блока finally, выполняемого вне зависимости от наличия ошибки.


Поскольку мы еще не рассматривали работу с файлами или подключениями
к серверу НТТР, для демонстрации блока finally мы будем просто использовать
пример с операторами console.log.
*/
try {
    console.log("Эта строка выполнена...");
    throw new Error("Упс!");
    console.log("Эта строка не выполняется ...");
} catch(err) {
    console.log("Была ошибка...");
} finally {
    console.log("... всегда выполняется ");
    console.log("Здесь выполняется очистка");
}

/*
Опробуйте этот пример с оператором throw и без него; вы увидите, что блок
finally выполняется в любом случае. 


Позвольте исключениям быть исключениями****************

Теперь, когда вы знаете, что такое обработка исключений и как ее осуществлять,
наверняка вы захотите использовать ее для обработки всех ошибок - как ожидаемых, так и нет. 

В конце концов, генерирование ошибки, чрезвычайно простой и удобный способ "выхода", когда вы попадаете в ситуацию, с которой не можете справиться. 

Но обработка исключений имеет свою цену. Кроме риска, что исключение так и не будет перехвачено (это приведет к аварийному завершению программы), применение исключений создает дополнительную вычислительную нагрузку. 
Поскольку исключения должны "прокрутить" стек, пока не встретится блок catch, интерпретатор JavaScript вынужден выполнять некоторые дополнительные служебные действия.

При постоянном росте скоростей компьютеров это вызывает все меньше и меньше беспокойства, но генерирование исключений в часто используемых ветках программы может снизить ее производительность.

Помните, что каждый раз, генерируя исключение, вы должны обработать его
(если не хотите столкнуться с аварийным завершением программы). 

Вы не можете получить нечто из ничего. Исключения лучше использовать лишь как последнюю линию обороны, для обработки исключительных ситуаций, которые вы не можете
предвидеть, а для исправления ожидаемых ошибок используйте операторы управления потоком. 

*/