/*
Класс: базовый синтаксис
В объектно-ориентированном программировании класс – это расширяемый шаблон кода для создания объектов, который устанавливает в них начальные значения (свойства) и реализацию поведения (методы).
  (Википедия)


На практике нам часто надо создавать много объектов одного вида, например пользователей, товары или что-то ещё.

Как мы уже знаем из главы Конструктор, оператор "new", с этим может помочь new function.

Но в современном JavaScript есть и более продвинутая конструкция «class», которая предоставляет новые возможности, полезные для объектно-ориентированного программирования.

Синтаксис «class»**************************************
Базовый синтаксис выглядит так:

class MyClass {
  // методы класса
  constructor() { ... }
  method1() { ... }
  method2() { ... }
  method3() { ... }
  ...
}
Затем используйте вызов 

new MyClass() 

для создания нового объекта со всеми перечисленными методами.

При этом автоматически вызывается метод constructor(), в нём мы можем инициализировать объект.

Например:
*/

class User {

    constructor(name) {
        this.name = name;
    }

    sayHi() {
        console.log(`Hi ${this.name}!`)
    }
}
// Используем:
let user = new User("Иван");
user.sayHi();  // Hi Иван!



/*
Когда вызывается new User("Иван"):

- Создаётся новый объект.
- constructor запускается с заданным аргументом и сохраняет его в this.name.
- …Затем можно вызывать на объекте методы, такие как user.sayHi().

Методы в классе не разделяются запятой
Частая ошибка начинающих разработчиков – ставить запятую между методами класса, что приводит к синтаксической ошибке.

Синтаксис классов отличается от литералов объектов, не путайте их. Внутри классов запятые не требуются.

Что такое класс?**************************************

Итак, что же такое class? Это не полностью новая языковая сущность, как может показаться на первый взгляд.

Давайте развеем всю магию и посмотрим, что такое класс на самом деле. Это поможет в понимании многих сложных аспектов.

В JavaScript класс – это разновидность функции.

Взгляните:
// доказательство: User - это функция
*/
console.log(typeof User);  //function
/*
Вот что на самом деле делает конструкция class User {...}:

1) Создаёт функцию с именем User, которая становится результатом объявления класса. 
Код функции берётся из метода constructor (она будет пустой, если такого метода нет).

2) Сохраняет все методы, такие как sayHi, в 
User.prototype.

При вызове метода объекта new User он будет взят из прототипа, как описано в файле 7_13_f_prototype.js. 
Таким образом, объекты new User имеют доступ к методам класса.

Можно проверить вышесказанное и при помощи кода:
*/
// класс - это функция
console.log(typeof User);  // function

// ...или, если точнее, это метод constructor
console.log(User === User.prototype. constructor);  // true

// Методы находятся в User.prototype, например:
console.log(User.prototype.sayHi);  // [Function: sayHi]

// в прототипе ровно 2 метода
console.log(Object.getOwnPropertyNames(User.prototype));  // [ 'constructor', 'sayHi' ]

/*
Не просто синтаксический сахар

Иногда говорят, что class – это просто «синтаксический сахар» в JavaScript (синтаксис для улучшения читаемости кода, но не делающий ничего принципиально нового), потому что мы можем сделать всё то же самое без конструкции class:

// перепишем класс User на чистых функциях

// 1. Создаём функцию constructor
*/

function UserFunc(name) {
    this.name = name;
}
/*
// каждый прототип функции имеет свойство constructor по умолчанию,
// поэтому нам нет необходимости его создавать

// 2. Добавляем метод в прототип
*/

UserFunc.prototype.sayHello = function() {
    console.log("Hello " + this.name);
}
/*
// Использование:
*/
let userFunc = new UserFunc("Петя");
userFunc.sayHello();  // Hello Петя
console.log(UserFunc.prototype.sayHello);  // [Function (anonymous)]

/*
Результат этого кода очень похож. Поэтому, действительно, есть причины, по которым class можно считать синтаксическим сахаром для определения конструктора вместе с методами прототипа.

Однако есть важные отличия:

1) Во-первых, функция, созданная с помощью class, помечена специальным внутренним свойством
 [[IsClassConstructor]]: true. 
 Поэтому это не совсем то же самое, что создавать её вручную.

В отличие от обычных функций, конструктор класса не может быть вызван без new:
*/
class UserErr {
    constructor() {}
}

console.log(typeof UserErr);  // function
// UserErr();  //TypeError: Class constructor UserErr cannot be invoked without 'new'
console.log(UserErr);  // [class UserErr]
/*
Кроме того, строковое представление конструктора класса в большинстве движков JavaScript начинается с «class …»
*/
console.log(User);   // [class User]
/*

2) Методы класса являются неперечислимыми. Определение класса устанавливает флаг enumerable в false для всех методов в "prototype".

И это хорошо, так как если мы проходимся циклом for..in по объекту, то обычно мы не хотим при этом получать методы класса.

3) Классы всегда используют use strict. Весь код внутри класса автоматически находится в строгом режиме.

Также в дополнение к основной, описанной выше, функциональности, синтаксис class даёт ряд других интересных возможностей, с которыми мы познакомимся чуть позже.

Class Expression*****************************************

Как и функции, классы можно определять внутри другого выражения, передавать, возвращать, присваивать и т.д.

Пример Class Expression (по аналогии с Function Expression):
*/
let Outsider = class Insider {
    sayHi() {
        console.log(Insider);  // // имя MyClass видно только внутри класса
    }
};

new Outsider().sayHi();  // [class Insider]  // работает, выводит определение - класс Insider

// console.log(Insider);  // ReferenceError: Insider is not defined // ошибка, имя Insider не видно за пределами класса

/*
Аналогично Named Function Expression, Class Expression может иметь имя.

Если у Class Expression есть имя, то оно видно только внутри класса:

// "Named Class Expression"
// (в спецификации нет такого термина, но происходящее похоже на Named Function Expression)

Мы даже можем динамически создавать классы «по запросу»:
*/

function makeClass(phrase) {
  // объявляем класс и возвращаем его
  return class {
    sayHi() {
        console.log(phrase);
    };
  };
}

// Создаём новый класс - вызываем функцию makeClass
let QuickClass = makeClass("Привет!");

new QuickClass().sayHi();   // Привет!

/*
Геттеры/сеттеры, другие сокращения**********************

Как и в литеральных объектах, в классах можно объявлять вычисляемые свойства, геттеры/сеттеры и т.д.

Вот пример user.name, реализованного с использованием get/set:
*/

class UserGet {

    constructor(name) {
        // вызывает сеттер
        this.name = name;
    }

    get name() {
        return this._name;
    }

    set name(value) {
        if (value.length < 4) {
            console.log("Имя слишком короткое.")
            return;
        }
        this._name = value
    }
}

let userGet = new UserGet("Frol");

console.log(userGet.name);  // Frol

userGet = new UserGet("U");  // Имя слишком короткое.
console.log(userGet.name);  // undefined

userGet.name = "Dunya";
console.log(userGet.name);  // Dunya

/*
Если убрать set сеттер, то будет ошибка TypeError: Cannot set property name of #<UserGet> which has only a getter

При объявлении класса геттеры/сеттеры создаются на User.prototype, вот так:
*/

Object.defineProperties(UserGet.prototype, {
    name: {
        get() {
            return this._name
        },
        set(name) {
            // ... 
            if(name.length < 4) {
                console.log("Имя слишком короткое.");
                return;
            }
            this._name = name;
        }
    }
});

/*
Пример с вычисляемым свойством в скобках [...]:
*/
class UserThink {

    ["say" + "Hi"]() {
        console.log("Приветик!");
    }
}

new UserThink().sayHi();  // Приветик!

/*
Свойства классов
--------------------------------------------------
Старым браузерам может понадобиться полифил
Свойства классов добавлены в язык недавно.
---------------------------------------------------
В приведённом выше примере у класса User были только методы. Давайте добавим свойство:
*/

class UserProperty {
    name = "Аноним";

    sayHi() {
        console.log(`Привет, ${this.name} `)
    }
}

 new UserProperty().sayHi();  // Привет, Аноним 

 let userProp = new UserProperty();

 for(let prop in UserProperty) {
    console.log(prop);
}  // пусто - выводит только статические свойства класса

console.log(Object.getOwnPropertyNames(UserProperty));  // [ 'length', 'name', 'prototype' ]

for(let prop in userProp) {
    console.log(prop);   // name
}

console.log(Object.keys(userProp));
// [ 'name' ]

console.log(Object.keys(userProp).length);   // 1

console.log(Object.keys(UserProperty).length)  // 0



/*

Свойство name не устанавливается в User.prototype. Вместо этого оно создаётся оператором new перед запуском конструктора, это именно свойство объекта.

Итого*************************************************

Базовый синтаксис для классов выглядит так:

class MyClass {
  prop = value; // свойство
  constructor(...) { // конструктор
    // ...
  }
  method(...) {} // метод
  get something(...) {} // геттер
  set something(...) {} // сеттер
  [Symbol.iterator]() {} // метод с вычисляемым именем (здесь - символом)
  // ...
}
MyClass технически является функцией (той, которую мы определяем как constructor), в то время как методы, геттеры и сеттеры записываются в MyClass.prototype.

В контексте JavaScript классы действительно являются синтаксическим сахаром. Это означает, что они представляют собой удобный синтаксис для создания объектно-ориентированной структуры кода, но на самом деле используют ту же прототипную модель, которая существует в JavaScript с самого начала.

Классы были введены в стандарте ECMAScript 2015 (ES6) для улучшения читаемости и организации кода, особенно для разработчиков, привыкших к классам из других языков программирования, таких как Java или Python. Однако при компиляции классов они преобразуются в функции и объекты, сохраняя при этом связь с прототипами.

Таким образом, хотя классы и предоставляют более удобный синтаксис для работы с объектами и наследованием, в итоге они все равно преобразуются в те же прототипы и функции, которые были бы использованы в прототипном стиле программирования.
*/