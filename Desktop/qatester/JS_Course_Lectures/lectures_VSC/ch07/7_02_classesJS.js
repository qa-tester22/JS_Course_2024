/*
Classes in JavaScript
Наследование в JavaScript

Зная большую часть подробностей OOJS объектного ориентирования JS, узнаем, 
- как создавать «дочерние» классы объектов (конструкторы), 
- которые наследуют признаки из своих «родительских» классов. 
Кроме того, узнаем когда и где вы можете использовать OOJS , и посмотрим, как классы рассматриваются в современном синтаксисе ECMAScript.

Classes and Constructors

/*
Классы в JavaScript

 мы представили некоторые основные концепции объектно-ориентированного программирования (ООП) и обсудили пример, в котором мы использовали принципы ООП для моделирования преподавателей и студентов в школе.

Мы также говорили о том, как можно использовать прототипы и конструкторы для реализации такой модели, и что JavaScript также предоставляет функции, которые более точно соответствуют классическим концепциям ООП.

рассмотрим эти функции. 
Стоит иметь в виду, что описанные здесь функции не являются новым способом объединения объектов: внутри они по-прежнему используют прототипы. 
Это просто способ упростить создание цепочки прототипов.


Классы и конструкторы

Вы можете объявить класс, используя class ключевое слово. Вот объявление нашего класса Person из предыдущего примера:
*/

class Person {
    name;

    constructor(name) {
        this.name = name;
    }

    introduceSelf() {
        console.log(`Hi! I'm ${this.name}`);
    }

}

/*
Это объявляет класс с именем Person, с:

    - property свойство  name.
    - конструктор, принимающий name параметр, используемый для инициализации name свойства нового объекта
    - метод introduceSelf(), который может ссылаться на свойства объекта, используя this.

Объявление name; не является обязательным: 
вы можете опустить его, и строку this.name = name;

в конструкторе создаст name свойство перед его инициализацией. Однако явное перечисление свойств в объявлении класса может облегчить людям, читающим ваш код, возможность увидеть, какие свойства являются частью этого класса.

Вы также можете инициализировать свойство значением по умолчанию при его объявлении с помощью строки типа 
*/

name = "friend";

/*
Конструктор определяется с помощью constructor ключевого слова. 
Точно так же, как конструктор вне определения класса , он может:

    - создать новый объект
    - привяжите this к новому объекту, чтобы вы могли ссылаться на его this в коде конструктора
    - запустить код в конструкторе
    - вернуть новый объект.

Учитывая приведенный выше код объявления класса, вы можете создать и использовать новый Person экземпляр следующим образом:
*/

const dunya = new Person("Dunya");

dunya.introduceSelf();   //  Hi! I'm Dunya

/*
Обратите внимание, что в этом примере мы вызываем конструктор, используя имя класса Person.

****************************************************
Ommitting constructors
Пропуск конструкторов

Если вам не нужно выполнять какую-либо специальную инициализацию, вы можете опустить конструктор, и для вас будет создан конструктор по умолчанию:
*/


class Animal {
    sleep() {
        console.log("zzzzzzzzzzzzzzzzz");
    }
}

const spot = new Animal();   // - экземпляр

spot.sleep();    // zzzzzzzzzzzzzzzzz


// не обязательно прописывать конструктор - он генерируется  в классах по дефолту

class Animals {

    constructor() {

    }

    sleep() {
        console.log("ZZZZZ");
    }
}

const spotic = new Animals();
spotic.sleep();  //  ZZZZZ

/*
Наследование
Inheritance 
Учитывая наш Person класс выше, давайте определим подкласс Professor.
*/

class Professor extends Person {   //  - подкласс
    teaches;

    constructor(name, teaches) {
        super(name);
        this.teaches = teaches;
    }

    introduceSelf() {
        console.log(
            `My name is ${this.name}, and I will be your ${this.teaches} Professor.`,
            );
    }

    grade(paper) {
        const grade = Math.floor(Math.random() * (5 - 1) + 1);
        console.log(grade);
    }
}

/*
Мы используем extends (простирается, продлевать) ключевое слово, чтобы сказать, что этот класс наследуется от другого класса.

Класс Professor добавляет новое свойство teaches, поэтому мы его объявляем.

Поскольку мы хотим установить teaches момент создания нового Professor, мы определяем конструктор, который принимает name и teaches в качестве аргументов. 

Первое, что делает этот конструктор, — это вызывает конструктор суперкласса с помощью super(), передавая name параметр. 
Конструктор суперкласса заботится о настройке name. 

После этого Professor конструктор устанавливает teaches свойство.

Примечание. Если подклассу необходимо выполнить какую-либо собственную инициализацию, он должен сначала вызвать конструктор суперкласса с помощью super(), передав любые параметры, которые ожидает конструктор суперкласса.

Мы также переопределили introduceSelf() метод из суперкласса 
и добавили новый метод grade() для оценки работ (наш профессор не очень хорош и просто ставит случайные оценки за контрольную работу).

С помощью этого объявления мы теперь можем создавать и использовать профессоров:
*/

const flor = new Professor ("Flor", "Python");
flor.introduceSelf();   // My name is Flor, and I will be your Python Professor.

flor.grade("my paper");  // 4

/********************************************************
Инкапсуляция
Encapsulation 

Наконец, давайте посмотрим, как реализовать инкапсуляцию в JavaScript. 
ранее мы обсуждали, как нам хотелось бы сделать year свойство Student частным, чтобы мы могли изменять правила, касающиеся классов стрельбы из лука, не нарушая при этом какой-либо код, использующий этот Student класс.

Вот объявление класса Student, который делает именно это:
*/

class Student extends Person {
    #year;

    constructor (name, year) {
        super(name);
        this.#year = year;
    }

    introduceSelf() {
        console.log(`Hi! I'm ${this.name}, and I'm in year ${this.#year}.`);
    }

    canStudyArchery() {
        return this.#year > 1;
    }
}

/*
В этом объявлении класса #year является частным свойством данных . Мы можем создать Student объект и использовать его #year для внутренних целей, но если код вне объекта попытается получить доступ, #year браузер выдаст ошибку:
*/



const kondrat = new Student("Kondrat", 2);

kondrat.introduceSelf();    //  Hi! I'm Kondrat, and I'm in year 2.
kondrat.canStudyArchery();  // 

// kondrat.#year;   // SyntaxError: Private field '#year' must be declared in an enclosing class

/*
Примечание. Код, запущенный в консоли Chrome, может получить доступ к частным свойствам за пределами класса. Это ослабление ограничения синтаксиса JavaScript только для DevTools.

Свойства частных данных должны быть объявлены в объявлении класса, а их имена начинаются с #.

Частные методы******************************************

У вас могут быть как частные методы, так и частные свойства данных.
 Как и свойства частных данных, их имена начинаются с #, и их можно вызывать только собственными методами объекта:
*/

class Example {
    somePublicMethod() {
        this.#somePrivateMethod();
    }

    #somePrivateMethod() {
        console.log("You called me?");
    }
}

const myExample = new Example();

myExample.somePublicMethod();   //  You called me?

// myExample.#somePrivateMethod();  // SyntaxError: Private field '#somePrivateMethod' must be declared in an enclosing class



/*Проверьте свои навыки!
OOJS 1
В этой задаче мы предоставляем вам начало определения класса Shape. Он имеет три свойства: name, sides, и sideLength. Этот класс моделирует только фигуры, все стороны которых имеют одинаковую длину, например квадрат или равносторонний треугольник.

Мы хотели бы, чтобы вы:

Добавьте конструктор в этот класс. Конструктор принимает аргументы для свойств name, sidesи sideLengthи инициализирует их.
Добавьте в класс новый метод calcPerimeter(), который вычисляет ее периметр (длину внешнего края фигуры) и записывает результат в консоль.
Создайте новый экземпляр класса Shapeс именем square. Дайте nameему square, 4 sidesи sideLength.5​
Вызовите свой calcPerimeter()метод в экземпляре, чтобы проверить, записывает ли он результаты вычислений в консоль браузера, как ожидалось.
Создайте новый экземпляр ShapeCalled triangleс nameof triangleи 3 sidesof .sideLength3
Позвоните triangle.calcPerimeter(), чтобы убедиться, что все работает.
*/



class Shape {
    name;
    sides; 
    sideLength;

    constructor(name, sides, sideLength) {
        this.name = name;
        this.sides = sides;
        this.sideLength = sideLength;
    }

    calcPerimeter() {
        
        return  console.log(`Perimeter of ${this.name} is equal to ${this.sides * this.sideLength}`);
    }
}

// create new instance of Shape  called square

const square = new Shape ("square", 4, 5);

square.calcPerimeter();  // Perimeter is equal to 20

const triangle = new Shape("triangle", 3, 3);

triangle.calcPerimeter();  // Perimeter is equal to 9


// OOJS 2
/*
Далее мы хотим, чтобы вы создали Squareкласс, который наследуется от Shape, и добавляет calcArea()метод, вычисляющий площадь квадрата. Также настройте конструктор так, чтобы nameсвойству Squareэкземпляров объекта автоматически присваивалось значение square, а sidesдля свойства автоматически устанавливалось значение 4. Поэтому при вызове конструктора вам нужно просто предоставить свойство sideLength.

Создайте экземпляр класса Square, вызываемого squareс соответствующими значениями свойств, и вызовите его методы calcPerimeter()и calcArea(), чтобы показать, что он работает нормально.
*/

class Square extends Shape {
    
    constructor (sideLength){
        
        super("square", 4, sideLength);
    }
    
    calcArea() {
        const area = this.sideLength ** 2;
        console.log(`The ${this.name}'s area is ${area}. `);
        return area;
    }
}

const square2 = new Square(5);

square2.calcPerimeter();  // Perimeter of square is equal to 20

square2.calcArea();  // The square's area is 25.



/*
В JavaScript существует несколько основных определений, связанных с работой с классами:

1. **class**: Это ключевое слово используется для определения нового класса. Например:

    ```javascript
    class MyClass {
        // Тело класса
    }
    ```

2. **constructor**: Это метод внутри класса, который выполняется при создании нового экземпляра класса. Он инициализирует объект. Например:

    ```javascript
    class MyClass {
        constructor() {
            // Инициализация объекта
        }
    }
    ```

3. **extends**: Это ключевое слово используется для создания подкласса, который наследует функциональность родительского класса. Например:

    ```javascript
    class ChildClass extends ParentClass {
        // Дополнительные свойства и методы подкласса
    }
    ```

4. **super**: Это ключевое слово используется в подклассе для вызова конструктора родительского класса или методов родительского класса. Например:

    ```javascript
    class ChildClass extends ParentClass {
        constructor() {
            super(); // Вызов конструктора родительского класса
        }
    }
    ```

5. **static**: Это ключевое слово используется для создания статических методов или свойств класса, которые доступны непосредственно от класса, а не от его экземпляров. Например:

    ```javascript
    class MyClass {
        static myStaticMethod() {
            // Статический метод
        }
    }

    MyClass.myStaticMethod(); // Вызов статического метода без создания экземпляра класса
    ```

Эти определения позволяют создавать и работать с классами в JavaScript, что обеспечивает более удобное и организованное программирование в сравнении с использованием прототипов.

В JavaScript классы представляют собой основной механизм для создания объектов и организации объектно-ориентированного программирования. Вот несколько ключевых определений, связанных с работой с классами в JavaScript:

1. **class**: Ключевое слово `class` используется для определения нового класса. Класс может содержать конструктор и другие методы.

```javascript
class MyClass {
  constructor() {
    // Конструктор класса
  }

  // Другие методы класса
}
```

2. **constructor**: Конструктор - это специальный метод, который вызывается при создании нового экземпляра класса. Он используется для инициализации объектов.

```javascript
class MyClass {
  constructor(name) {
    this.name = name;
  }
}
```

3. **new**: Оператор `new` используется для создания нового экземпляра класса.

```javascript
const obj = new MyClass('example');
```

4. **extends**: Ключевое слово `extends` используется для создания подклассов, которые наследуют функциональность от другого класса (родительского класса).

```javascript
class SubClass extends ParentClass {
  // Класс подкласса
}
```

5. **super**: Ключевое слово `super` используется в подклассе для вызова конструктора родительского класса или для вызова методов родительского класса.

```javascript
class SubClass extends ParentClass {
  constructor() {
    super(); // Вызываем конструктор родительского класса
  }
}
```

Это основные определения, связанные с работой с классами в JavaScript. Использование классов облегчает создание объектно-ориентированного кода и обеспечивает более четкую структуру программы.

Да, верно. В JavaScript хэш-символ (`#`) используется для обозначения приватных полей и методов в классах при использовании синтаксиса private fields.

Пример:

```javascript
class Example {
    #privateField;

    constructor() {
        this.#privateField = 'private';
    }

    #privateMethod() {
        console.log('This is a private method.');
    }

    publicMethod() {
        this.#privateMethod();
        console.log(`Accessing private field: ${this.#privateField}`);
    }
}

const instance = new Example();
instance.publicMethod();
```

В этом примере `#privateField` и `#privateMethod()` являются приватными для класса `Example` и не могут быть доступны извне класса. Только публичный метод `publicMethod()` может обращаться к ним.

Нет, символ `#` и ключевое слово `static` имеют разные цели и применения в JavaScript.

1. **Приватные поля (#)**: Символ `#` используется для обозначения приватных полей и методов в классах при использовании синтаксиса private fields. Приватные поля недоступны извне класса, и их нельзя изменить или прочитать вне методов класса.

2. **Статические методы и поля (static)**: Ключевое слово `static` используется для определения методов и полей класса, которые принадлежат самому классу, а не его экземплярам. Статические методы и поля доступны для использования без создания экземпляра класса, и они общие для всех экземпляров класса.

Пример использования `static`:

```javascript
class Example {
    static staticField = 'static';
    static staticMethod() {
        console.log('This is a static method.');
    }
}

console.log(Example.staticField); // 'static'
Example.staticMethod(); // 'This is a static method.'
```

В этом примере `staticField` и `staticMethod()` принадлежат самому классу `Example` и доступны для использования без создания экземпляра класса.
*/



/*
Вы дочитали эту статью до конца, но сможете ли вы запомнить самую важную информацию? Прежде чем двигаться дальше, вы можете найти дополнительные тесты, чтобы убедиться, что вы сохранили эту информацию — см. Проверка своих навыков: объектно-ориентированный JavaScript .

Краткое содержание
В этой статье мы рассмотрели основные инструменты JavaScript для написания объектно-ориентированных программ. Мы рассмотрели здесь не все, но этого должно быть достаточно, чтобы вы начали. Наша статья о классах — хорошее место, чтобы узнать больше.

*/








/*


Прототипное наследование

До сих пор мы видели некоторое наследование в действии - мы видели, как работают прототипы и как элементы наследуются, поднимаясь по цепочке. Но в основном это связано с встроенными функциями браузера. 
Как создать объект в JavaScript, который наследует от другого объекта?

Давайте рассмотрим, как это сделать на конкретном примере.

создадим пример конструктора Person(), который мы использовали, с небольшим отличием - мы определили внутри конструктора только лишь свойства:


fucn


function Person(first, last, age, gender, interests) {
  this.name = {
    first,
    last,
  };
  this.age = age;
  this.gender = gender;
  this.interests = interests;
}
Все методы определены в прототипе конструктора. Например:


Person.prototype.greeting = function () {
  alert("Hi! I'm " + this.name.first + ".");
};
Примечание: . В исходном коде вы также увидите определённые методы bio() и farewell(). Позже вы увидите, как они могут быть унаследованы другими конструкторами.

Скажем так, мы хотели создать класс Teacher, подобный тому, который мы описали в нашем первоначальном объектно-ориентированном определении, которое наследует всех членов от Person, но также включает в себя:

Новое свойство, subject - оно будет содержать предмет, который преподаёт учитель.
Обновлённый метод greeting(), который звучит немного более формально, чем стандартный метод greeting() — более подходит для учителя, обращающегося к некоторым ученикам в школе.
Определение функции-конструктора Teacher()
Первое, что нам нужно сделать, это создать конструктор Teacher() - добавьте ниже следующий код:


function Teacher(first, last, age, gender, interests, subject) {
  Person.call(this, first, last, age, gender, interests);

  this.subject = subject;
}
Это похоже на конструктор Person во многих отношениях, но здесь есть что-то странное, что мы не видели раньше - функцию call(). Эта функция в основном позволяет вам вызывать функцию, определённую где-то в другом месте, но в текущем контексте. Первый параметр указывает значение this, которое вы хотите использовать при выполнении функции, а остальные параметры - те, которые должны быть переданы функции при её вызове.

Мы хотим, чтобы конструктор Teacher() принимал те же параметры, что и конструктор Person(), от которого он наследуется, поэтому мы указываем их как параметры в вызове call().

Последняя строка внутри конструктора просто определяет новое свойство subject, которое будут иметь учителя, и которого нет у Person().

В качестве примечания мы могли бы просто сделать это:



function Teacher(first, last, age, gender, interests, subject) {
  this.name = {
    first,
    last,
  };
  this.age = age;
  this.gender = gender;
  this.interests = interests;
  this.subject = subject;
}
Но это просто переопределяет свойства заново, а не наследует их от Person(), так что теряется смысл того, что мы пытаемся сделать. Он также занимает больше строк кода.

Наследование от конструктора без параметров
Обратите внимание, что если конструктор, от которого вы наследуете, не принимает значения своего свойства из параметров, вам не нужно указывать их в качестве дополнительных аргументов в call(). Так, например, если у вас было что-то действительно простое:


function Brick() {
  this.width = 10;
  this.height = 20;
}
Вы можете наследовать свойства width и height, выполнив это (как и другие шаги, описанные ниже, конечно):


function BlueGlassBrick() {
  Brick.call(this);

  this.opacity = 0.5;
  this.color = "blue";
}
Обратите внимание, что мы указали только this внутри call() - никаких других параметров не требуется, поскольку мы не наследуем никаких свойств родителя, которые задаются через параметры.

Установка Teacher()'s prototype и конструктор ссылок
Пока все хорошо, но у нас есть проблема. Мы определили новый конструктор и у него есть свойство prototype, которое по умолчанию просто содержит ссылку на саму конструкторскую функцию. Он не содержит методов свойства prototype конструктора Person. Чтобы увидеть это, введите Object.getOwnPropertyNames(Teacher.prototype) в поле ввода текста или в вашу консоль JavaScript. Затем введите его снова, заменив Teacher на Person. Новый конструктор не наследует эти методы. Чтобы увидеть это, сравните выводы в консоль Person.prototype.greeting и Teacher.prototype.greeting. Нам нужно заставить Teacher() наследовать методы, определённые на прототипе Person(). Итак, как мы это делаем?

Добавьте следующую строку ниже своего предыдущего добавления:


Teacher.prototype = Object.create(Person.prototype);
Здесь наш друг create() снова приходит на помощь. В этом случае мы используем его для создания нового объекта и делаем его значением Teacher.prototype. Новый объект имеет свой прототип Person.prototype и, следовательно, наследует, если и когда это необходимо, все доступные методы Person.prototype.
Нам нужно сделать ещё одну вещь, прежде чем двигаться дальше. После добавления последней строки, Teacher.prototype.constructor стало равным Person(), потому что мы просто устанавливаем Teacher.prototype для ссылки на объект, который наследует его свойства от Person.prototype! Попробуйте сохранить код, загрузите страницу в браузере и введите Teacher.prototype.constructor в консоль для проверки.
Это может стать проблемой, поэтому нам нужно сделать это правильно. Вы можете сделать это, вернувшись к исходному коду и добавив следующие строки внизу:
Object.defineProperty(Teacher.prototype, 'constructor', {
    value: Teacher,
    enumerable: false, // false, чтобы данное свойство не появлялось в цикле for in
    writable: true });
Теперь, если вы сохраните и обновите, введите Teacher.prototype.constructor, чтобы вернуть Teacher(), плюс мы теперь наследуем Person()!
Предоставление Teacher() новой функции greeting()
Чтобы завершить наш код, нам нужно определить новую функцию greeting() в конструкторе Teacher().

Самый простой способ сделать это - определить его на прототипе Teacher() - добавить в нижнюю часть кода следующее:


Teacher.prototype.greeting = function () {
  var prefix;

  if (
    this.gender === "male" ||
    this.gender === "Male" ||
    this.gender === "m" ||
    this.gender === "M"
  ) {
    prefix = "Mr.";
  } else if (
    this.gender === "female" ||
    this.gender === "Female" ||
    this.gender === "f" ||
    this.gender === "F"
  ) {
    prefix = "Mrs.";
  } else {
    prefix = "Mx.";
  }

  alert(
    "Hello. My name is " +
      prefix +
      " " +
      this.name.last +
      ", and I teach " +
      this.subject +
      ".",
  );
};
Это выводит на экран приветствие учителя, в котором используется соответствующий префикс имени для своего пола, разработанный с использованием условного оператора.

Попробуйте пример
Теперь, когда вы ввели весь код, попробуйте создать экземпляр объекта из Teacher(), поставив ниже вашего JavaScript-кода (или что-то похожее по вашему выбору):


var teacher1 = new Teacher(
  "Dave",
  "Griffiths",
  31,
  "male",
  ["football", "cookery"],
  "mathematics",
);
Теперь сохраните, обновите, и попробуйте получить доступ к свойствам и методам вашего нового объекта teacher1, например:

JS
Copy to Clipboard
teacher1.name.first;
teacher1.interests[0];
teacher1.bio();
teacher1.subject;
teacher1.greeting();
teacher1.farewell();
Все должно работать нормально. Запросы в строках 1, 2, 3 и 6 унаследованные от общего конструктора Person() (класса). Запрос в строке 4 обращается к subject, доступному только для более специализированного конструктора (класса) Teacher(). Запрос в строке 5 получил бы доступ к методу greeting(), унаследованному от Person(), но Teacher() имеет свой собственный метод greeting() с тем же именем, поэтому запрос обращается к этому методу.

Примечание: . Если вам не удаётся заставить это работать, сравните свой код с нашей готовой версией (см. также рабочее демо).

Методика, которую мы здесь рассмотрели, - это не единственный способ создания наследующих классов в JavaScript, но он работает нормально и это даёт вам представление о том, как реализовать наследование в JavaScript.

Вам также может быть интересно узнать некоторые из новых функций ECMAScript, которые позволяют нам делать наследование более чисто в JavaScript (см. Classes). Мы не рассматривали их здесь, поскольку они пока не поддерживаются очень широко в браузерах. Все остальные конструкторы кода, которые мы обсуждали в этом наборе статей, поддерживаются ещё в IE9 или ранее и есть способы добиться более ранней поддержки, чем это.

Обычный способ - использовать библиотеку JavaScript - большинство популярных опций имеют простой набор функций, доступных для выполнения наследования более легко и быстро. CoffeeScript , например, предоставляет класс, расширяет и т.д.

Дальнейшее упражнение
В нашем руководстве по Объектно-ориентированному JavaScript для начинающих (en-US) мы также включили класс Student как концепцию, которая наследует все особенности Person, а также имеет другой метод greeting() от Person, который гораздо более неформален, чем приветствие Teacher. Посмотрите, как выглядит приветствие ученика в этом разделе, и попробуйте реализовать собственный конструктор Student(), который наследует все функции Person() и реализует другую функцию greeting().

Примечание: . Если вам не удаётся заставить это работать, сравните свой код с нашей готовой версией (см. также рабочее демо).

Object member summary
Подводя итог, вы в основном получили три типа свойств / методов, о которых нужно беспокоиться:

Те, которые определены внутри функции-конструктора, которые присваиваются экземплярам объекта. Их довольно легко заметить - в вашем собственном коде они представляют собой элементы, определённые внутри конструктора, используя строки this.x = x; в встроенном коде браузера они являются членами, доступными только для экземпляров объектов (обычно создаются путём вызова конструктора с использованием ключевого слова new, например var myInstance = new myConstructor ().
Те, которые определяются непосредственно самим конструктором, которые доступны только для конструктора. Они обычно доступны только для встроенных объектов браузера и распознаются путём непосредственной привязки к конструктору, а не к экземпляру. Например, Object.keys().
Те, которые определены в прототипе конструктора, которые наследуются всеми экземплярами и наследуют классы объектов. К ним относятся любой член, определённый в свойстве прототипа конструктора, например. myConstructor.prototype.x().
Если вы не уверены, что это такое, не беспокойтесь об этом, пока вы ещё учитесь и знание придёт с практикой.

Когда вы используете наследование в JavaScript?
В частности, после этой последней статьи вы можете подумать: «У-у-у, это сложно». Ну, ты прав. Прототипы и наследование представляют собой некоторые из самых сложных аспектов JavaScript, но многие возможности и гибкость JavaScript вытекают из его структуры объектов и наследования и стоит понять, как это работает.

В некотором смысле вы используете наследование все время. Всякий раз, когда вы используете различные функции веб-API или методы/свойства, определённые во встроенном объекте браузера, который вы вызываете в своих строках, массивах и т.д., вы неявно используете наследование.

Что касается использования наследования в вашем собственном коде, вы, вероятно, не будете часто его использовать, особенно для начала и в небольших проектах. Это пустая трата времени на использование объектов и наследование только ради этого, когда они вам не нужны. Но по мере того, как ваши базы кода становятся больше, вы с большей вероятностью найдёте необходимость в этом. Если вы начинаете создавать несколько объектов с подобными функциями, то создание универсального типа объекта, содержащего все общие функции и наследование этих функций в более специализированных типах объектов, может быть удобным и полезным.

Примечание: . Из-за того, как работает JavaScript, с цепочкой прототипов и т.д., совместное использование функций между объектами часто называется делегированием. Специализированные объекты делегируют функциональность универсальному типу объекта.

При использовании наследования вам рекомендуется не иметь слишком много уровней наследования и тщательно отслеживать, где вы определяете свои методы и свойства. Можно начать писать код, который временно изменяет прототипы встроенных объектов браузера, но вы не должны этого делать, если у вас нет действительно веской причины. Слишком много наследования могут привести к бесконечной путанице и бесконечной боли при попытке отладки такого кода.

В конечном счёте, объекты - это ещё одна форма повторного использования кода, например функций или циклов, со своими конкретными ролями и преимуществами. Если вы обнаруживаете, что создаёте кучу связанных переменных и функций и хотите отслеживать их все вместе и аккуратно их упаковывать, объект является хорошей идеей. Объекты также очень полезны, когда вы хотите передать коллекцию данных из одного места в другое. Обе эти вещи могут быть достигнуты без использования конструкторов или наследования. Если вам нужен только один экземпляр объекта, вам лучше всего использовать литерал объекта и вам, разумеется, не нужно наследование.

Резюме
В этой статье мы рассмотрели оставшуюся часть основной теории и синтаксиса OOJS, которые, как мы думаем, вам следует знать сейчас. На этом этапе вы должны понимать основы JavaScript, ООП, прототипы и прототипное наследование, как создавать классы (конструкторы) и экземпляры объектов, добавлять функции в классы и создавать подклассы, которые наследуются от других классов.

В следующей статье мы рассмотрим, как работать с JavaScript Object Notation (JSON), общим форматом обмена данными, написанным с использованием объектов JavaScript.

See also
ObjectPlayground.com — A really useful interactive learning site for learning about objects.
Secrets of the JavaScript Ninja, Chapter 6 — A good book on advanced JavaScript concepts and techniques, by John Resig and Bear Bibeault. Chapter 6 covers aspects of prototypes and inheritance really well; you can probably track down a print or online copy fairly easily.
You Don't Know JS: this & Object Prototypes — Part of Kyle Simpson's excellent series of JavaScript manuals, Chapter 5 in particular looks at prototypes in much more detail than we do here. We've presented a simplified view in this series of articles aimed at beginners, whereas Kyle goes into great depth and provides a more complex but more accurate picture.

Delegation в JavaScript - это паттерн проектирования, который позволяет объекту делегировать (или передавать) определенные операции или свойства другому объекту. Этот паттерн основан на принципе композиции, когда объекты объединяются вместе для достижения определенного функционала.

В JavaScript делегация часто достигается с помощью прототипного наследования и объектов прототипов.

Вот пример, как можно реализовать делегацию в JavaScript:

```javascript
// Создаем объект для делегации
const delegate = {
  sayHello: function() {
    return `Hello, ${this.name}!`;
  }
};

// Создаем основной объект
const object = {
  name: "World"
};

// Делегируем метод sayHello объекту delegate
object.sayHello = delegate.sayHello;

console.log(object.sayHello()); // Выведет "Hello, World!"
```

В этом примере `delegate` содержит метод `sayHello`, а `object` делегирует вызов этого метода объекту `delegate`. Таким образом, при вызове `object.sayHello()`, вызывается метод `sayHello` объекта `delegate`, но контекст `this` остается в объекте `object`, что позволяет получить доступ к его свойствам (например, `name`).

*/