/*
(JS носорог)
объект - это контейнер, и его содержимое может измениться со временем
*/

const objEx = {} // создаем объект
const user = {}
const shoppingCart = {}  //  обычно используется описательное имя

/*
Содержимое объекта называется свойствами (properties) или членами (members),
а свойства состоят из имени (или ключа) key и значения value. 
Имена свойств должны быть строками или символами, а значения могут иметь любой тип (включая другие объекты). Давайте добавим в объект obj свойство color.
*/

objEx.size;  // undefined
objEx.color = " yellow"   // "yellow"

/*
Чтобы использовать оператор обращения к члену класса, имя свойства должно быть корректным идентификатором. Если нужны имена свойств, не являющиеся допустимыми идентификаторами, используйте оператор вычисляемого доступа к члену (computed member access), применимый также и к допустимым идентификаторам.
*/
objEx["not an identifier"] = 3;
console.log(objEx["not an identifier"]);   // 3
console.log(objEx["color"]);  //  yellow

/*
Оператор вычисляемого доступа к члену применим и для свойств символов.
*/
const SIZE = Symbol();
objEx[SIZE] = 8;
console.log(objEx[SIZE]); //  8  - свойство объекта

/*
Здесь объект obj содержит три свойства с ключами: "color" (строка, являющаяся допустимым идентификатором), 
"not an identifier" (строка, не являющаяся допустимым идентификатором) и 
SIZE (символ). 

символьные свойства рассматриваются иначе и не отображаются стандартно. Обратите также внимание на то, что ключ для этого свойства - символ SIZE, а не
строка "SIZE". 
Проверим:
*/

objEx.SIZE = 0;
console.log(objEx[SIZE]);      //  8  
console.log(objEx.SIZE);       //  0
console.log(objEx["SIZE"]);    //  0

// мы изменяем объект, obj указывает на тот же объект все время, но сам объект изменяется. 

/*
 Свойства в фигурных скобках разделяются запятыми, а имена и значения - двоеточиями.
 */
const sam1 = {
    name: ' Sam',
    age: 4,
};
const sam2 = { name: ' Sam', age: 4 }; // объявление в одной строке

const sam3 = {
    name: ' Sam ',
    classification: {

        kingdom: ' Anamalia ',
        phylum: ' Chordata ',
        class: ' Mamalia ',
        order: ' Carnivoria ',
        family: ' Felidae ',
        subfaimily: ' Felinae ',
        genus: ' Felis ',
        species: ' catus',
    },
};
// значения свойств сами могут быть объектами 

/*
 Обратите внимание, что объекты saml и sam2 содержат те
же свойства, но это два разных объекта (еще одно отличие от базовых типов: две переменные, содержащие значение 3, относятся к одному и тому же типу).
*/

let a = 3;
let b = 3;
console.log(a === b);  // true
console.log(sam1 == sam2);  // false

/*
различные способы доступа к семейству кота Сэма (здесь также не имеет значения, используем ли мы одиночные, двойные кавычки или обратные апострофы).
*/
console.log(sam3.classification.family); // "Felidae"
console.log(sam3["classification"].family); // "Felidae"
console.log(sam3.classification["family"]); // "Felidae"
console.log(sam3["classification"]["family"]); // "Felidae"

/*
Объекты могут также содержать функции (function). 
 функция содержит код (по существу, это подпрограмма).
  Вот как мы добавляем функцию в samЗ.
*/

sam3.speak = function () { return "Meow!"; };

/*
Теперь мы можем вызвать эту функцию, добавив к ней круглые скобки.
*/
console.log(sam3.speak());  // Meow!


/*
И наконец оператором delete мы можем удалить свойство из объекта.
*/

delete sam3.classification; // все дерево classification удалено

/*
Объекты Number, String и Boolean

числа, строки и логические значения имеют соответствующие типы объектов (NumЬer, String и Boolean). Эти объекты служат двум целям: 
1. хранить специальные значения (такие, как NumЬer.INFINITY) и 
2. обеспечивать функциональные возможности в форме функции. Рассмотрим следующий код.
*/

const s = "hello";
const str = s.toUpperCase();
console.log(s);  // hello
console.log(str);  // HELLO

/*
В этом примере создается впечатление, что s - это объект (мы обратились к функциональному свойству, как будто оно есть). Но нам известно, что s - это базовый строковый тип. Так как же это произошло? Для этого JavaScript создает временный объект String (у которого есть функция toUpperCase, кроме других прочих). По завершении вызова функции JavaScript удаляет объект. Для доказательства
давайте попробуем присвоить свойство строке.
*/
// const s = "hello";
s.rating = 3;  // ошибки нет . . . удача ?
console.log(s.rating);  // undefined
// 1.rating = 15;   // SyntaxError: Invalid or unexpected token - для чисел сложнее

/*
JavaScript позволяет сделать это, создавая впечатление, что мы присваиваем свойство строке s. На самом деле свойство присваивается временному объекту String,
который для этого и создается. Сразу после этого временный объект удаляется, поэтому результатом s.rating будет undefined.
Хотя такое поведение JavaScript применяется редко (если вообще применяется), о нем следует знать. 
*/

/*
еще одним примером объекта является функция.

Функция (function) - это самодостаточный набор операторов, выполняющийся
как единый блок; по существу, можно считать ее подпрограммой. 
Функции - это основа мощи и выразительности языка JavaScript. 
У каждой функции есть тело (body) - набор составляющих функцию операторов.
*/
function sayHello() {
    // это тело; оно начинается с открывающей фигурной скобки ...
    console.log("Hello world ! ");
    console.log("! Hola mundo ! ");
    console.log("Hallo wereld ! ");
    console.log("Пpивeт мир!");
    // . . . и завершается закрывающей фигурной скобкой
}
/* 
Это пример объявления функции по имени sayHello. Само по себе объявление
функции не выполняет ее тело: если вы попытаетесь запустить этот пример, то не
увидите на консоли сообщения "Hello world !" на нескольких языках. 

Для вызова функции (называемого также выполнением или запуском) вы должны использовать
имя функции, сопровождаемое круглыми скобками:
*/
sayHello(); // "Hell o, World! " выводится на консоль на разных языках
/*
Термины вызов (call), выполнение (ехесиtе) и запуск (rип) являются синонимами,
*/

/*
Вызов функции - это выражение, а как известно, выражения , в отличие от операторов, возвращают значения. Так что возвращает вызов функции? 
Возвращаемое значение (return value). Ключевое слово return в теле функции немедленно завершает ее выполнение и возвращает определенное значение, которое и является результатом вызова функции. Давайте изменим наш пример: вместо вывода на консоль просто возвратим приветствие.
*/

function getGreeting() {
    return "***Hello world***! ";
}
/*
Теперь, когда происходит вызов, функция создает возвращаемое значение.
*/
console.log(getGreeting()); // "Hello, World! "
/*
Без явного оператора return возвращаемое значение будет undefined. Функция
может возвратить значение любого типа; в качестве упражнения попробуйте создать
функцию getGreetings, возвращающую массив, содержащий строки "Hello, World"
на разных языках. 

Вызов и обращение к функции******************************************************************

Функции в JavaScript являются объектами и могут быть переданы и присвоены
подобно любым другим объектам. Важно понимать различие между 
вызовом ( calling) функции и 
просто обращением (referencing) к ней. 
Когда за идентификатором функции следуют круглые скобки, JavaScript знает, что осуществляется вызов: выполняется тело функции и выражение возвращает значение. 
Без круглых скобок вы просто обращаетесь к функции, как к любому другому значению, а это не вызов. Опробуйте
следующее на консоли JavaScript.
*/

console.log(getGreeting());  // ***Hello world***!
console.log(getGreeting);  // [Function: getGreeting]
/*
 
Возможность обращения к функции, как к любому другому значению (не вызывая ее), обеспечивает большую гибкость языка. Например, вы можете присвоить функцию переменной, что позволит вызвать функцию под другим именем.
*/

const f = getGreeting;
console.log(f()); //  "Hello, World!" 
// Или можете присвоить функцию свойству объекта.
const o = {};
o.f = getGreeting;
console.log(o.f()); // "***Hello, World***! "
// Или даже добавить функцию в массив. 

const arr = [1, 2, 3];
arr[1] = getGreeting; // arr теперь [1 , function getGreeting () , 2]
arr[1](); // "Hello, World! "
console.log(arr[1]);  // [Function: getGreeting]
console.log(arr[1]());  // ***Hello world***! 

/*
Этот последний пример проясняет роль круглых скобок: если JavaScript встречает круглые скобки, которые следуют за значением, значение считается функцией и эту функцию следует вызвать. В приведенном примере arr [ 1] является выражением, которое возвращает значение. Данное значение, сопровождаемое круглыми скобками,
является сигналом JavaScript о том, что это значение - функция и ее следует вызвать.
Если вы попытаетесь добавить круглые скобки к значению, не являющемуся функцией, то вы получите ошибку. Например, "whoops" ()
приведет к сообщению об ошибке TypeError : "whoops " is not а
function. 
*/

// s();  // TypeError: s is not a function

/*
Ключевое слово this****************************************************************************************************

В теле функции доступна предназначенная только для чтения специальная переменная this. 
Это ключевое слово обычно ассоциируется с объектно-ориентированным программированием, и мы узнаем больше о его использовании.
В JavaScript, однако, оно используется несколькими способами.

Обычно ключевое слово this имеет отношение к функциям, являющимся свойствами объектов. 
При вызове метода переменной this присваивается значение конкретного объекта, в котором произошел вызов.
*/
const oTom = {
    name: 'Tom',
    speak() { return `Меня зовут ${this.name}!`; },
}

/*
Когда происходит вызов oTom.speak ( ) , переменная this будет связана с объектом оTom.
*/

console.log(oTom.speak()); // Меня зовут Tom!

/*
Важно понимать, что this связывается согласно тому, как функция вызвана, а не где объявлена. Таким образом, this связана с oTom не потому, что speak - это свойство
oTom, а потому, что мы вызвали этот метод непосредственно из oTom (oTom.speak). Давайте
рассмотрим, что будет, если мы присвоим ту же функцию переменной.
*/
const speak = oTom.speak;
console.log(speak === oTom.speak); // true; обе переменные обращаются к той же функции
console.log(speak()); // "Меня зовут undefined! "

/*
В связи с другим способом вызова функции движок JavaScript не знает, что функция была первоначально объявлена в oTom; таким образом, переменной this было присвоено значение undefined. 

Когда вы вызываете функцию таким способом, при котором привязка переменной this не очевидна (как при вызове метода speak ранее),
становится довольно сложно предсказать ее значение. Все зависит от того, находитесь ли вы в строгом режиме, и от места, из которого функция вызывается. Мы преднамеренно не рассматриваем эти подробности, поскольку таких ситуаций лучше избегать. 
Чтобы узнать больше, обратитесь к теме Code formatting (форматирование кода) в документации MDN.

Термин метод (method) традиционно ассоциируется с объектно-ориентированным программированием, и  мы будем использовать его для обозначения функции, которая является свойством объекта и предназначена для вызова
непосредственно из экземпляра объекта (например, oTom.speak () ). 
Если в функции не используется переменная this, то мы все равно будем называть ее функцией независимо от того, где она объявлена.
Одна из особенностей переменной this зачастую сбивает с толку, когда необходимо получить доступ к ней во вложенной функции. Рассмотрим следующий пример, в котором мы используем в методе вспомогательную функцию.
*/


// const oJohn = {
//     name: "John",
//     greetBackwards: function() {
//         function getReverseName() {
//             let nameBackwards = '';
//             for(let i=this.name.length-1; i >= 0; i--) {
//                 nameBackwards += this.name[i];
//             }
//             return nameBackwards;
//         }
//         return `${getReverseName()} si eman ym ,olleH`;
//     },
// };

// oJohn.greetBackwards();

// TypeError: Cannot read properties of undefined (reading 'length')
/*
Здесь мы используем вложенную функцию, getReverseName, для изменения имени на обратное. К сожалению, getReverseName не будет работать так, как ожидалось: при вызове oJohn.greetBackwards () JavaScript привязывает переменную this, как и ожидалось к объекту oJohn. 
Но когда происходит вызов getReverseName внутри функции greetBackwards, переменная this связывается с чем-то друrим. Обычно решение этой проблемы подразумевает применение второй переменной, которой присваивается значение this.
*/

const oJonny = {
    name: "Jonny",
    greetBackwards: function () {
        const self = this;
        function getReverseName() {
            let nameBackwards = "";
            for (let i = self.name.length - 1; i >= 0; i--) {
                nameBackwards += self.name[i];
            }
            return nameBackwards;
        }
        return `${getReverseName()} si eman ym ,olleH`;
    },
};

console.log(oJonny.greetBackwards());  // ynnoJ si eman ym ,olleH


/*
    Это общепринятая методика, и вы часто будете встречать присваивание значения
    переменной this константам self, или that. Стрелочные функции, являются еще одним средством решения этой проблемы. 

    У стрелочных функций действительно есть одно серьезное отличие от обычных  функций: 
    переменная this привязывается лексически, точно так же, как и любая другая переменная.  Со стрелочной
функцией мы можем использовать переменную this во внутренней функции. 
*/

const oJan = {
    name: "Jan",
    greetBackwards: function () {
        const getReverseName = () => {
            let nameBackwards = "";
            for (let i = this.name.length - 1; i >= 0; i--) {
                nameBackwards += this.name[i];
            }
            return nameBackwards;
        };
        return `${getReverseName()} si eman ym ,olleH`;
    },
};

console.log(oJan.greetBackwards());  // naJ si eman ym ,olleH

/*
У стрелочных функций есть еще два дополнительных отличия от обычных функций: они не могут использоваться как конструкторы объекта (см. главу 9) и в них недоступна специальная переменная arguments (в которой больше нет необходимости
благодаря оператору расширения). 
*/
/*

Методы call, apply и bind******************************

значение переменной this зависит от вызываемого контекста
(как и в других объектно-ориентированных языках). Но JavaScript позволяет определять, к чему привязана переменная this, независимо от того, как или где вызывается рассматриваемая функция. 

Давайте начнем с метода call, который доступен во всех
функциях. Он позволяет вызывать функцию с определенным значением this.
*/

const bruce = { name: "Bruce" };
const madeline = { name: "Madeline" };

// эта функция не связана ни с каким объектом,
// но все же в ней используется ' this ' !

function greet() {
    return `££££ Привет ! Меня зовут ${this.name} ! `;
}

console.log(greet());  //  Привет ! Меня зовут undefined ! - ' this ' не привязана
console.log(greet.call(bruce));  //  Привет ! Меня зовут Bruce ! - ' this ' привязана к 'madeline ' 

/*
Как можно заметить, метод call позволяет вызывать функцию, как будто это метод, предоставляемый объектом, к которому привязана переменная this. 
Первый аргумент метода call - это значение, к которому вы хотите привязать this, а все остальные аргументы становятся аргументами вызываемой функции.
*/

function update(birthYear, occupation) {
    this.birthYear = birthYear;
    this.occupation = occupation;
}

update.call(bruce, 1949, 'singer');
console.log(bruce);  // bruce теперь { name: "Bruce ", ЬirthYear: 1949, occupatioп : "siпger " }
update.call(madeline, 1942, ' actress ');
console.log(madeline);  // Madeliпe теперь { name : "Madeliпe", ЬirthYear: 1942, occupatioп : "actress " }

/*
Метод apply идентичен методу call, за исключением способа, которым он обрабатывает аргументы функции. Методу call аргументы передаются непосредственно, точно
так же, как и обычной функции. Метод apply аргументы передаются в виде массива.
*/

update.apply(bruce, [1955, " actor"]);
console.log(bruce);  // bruce теперь { name: 'Bruce', birthYear: 1955, occupation: ' actor' }

update.apply(madeline, [1918, "writer"]);
console.log(madeline); //  Madeliпe теперь { name: 'Madeline', birthYear: 1918, occupation: 'writer' }
/*
 
Метод apply полезен, если у вас есть массив и вы хотите использовать его значения как аргументы функции. 

Классический пример - поиск минимального или
максимального числа в массиве. Вспомогательным функциям Маth.min и Маth.mах
можно передать любое количество аргументов, а они возвращают минимальное или максимальное значение, соответственно. Мы можем использовать метод apply, чтобы вызвать эти функции с существующим массивом.
*/

const arrMath = [2, 3, -5, 15, 7];
console.log(Math.min.apply(null, arrMath));  // -5
console.log(Math.max.apply(null, arrMath));  // 15

/*
Обратите внимание, что вместо значения this мы просто передаем null. Так происходит потому, что в функциях Math.min и Math.max не используется переменная
this вообще; поэтому не имеет никакого значения, что мы передаем в качестве значения для this.


Оператор расширения ( ... ) ЕSб позволяет достичь того же результата, что и метод apply. В экземпляре нашего метода update, в котором значение this действительно важно, мы все еще должны использовать метод call, но для функций Math.min и Math.max, для которых оно не имеет значения, мы можем использовать оператор расширения, чтобы вызвать эти функции непосредственно.
*/

const newBruce = [1940, "martial artist "];
update.call(bruce, ...newBruce); // эквивалент apply (bruce, newBruce)
console.log(Math.min(...arrMath)); // -5
console.log(Math.max(...arrMath)); // 15
/*
Есть еще одна функция, Ьind, которая позволяет определить значение для переменной this. 
Функция Ьind позволяет перманентно ассоциировать значение
для this с функцией. Предположим, что мы распространяем свой метод update и хотим удостовериться, что в нем переменной this всегда будет присвоено значение bruce, независимо от того, как он будет вызван (даже с функцией call, apply или другой функцией bind). Функция bind позволяет сделать так.
*/
console.log("?????")
console.log(bruce);
const updateBruce = update.bind(bruce);
updateBruce(1904, " actor");
console.log(bruce); // { name: 'Bruce', birthYear: 1904, occupation: ' actor' }
console.log(updateBruce);  // [Function: bound update]

updateBruce.call(madeline, 1274, " king");
console.log(bruce);  // { name: 'Bruce', birthYear: 1274, occupation: ' king' }

/*
Тот факт, что действие функции bind является постоянным, делает ее потенциальным источником ошибок, которые трудно обнаружить: в результате вы получаете функцию, которую фактически нельзя использовать с функциями call, apply или bind (во второй раз). Представьте себе, что функция передается в виде параметра,  и она, будучи вызванной с помощью функций call или apply в некоем отдаленном месте, полностью уверена в правильной привязке this. Я не говорю вам, что Ьind не
нужно использовать, она весьма полезна, но помните о налагаемых ею ограничениях.
Вы можете также предоставить функции Ьind параметры, которые позволяют создать новую функцию, всегда вызываемую с определенными параметрами. Например, если необходима функция update, которая всегда устанавливает год рождения bruce равным 1949, но все еще позволяет изменять род занятия, вполне можете поступить следующим образом. 

*/

const updateBruce1949 = update.bind(bruce, 1949);
updateBruce1949("singer songwriter");
console.log(bruce);  // { name: 'Bruce', birthYear: 1949, occupation: 'singer songwriter' }
