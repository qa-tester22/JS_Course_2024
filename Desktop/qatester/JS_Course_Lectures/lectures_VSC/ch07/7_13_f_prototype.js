/*
F.prototype
Как мы помним, новые объекты могут быть созданы с помощью функции-конструктора new F().

Если в F.prototype содержится объект, оператор new устанавливает его в качестве [[Prototype]] для нового объекта.
-------------------------------------------------
На заметку:
JavaScript использовал прототипное наследование с момента своего появления. Это одна из основных особенностей языка.

Но раньше, в старые времена, прямого доступа к прототипу объекта не было. Надёжно работало только свойство "prototype" функции-конструктора, описанное в этом файле. Поэтому оно используется во многих скриптах.

-------------------------------------------------

Обратите внимание, что 
F.prototype означает обычное свойство с именем "prototype" для F. 
Это ещё не «прототип объекта», а обычное свойство F с таким именем.

Приведём пример:
*/


let animal = {
  eats: true
};

function Rabbit(name) {
  this.name = name;
}

Rabbit.prototype = animal;

let rabbit = new Rabbit("White Rabbit"); //  rabbit.__proto__ == animal

console.log( rabbit.eats ); // true

/*
Установка Rabbit.prototype = animal буквально говорит интерпретатору следующее: 
"При создании объекта через new Rabbit() запиши ему animal в [[Prototype]]".

Результат будет выглядеть так:
Rabbit --> prototype animal  
                        /|\
                         |  [[Prototype]]
                       rabbit

На изображении: "prototype" – горизонтальная стрелка, обозначающая обычное свойство для "F", а [[Prototype]] – вертикальная, обозначающая наследование rabbit от animal.

------------------------------------------------------
F.prototype используется только в момент вызова 
new F

F.prototype используется только при вызове new F и присваивается в качестве свойства [[Prototype]] нового объекта.

Если после создания свойство F.prototype изменится 
(F.prototype = <другой объект>), 
то новые объекты, созданные с помощью new F, будут иметь в качестве [[Prototype]] другой объект, 
а уже существующие объекты сохранят старый.
---------------------------------------------------------


F.prototype по умолчанию, свойство constructor***********

У каждой функции (за исключением стрелочных) по умолчанию уже есть свойство "prototype".

По умолчанию "prototype" – объект с единственным свойством constructor, которое ссылается на функцию-конструктор.

Вот такой:
*/

/*
function Rabbit() {}

// прототип по умолчанию
Rabbit.prototype = { constructor: Rabbit };
/

Проверим это:
*/

function Rabbit1() {}
// по умолчанию:
// Rabbit.prototype = { constructor: Rabbit }

console.log( Rabbit1.prototype.constructor == Rabbit1 ); // true

/*
Соответственно, если мы ничего не меняем, то свойство constructor будет доступно всем кроликам через [[Prototype]]:

function Rabbit1() {}
// по умолчанию:
// Rabbit1.prototype = { constructor: Rabbit1 }
*/

let rabbit1 = new Rabbit1(); // наследует от {constructor: Rabbit}

console.log(rabbit1.constructor == Rabbit1); // true (свойство получено из прототипа)
/*

Мы можем использовать свойство constructor существующего объекта для создания нового.

Пример:
*/


function Rabbit2(name) {
  this.name = name;
  console.log(name);
}

let rabbit2 = new Rabbit2("White Rabbit");

let rabbit3 = new rabbit2.constructor("Black Rabbit");


rabbit2.name;
rabbit3.name;
/*
Это удобно, когда у нас есть объект, но мы не знаем, какой конструктор использовался для его создания (например, он мог быть взят из сторонней библиотеки), а нам необходимо создать ещё один такой объект.

Но, пожалуй, самое важное о свойстве "constructor" это то, что…

…JavaScript сам по себе не гарантирует правильное значение свойства "constructor".

Да, оно является свойством по умолчанию в "prototype" у функций, но что случится с ним позже – зависит только от нас.

В частности, если мы заменим прототип по умолчанию на другой объект, то свойства "constructor" в нём не будет.

Например:
*/

function Rabbit4() {}
Rabbit4.prototype = {
  jumps: true
};

let rabbit4 = new Rabbit4();

console.log(rabbit4.constructor === Rabbit4); // false

/*
Таким образом, чтобы сохранить верное свойство "constructor", мы должны добавлять/удалять/изменять свойства у прототипа по умолчанию вместо того, чтобы перезаписывать его целиком:
*/

function Rabbit5() {}

// Не перезаписываем Rabbit.prototype полностью,
// а добавляем к нему свойство

Rabbit5.prototype.jumps = true;

// Прототип по умолчанию сохраняется, и мы всё ещё имеем доступ к Rabbit.prototype.constructor
// Или мы можем заново создать свойство constructor:

function Rabbit7() {}
Rabbit7.prototype = {
  jumps: true,
  constructor: Rabbit7
};

let rabbit7 = new Rabbit7();
console.log(rabbit7.constructor === Rabbit7);  // true

/*
// теперь свойство constructor снова корректное, так как мы добавили его


Итого***************************************************

мы кратко описали способ задания [[Prototype]] для объектов, создаваемых с помощью функции-конструктора. Позже мы рассмотрим, как можно использовать эту возможность.

Всё достаточно просто. Выделим основные моменты:

- Свойство F.prototype (не путать с [[Prototype]]) устанавливает[[Prototype]] для новых объектов при вызове new F().

- Значение F.prototype должно быть либо объектом, либо null. Другие значения не будут работать.

- Свойство "prototype" является особым, только когда оно назначено функции-конструктору, которая вызывается оператором new.

В обычных объектах prototype не является чем-то особенным:
*/

let user77 = {
  name: "John",
  prototype: "Bla-bla" // никакой магии нет - обычное свойство
};
console.log(`***********`)
console.log(Object.getPrototypeOf(user77) == Object.prototype)  // true
console.log(Object.keys(user77));  // [ 'name', 'prototype' ]

console.log(Object.keys(rabbit4));  // []
/*
По умолчанию все функции имеют F.prototype = { constructor: F }, поэтому мы можем получить конструктор объекта через свойство "constructor".
*/

/*
Встроенные прототипы

Object
Array
Date
Function

String
Numcber
Boolean

Только у значений undefined и null нет объектов-обёрток.

Методы прототипов, объекты без свойства __proto__

Свойство __proto__ считается устаревшим, и по стандарту оно должно поддерживаться только браузерами.

Современные же методы это:

Object.create(proto[, descriptors]) – создаёт пустой объект со свойством [[Prototype]], указанным как proto, и необязательными дескрипторами свойств descriptors.

Object.getPrototypeOf(obj) – возвращает свойство [[Prototype]] объекта obj.

Object.setPrototypeOf(obj, proto) – устанавливает свойство [[Prototype]] объекта obj как proto.

Эти методы нужно использовать вместо __proto__.

Ещё методы:

Object.keys(obj) / Object.values(obj) / Object.entries(obj) – возвращают массив всех перечисляемых собственных строковых ключей/значений/пар ключ-значение.

Object.getOwnPropertySymbols(obj) – возвращает массив всех собственных символьных ключей.

Object.getOwnPropertyNames(obj) – возвращает массив всех собственных строковых ключей.

Reflect.ownKeys(obj) – возвращает массив всех собственных ключей.

obj.hasOwnProperty(key): возвращает true, если у obj есть собственное (не унаследованное) свойство с именем key.

Все методы, которые возвращают свойства объектов (такие как Object.keys и другие), возвращают «собственные» свойства. Если мы хотим получить и унаследованные, можно воспользоваться циклом for..in.
*/