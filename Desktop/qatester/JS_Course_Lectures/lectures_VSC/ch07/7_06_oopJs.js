/*
OOP **************************************************
объекты в JavaScript - это контейнеры, которые называют агрегатными или комплексными типами данных.

Свойство  (property) объекта  состоит из ключа (key) (строки или символа) и значения (value). Особенными объекты делает то, что вы можете обращаться к свойствам по их ключам. 

Перебор свойств****************************************

Обычно, если нужно вывести содержимое некоторого контейнера (операция перебора), чаще всего используется массив, а не объект.
 Тем не менее объекты также являются контейнерами, и они обеспечивают перебор свойств; вам только нужно
знать об особенностях и возможных сложностях.
Первое, что необходимо помнить о переборе свойств, - это то, что порядок не гарантируется. 

Проведя небольшой эксперимент, вы можете обнаружить, что
свойства выводятся в том порядке, в котором они добавляются, и это справедливо для многих реализаций движка почти всегда. Тем не менее JavaScript не дает
никаких гарантий этому, и изменение реализации движка в любой момент может ликвидировать этот эффект. Поэтому не стоит полагаться на результат эксперимента и никогда не стоит подразумевать, что порядок свойств будет именно таков.

Будучи предупрежденными об этом, давайте теперь рассмотрим основные способы перебора свойств объекта.


Цикп for ... in****************************************

Традиционным способом перебора свойств объекта является цикл for ... in. 
Рассмотрим объект, у которого есть несколько строковых свойств и одно символьное свойство.
*/

const SYM = Symbol();

const objSym = {
    a: 1,
    b: 2,
    c: 3,
    [SYM]: 4
};

for (let prop in objSym) {
    if (!objSym.hasOwnProperty(prop)) continue;
    console.log(`* ${prop} : ${objSym[prop]}`);
}



/*
вывел: 
* a : 1
* b : 2
* c : 3

Все кажется довольно простым ... кроме, вероятно, вполне резонного вопроса "Что делает hasOwnProperty?" 

Он ликвидирует опасность, связанную с циклом
for ... in, которая станет ясна далее. 

Речь идет об унаследованных свойствах. В данном примере мы это могли бы опустить и не придать значения. Но, перебирая свойства объектов других типов (особенно объектов, производных от других),
вы можете обнаружить свойства, которых не ожидали. Поэтому рекомендую выработать привычку использовать для проверки метод hasOwnProperty. Вы скоро узнаете, почему это так важно, а также научитесь определять, когда его можно безболезненно (или желательно) опустить.
Что если не использовать hasOwnProperty?
*/

for (let prop in objSym) {
    if (!objSym[prop]) constinue;
    console.log(`** ${prop} : ${objSym[prop]}`);
}
/*
Вывел:
** a : 1
** b : 2
** c : 3

Обратите внимание, что цикл for ... in не выводит значения свойств с символьными ключами.

Несмотря на то что с помощью цикла for ... in можно выполнить перебор элементов массива, обычно это считается плохой идеей. Для массивов я рекомендую использовать обычный цикл for или forEach.


Метод Object.keys**************************************

Метод Object.keys позволяет получить все перечислимые строковые свойства объекта в виде массива.
*/

const SYMBA = Symbol();

const oSymba = {
    a: 1,
    b: 2,
    c: 3,
    [SYMBA]: 4
};

Object.keys(oSymba).forEach(prop => console.log(`*** ${prop} : ${oSymba[prop]}`));


/*
вывел:
*** a : 1
*** b : 2
*** c : 3

Этот пример приводит к тому же результату, что и цикл for ... in (здесь даже не нужно выполнять проверку с помощью метода hasOwnProperty). Это весьма удобно,
когда нужно собрать ключи свойств объекта в виде массива. Например, это облегчает вывод всех свойств объекта, которые начинаются с символа х.
*/



const oX = { apple: 1, xochitl: 2, balloon: 3, guitar: 4, xylophone: 5, };

Object.keys(oX)
    .filter(prop => prop.match(/^x/))
    .forEach(prop => console.log(`${prop} : ${oX[prop]}`));


/*

xochitl : 2
xylophone : 5

Объектно-ориентированное программирование***************
Объектно-ориентированное программирование (ООП, Object-Oriented Programming) - старая добрая парадигма в информатике. 
Некоторые из концепций, которые мы теперь знаем как ООП, появились еще в 1950-х годах, но только после появления языков программирования Simula 67 и Smalltalk они обрели форму ООП.
Фундаментальная идея проста и интуитивно понятна: объект - это логически связанная коллекция данных и функций. Она призвана отразить наше понимание естественного мира. 

Автомобиль - это объект, у которого есть данные (марка, модель, количество дверей, идентификатор транспортного средства (VIN) и т.д.), а также функции (ускорение, переключение передач, открывание дверей, включение фар и т.д.). 
Кроме того, ООП позволяет думать о вещах абстрактно (автомобиль) и конкретно (определенный автомобиль).

Прежде чем продолжать, давайте рассмотрим базовую лексику ООП. 

Термин класс
(class) описывает обобщенную сущность (автомобиль), а экземпляр (instance) (или экземпляр объекта (object instance)) - определенную сущность (конкретный автомобиль, такой как "мой автомобиль"). 

Одна часть функций (ускорение) является методами (method). 
Другая часть функций, связанных с классом, но не относящихся к конкретному экземпляру, является методами класса (например, "создание нового VIN" могло бы быть методом класса: это не имеет отношения к конкретному новому автомобилю и, конечно, мы не ожидаем, что у конкретного автомобиля будет возможность или способность создать новый, законный VIN). Когда экземпляр создается, выполняется его конструктор (constructor). 

Конструктор инициализирует экземпляр объекта.
ООП предоставляет нам также среду для иерархической категоризации классов. Например, мог бы существовать более общий класс транспортного средства.

У транспортного средства может быть характеристика дальности (дистанция, которую он может пойти без дозаправки или перезарядки), но в отличие от автомобиля у него может не быть колес (например, у такого транспортного средства, как лодка, очевидно нет колес). Мы говорим, что 
транспортное средство - это суперкласс (superclass) автомобиля, а автомобиль - это производный класс (subclass) транспортного средства. 
У класса транспортного средства может быть несколько производных классов: автомобили, лодки, планеры, мотоциклы, велосипеды и т.д. У производных классов, в свою очередь, могут быть следующие производные классы.
Например, у производного класса лодки могут быть дальнейшие производные классы парусной яхты, гребной шлюпки, каноэ, буксира, моторной лодки и т.д.

мы будем использовать пример автомобиля, поскольку это реальный объект, с которым все мы, очевидно связаны.

Создание класса и экземпляра************************************************************************************************

До ЕSб создание классов в JavaScript было суетным и не интуитивно понятным делом. Теперь появился новый удобный синтаксис создания классов.
*/

class Car1 {
    constructor() {

    }
}


/*
Это создает новый класс по имени Car. Никаких его экземпляров (конкретных автомобилей) еще не создано, но теперь есть возможность сделать это. Чтобы создать конкретный автомобиль, мы используем ключевое слово new.
*/

const car1 = new Car1();
const car2 = new Car1();

/*
Теперь у нас есть два экземпляра класса Car. Прежде чем сделать класс Car более сложным, давайте рассмотрим оператор instanceof, который может сказать вам, является ли данный объект экземпляром данного класса.
*/

console.log(car1 instanceof Car1);  // true
console.log(car1 instanceof Array); // false
console.log(car1 instanceof Object);  // true


/*
Из этого видно, что carl - экземпляр класса Car1, а Array - нет.
Давайте сделаем класс Car немного интереснее. Придадим ему некие данные (марка, модель) и некие функции (переключение передач).
*/

class Car {
    constructor(make, model) {
        this.make = make;
        this.model = model;
        this.userGears = ["P", "N", "R", "D"];
        this.userGear = this.userGears[0];
    }

    shift(gear) {
        if (this.userGears.indexOf(gear) < 0)
            throw new Error(`Ошибочная передача: ${gear}`);
        this.userGear = gear;
    }
}


/*
Здесь ключевое слово this используется по прямому назначению: для обращения к экземпляру, метод которого был вызван. Вы можете считать его знакоместом:

когда вы пишете свой класс, вероятно, абстрактный, ключевое слово this является знакоместом для конкретного экземпляра, который будет известен на момент вызова метода. 
Этот конструктор позволяет задать марку и модель автомобиля при его создании, а также установить некоторые стандартные значения: допустимые передачи (userGears) и текущую передачу (gear), которую мы инициализируем значением первой допустимой передачи. 

(Я решил назвать это пользовательскими передачами
(user gears) потому, что если этот автомобиль оснащен автоматической коробкой передач, то, когда автомобиль будет находиться в движении, фактически использующаяся передача может отличаться от включенной пользователем.) Кроме конструктора (который вызывается неявно при создании нового объекта), мы также создали метод shift, позволяющий переключать передачу. Давайте рассмотрим это в действии.
*/

const car3 = new Car("Tesla", "Model S");
const car4 = new Car("Mazda", "3i");

car3.shift("D");
car4.shift("R");


/*
В этом примере, когда мы вызываем car3.shift ( 'D' ), переменная this связана с car3. 
Точно так же при вызове car4.shift ( 'R' ) она связана с car4. Мы можем убедиться, что car3 находится в движении на передаче D (drive), а car4 сдает назад на передаче R (reverse).
*/

console.log(car3.userGear);  // D
console.log(car4.userGear);  // R

/*
Динамические свойства*******************************
То, что метод shift нашего класса Car предотвращает выбор недопустимой передачи по небрежности, может казаться очень умным ходом. 
Но эта защита ограничена, поскольку нет ничего, что помешало бы установить значение непосредственно: 
*/

// car3.userGear = 'X';

// console.log(car3.userGear);  // X - несуществующая передача, присвоили в обход метода shift

// car4.shift("X");

// console.log(car4.userGear);  // Error: Ошибочная передача: X

/*
Большинство объектно-ориентированных языков идет на большие затраты, чтобы предоставить механизмы защиты от этого вида неправильного обращения, разрешая вам определять уровень доступа к методам и свойствам. 
В JavaScript такого механизма нет, за что его нередко и критикуют.

Динамические свойства способны несколько сгладить этот недостаток. Они обладают семантикой свойств с функциональными возможностями методов. 

Давайте изменим наш класс Car так, чтобы использовать это в своих интересах.
*/

class Car2 {
    constructor(make, model) {
        this.make = make;
        this.model = model;
        this._userGears = ["P", "N", "R", "D"];
        this._userGear = this._userGears[0];
    }

    get userGear() { return this._userGear; }
    set userGear(value) {
        if (this._userGears.indexOf(value) < 0)
            throw new Error(`Ошибочная передача: ${value}`);
        this._userGear = value;
    }

    shift(gear) { this.userGear = gear; }
}

const car5 = new Car2();

car5.shift("N");  // ReferenceError: shift is not defined

console.log(car5._userGear);  // N

// если установим не существующую передачу W

// car5.shift("W");

// console.log(car5._userGear);  // Error: Ошибочная передача: W

// но мы можем присвоить напрямую значение L

car5._userGear = "L";

console.log(car5._userGear);  // L - не существующая передача

/*
мы не устранили проблему, поскольку значение _ userGear все еще можно установить непосредственно: 


car5. _ userGear = 'X';


В этом примере мы используем "ограничение доступа для бедных" - свойства,
имена которых начинаются с символа подчеркивания, мы считаем закрытыми. 
Эта защита сугубо в соглашении, позволяющем быстро просмотреть код и выявить свойства, к которыми вы не должны обращаться непосредственно.
Если вы действительно должны обеспечить конфиденциальность, то можете использовать экземпляр WeakMap, который защищен областью видимости (если мы не будем использовать WeakMap, то наши закрытые свойства никогда не будут выходить из области видимости, даже если экземпляры, к которым они относятся, выйдут). Чтобы сделать основное текущее свойство передачи действительно
закрытым, мы можем изменить свой класс Car так.
*/

const Car7 = (function () {
    const carProps = new WeakMap();

    class Car7 {
        constructor(make, model) {
            this.make = make;
            this.model = model;
            this._userGears = ["P", "N", "R", "D"];
            carProps.set(this, { userGear: this._userGears[0] });
        }

        get userGear() { return carProps.get(this).userGear; }

        set userGear(value) {
            if (this._userGears.indexOf(value) < 0)
                throw new Error(`Ошибочная передача: ${value}`);
            carProps.get(this).userGear = value;
        }

        shift(gear) { this.userGear = gear; }
    }

    return Car7
})()

const car10 = new Car7;

// car10.shift("O");

// console.log(car10._userGear);  // Error: Ошибочная передача: O

// присвоим напрямую неправильное значение передачи "F"

// car10._userGear = "N";

// console.log(car10_userGear);  // ReferenceError: car10_userGear is not defined

car10.userGear = "N"

console.log(car10._userGear);  // undefined

console.log(car10.userGear);  // N


// car10.userGear = "F"; // Error: Ошибочная передача: F

// console.log(car10._userGear);  // Error: Ошибочная передача: F

// console.log(car10.userGear);  // 

car10.shift("D");
console.log(car10.userGear);  // D

// car10.shift("F");  // Error: Ошибочная передача: F


/*
Проблема здесь связана с тем, что вы пытаетесь обратиться к `_userGear` напрямую из экземпляра класса, используя `_userGear`, однако это значение хранится в WeakMap и не может быть прочитано напрямую таким образом.

WeakMap используется для сохранения приватных данных для объекта. Ваш класс `Car7` использует WeakMap `carProps`, чтобы хранить `userGear` как приватное свойство. Обратный доступ к нему через экземпляр класса напрямую невозможен. 

Вместо этого, вы можете использовать геттер и сеттер `userGear`, который обращается к WeakMap для получения и установки значения `userGear`. Это обеспечит безопасность доступа к приватному свойству:


console.log(car10.userGear); // Выведет: P
car10.userGear = "N";
console.log(car10.userGear); // Выведет: N


Таким образом, весь доступ к приватному свойству `userGear` должен осуществляться через геттер и сеттер `userGear`, а не напрямую к `_userGear`.
*/
/*
Чтобы поместить наш WeakMap в замкнутое выражение, к которому нельзя обратиться извне, мы используем немедленно вызываемое функциональное выражение. Теперь WeakМap может безопасно хранить любые свойства, к которым
мы не хотим обращаться за пределами класса.
Существует и другой способ, который подразумевает использование символов для имен свойств; они также предоставляют некоторую защиту от случайного использования, но к символьным свойствам класса также можно обратиться, а значит, даже эту защиту можно обойти.

Классы как функции *************************************
До введения в ЕSб ключевого слова class для создания класса приходилось создавать функцию, которая служила бы конструктором класса. Хотя синтаксис class намного более интуитивно понятен и прост, внутренний характер классов в JavaScript не изменился (ключевое слово class лишь обеспечивает немного более удобный синтаксис), поэтому важно понимать, что именно представляет собой класс в JavaScript.

В действительности класс - это только функция. В ES5 мы начали бы свой класс
Car так.
*/

function Car11(make, model) {
    this.make = make;
    this.model = model;
    this._userGears = ["P", "N", "R", "D"];
    this._userGear = this.userGears[0];
}

/*
Мы все еще можем сделать это и в ЕSб - результат будет тот же (до методов мы дойдем ниже). Мы можем проверить это, опробовав оба пути.
*/

console.log(typeof Car7);  // function
console.log(typeof Car11);  // function

/*
Таким образом, ничего действительно нового в ЕSб нет; у нас есть только некий новый удобный синтаксис.

Прототип**********************************************
Когда говорят о методах, доступных в экземплярах класса, имеют в виду прототип (prototype) методов. Например, упоминая метод shift, доступный в экземплярах класса Car, вы имеете в виду прототип метода и зачастую можете встретить синтаксис Car.prototype.shift. 
*/

Car7.prototype.shift;
console.log(Car7.prototype.shift);  // [Function: shift]
/*
(Точно так же функция forEach класса Array может выглядеть как Array.prototype.forEach.) 
*/

const arrayFor = [1, 2, 3, 4, 5];

Array.prototype.forEach.call(arrayFor, function (el, index, array) { console.log(el); });

/*
вывел:
1
2
3
4
5
Это эквивалентно использованию `arr.forEach()`, но предоставляет более явное указание на то, что `forEach` вызывается через прототип `Array`.
*/
arrayFor.forEach(function (el) { console.log(el) });

/*
вывел:
1
2
3
4
5
Теперь пришло время фактически узнать, что такое прототип и как JavaScript осуществляет динамический вызов ( dynamic
dispatch), используя цепь прототипов (prototype chain). 

Использование знака диеза ( #) стало популярным соглашением для описания прототипов методов. 
Например, вы будете часто встречать Car.prototype.shift, записанный просто как Car#shift.
*/

Car7.prototype.shift
// Car7#shift



/*
Каждая функция имеет специальное свойство prototype. (Вы можете изменить его для любой функции f, введя на консоли f.prototype.)

Для обычных функций прототип не используется, но он критически важен для функций, которые действуют
как конструкторы объектов.
В соответствии с соглашением имена конструкторов объектов (иначе - классов) всегда начинаются с заглавной буквы, например Car.
Это соглашение - не догма, но многие анализаторы предупредят вас,
если вы попытаетесь называть функцию с заглавной буквы или конструктор объекта - со строчной.

Свойство функции prototype становится важным, когда вы создаете новый экземпляр с использованием ключевого слова new: вновь созданный объект имеет доступ к свойству prototуре его конструктора. 

Экземпляр объекта хранит его в своем
свойстве _proto _

Свойство proto считается внутренней частью JavaScгipt, как
и любое свойство, заключенное между двойными символами подчеркивания. Используя эти свойства, можно сделать очень, очень много вреда. Иногда их можно использовать очень хитро и правильно, но
пока у вас нет полного понимания JavaScript, я настоятельно рекомендую только просматривать (но не изменять) эти свойства.

В прототипе важнее всего механизм динамического вызова (термин "dispatch" - это синоним вызова метода). Когда вы пытаетесь получить доступ к свойству или
методу объекта, если его не существует, JavaScript проверяет прототип объекта,
чтобы убедиться, есть ли он там. 
Поскольку все экземпляры данного класса совместно используют один и тот же прототип, к свойству или методу, имеющемуся в прототипе, есть доступ для всех экземпляров этого класса.
Присвоение значения свойствам данных в прототипе класса обычно не выполняется. 
Дело в том что тогда значение этого свойства будет доступно для всех экземпляров класса. Однако если значение свойства устанавливается в каком -нибудь экземпляре, оно устанавливается именно в этом экземпляре, а не в прототипе, чтобы избежать путаницы и ошибок. 
Если экземпляры должны иметь начальные значения
свойств данных, то лучше устанавливать их в конструкторе.
Обратите внимание, что определение метода или свойства в экземпляре переопределяет версию в прототипе; помните, что JavaScript сначала проверяет экземпляр,
а только затем - прототип. Давайте рассмотрим все это на примере. 
11 определенный ранее класс Car с методом shift
*/
car12 = new Car7();
car12.shift("R");
car10.shift === Car7.prototype.shift;
console.log(car10.shift === Car7.prototype.shift);  // true
car12.shift("D");
// car12.shift("d");   // Error: Ошибочная передача: d
car10.shift === car12.shift
console.log(car10.shift === car12.shift);  // true

car10.shift = function (gear) { this.userGear = gear.toUpperCase(); }  // изменили shift у car10

console.log(car10.shift === Car7.prototype.shift);  // false

console.log(car10.shift === car12.shift);  // false

car10.shift("d");
console.log(car10.userGear);     // D

// car12.shift("n");
// console.log(car12.userGear);   //  Error: Ошибочная передача: n


/*
В этом примере ясно показано, как JavaScript осуществляет динамический вызов.
Первоначально у объекта car12 нет метода shift, но при вызове car12.shift ( 'D' )
JavaScript просматривает прототип для car12 и находит метод с таким именем. Когда мы заменяем метод shift собственной версией, то у объекта car12 и у его прототипа
появляется метод с этим именем. Однако при вызове 
car10.shift( 'd' ) , будет вызван
метод объекта car10, а не его прототипа.
Обычно в знании механики цепи прототипов и динамического вызова у вас не будет особой нужды, но все же может встретиться проблема, которая потребует их
глубокого понимания. 

Поэтому, прежде чем продолжать, имеет смысл узнать детали.


Статические методы*************************************

Методы, которые мы рассматривали до сих пор, являлись методами экземпляра
(instance method). 
Они предназначены для работы с конкретным экземпляром. Есть также статические методы 
(static method) (или методы класса 
    (class method)), которые не относятся ни к какому конкретному экземпляру. 

В статическом методе переменная this привязана к самому классу, но в этом случае вместо нее рекомендуется
использовать имя класса.
Статические методы используются для выполнения обобщенных задач, которые связаны с классом, а не с любым конкретным экземпляром. 

Давайте рассмотрим пример использования VIN автомобиля (идентификатор транспортного средства).
Нет смысла позволять индивидуальному автомобилю создавать собственный VIN:
что помешало бы автомобилю использовать такой же VIN, как и у другого автомобиля? Однако присвоение VIN является абстрактной концепцией, которая связана с идеей автомобиля вообще; следовательно, это кандидат в статические методы.

Кроме того, статические методы зачастую используются для работы с несколькими транспортными средствами (объектами). 
Например, нам может понадобиться метод
areSimilar, который возвращает true, если у двух автомобилей те же марка и модель, а метод areSame, возвращающий true, если у двух автомобилей один и тот же
VIN. 
Давайте рассмотрим эти статические методы, реализованные для класса Car7.
*/

class Car20 {
    static getNextVin() {
        return Car20.nextVin++; // мы могли бы также использовать this . nextVin++, но обращение к Car20 подчеркивает, что это статический метод
    }

    constructor(make, model) {
        this.make = make;
        this.model = model;
        this.vin = Car20.getNextVin();
    }

    static areSimilar(car1, car2) {
        return car1.make === car2.make && car1.model === car2.model;
    }

    static areSame(car1, car2) {
        return car1.vin === car2.vin;
    }
}

Car20.nextVin = 0;

const car20 = new Car20("Tesla", "S");
const car21 = new Car20("Mazda", "3");
const car22 = new Car20("Mazda", "3");

console.log(car20.vin);  //  0
console.log(car21.vin);  //  1
console.log(car22.vin);  //  2

console.log(Car20.areSimilar(car20, car21));  // false - не похожи 
console.log(Car20.areSimilar(car21, car22));  // true - похожи
console.log(Car20.areSame(car21, car22));  // false - не одно и то же
console.log(Car20.areSame(car22, car22));  //  true - одно и то же

/*
Наследование*********************************************

Рассматривая прототипы, мы уже встречали некий вид наследования: при создании экземпляра класса он наследовал все функции, находящиеся в прототипе класса.
Но на этом дело не заканчивается: если метод не найден в прототипе объекта, проверяется прототип прототипа. Так получается цепь прототипов. 
JavaScript будет идти по цепи прототипов, пока не найдет тот прототип, который удовлетворяет запросу.
Если такой прототип не будет найден, то все закончится ошибкой.
Это пригодится при создании иерархии классов. Мы уже упоминали, что 
автомобиль - это общий тип транспортного средства. Цепь прототипов позволяет располагать функции там, где им самое место. Например, у автомобиля мог бы быть

метод deployAirbags. Мы могли бы сделать его методом обобщенного транспортного средства, но вы когда-либо видели лодку с подушками безопасности? С другой
стороны, почти все транспортные средства могут перевозить пассажиров; таким образом, у транспортного средства мог бы быть 
метод addPassenger (который мог бы сообщать об ошибке, если количество пассажиров превышено). Давайте посмотрим,
как этот сценарий реализуется в коде JavaScript.
*/

class Vehicle {
    constructor() {
        this.passengers = [];
        console.log("Транспортное средство создано");
    }

    addPassenger(p) {
        this.passengers.push(p);
    }
}

class Car30 extends Vehicle {
    constructor() {
        super();
        console.log("Автомобиль создан");
    }

    deployAirbags() {
        console.log("БАБАХ!!!");
    }
}


/*
Первое нововведение, которое мы замечаем, - это ключевое слово extends; 
этот синтаксис указывает, что класс Car30 происходит от класса Vehicle. 
Второй новостью является вызов super ().

Это специальная функция JavaScript, которая вызывает конструктор суперкласса. Для производных классов это обязательно; если вы опустите
его, то получите ошибку.
Давайте рассмотрим этот пример в действии.
*/

const v = new Vehicle();
v.addPassenger("Dunya");
v.addPassenger("Mitrofan");

console.log(v.passengers);  // Транспортное средство создано  [ 'Dunya', 'Mitrofan' ]

const c = new Car30();
c.addPassenger("Alice");
c.addPassenger("Tom");
console.log(c.passengers);  // Транспортное средство создано Автомобиль создан  [ 'Alice', 'Tom' ]

// v.deployAirbags();  // TypeError: v.deployAirbags is not a function
c.deployAirbags();  // БАБАХ!!!
/*
Обратите внимание, что мы можем вызвать метод deployAirbags с с, но не с v.

Другими словами, наследование работает только в одном направлении. 
Экземпляры класса Car30 могут обращаться ко всем методам класса Vehicle, но не наоборот.


Полиморфизм**********************************************

Термин полиморфизм (polymorphism) из лексикона объектно-ориентированных
языков описывает ситуацию, когда экземпляр рассматривается как член не только его собственного класса, но и любых суперклассов. 

На многих объектно-ориентированных языках 
полиморфизм - это нечто особенное, приносящее большую пользу  ООП. 

Язык JavaScript не является типизированным, т.е. любой объект может быть использован в любом месте (хотя правильный результат не гарантирован). Таким образом, в некотором смысле у JavaScript есть абсолютный полиморфизм.

Код JavaScript, который вы пишете, довольно часто использует некую форму утиной типизации (duck typing). 

Эта методика исходит из выражения "Если это
выглядит, как утка, плавает, как утка и крякает, как утка, то это, возможно, и есть утка': 
В нашем примере с классом Car30, если у вас есть объект, обладающий методом deployAirbags, то вы могли бы резонно заключить, что это экземпляр класса Car30.

Это может быть правда, а может и нет, но попытка довольно хорошая.
В JavaScript предусмотрен 
оператор instanceof, который укажет вам, является ли
объект экземпляром данного класса. Как ни удивительно, но до тех пор, пока вы не оперируете напрямую свойствами prototype и _proto _, этот оператор будет возвращать правильный результат.
*/

class Motocycle extends Vehicle { }

const car33 = new Car30();
const moto = new Motocycle();

console.log(car33 instanceof Car30);   // true
console.log(car33 instanceof Vehicle);  // true
console.log(moto instanceof Car30);      // false
console.log(moto instanceof Motocycle);  // true
console.log(moto instanceof Vehicle);    // true

/*
Все объекты в JavaScript являются экземплярами корневого класса Object. 
Таким образом, для любого объекта 
"о" выражение 
"о" instanceof Object 
будет истинным (если только вы явно не установите значение его свойства _proto _, чего следует избегать). 

С практической точки зрения в этом есть небольшой смысл, поскольку такая возможность позволяет создать ряд важных методов для всех объектов иерархии. В качестве примера можно привести метод toString, который будет рассмотрен далее.


Перебор свойств объектов (снова}************************

Мы уже видели, как можно перебрать свойства объекта в цикле for ... in. 
Теперь, когда мы понимаем механизм наследования прототипов, мы можем полностью оценить использование 
метода hasOwnProperty при переборе свойств объекта. 

Для объекта obj и свойства х вызов obj.hasOwnProperty(х)возвратит true, если у obj будет свойство х, и false, если свойство х не определено или определено в цепи прототипов.

Если вы будете использовать классы ES6 так, как они задуманы, то свойства данных всегда будут определяться в экземплярах, а не в цепи прототипов. 

Однако, поскольку нет ничего, что предотвратило бы добавление свойств непосредственно в прототип, всегда лучше использовать hasOwnProperty, чтобы удостовериться
в этом. Рассмотрим пример.
*/

class Super {
    constructor() {
        this.name = "Super";
        this.isSuper = "true";
    }
}

// это допустимо, но не желательно...
Super.prototype.sneaky = "Не рекомендуется! ";

class Sub extends Super {
    constructor() {
        super();
        this.name = "Sub";
        this.isSub = true;
    }
}

const objEx = new Sub();

for (let p in objEx) {
    console.log(`${p} : ${objEx[p]}` +
        (objEx.hasOwnProperty(p) ? "" : " (унаследовано)"));
}

/*
Выведет:
name : Sub
isSuper : true
isSub : true
sneaky : Не рекомендуется! (унаследовано)


Свойства name, isSuper и isSub определяются в экземпляре, а не в цепи прототипов (обратите внимание, что свойства, объявленные в конструкторе супер класса,
присутствуют также в экземпляре производного класса). 

Свойство sneaky, напротив, было вручную добавлено в прототип суперкласса.
Вы можете избежать этой проблемы в целом, используя метод Object.keys, который включает только свойства, определенные в прототипе.
*/

console.log(Object.keys(objEx));  // [ 'name', 'isSuper', 'isSub' ]

console.log(Object.values(objEx));  // [ 'Sub', 'true', true ]


// как и раньше можно ключи вывести циклом forEach , пройдя по ключам

Object.keys(objEx).forEach(key => {
    console.log(`For keys: ${key} : ${objEx[key]}`);
});


// можем обойти по значениям объекта

Object.values(objEx).forEach((value, index) => {
    const key = Object.keys(objEx)[index];
    console.log(`For values: ${key} : ${value}`);
});

/*
Выведет:

For keys: name : Sub
For keys: isSuper : true
For keys: isSub : true
For values: name : Sub
For values: isSuper : true
For values: isSub : true


Строковое представление**********************************

Каждый объект в конечном счете происходит от класса Object. Таким образом, все методы, доступные в классе Object, стандартно доступны для всех объектов.

Одним из этих методов является toString, возвращающий стандартное строковое представление объекта. Стандартное поведение метода toString подразумевает возвращение строки 
" [ object Object ] ", что не особенно полезно.

Наличие метода toString, выводящего нечто описательное об объекте, может очень пригодиться при отладке, позволяя сразу получить важную информацию об объекте.
 Например, мы могли бы изменить свой класс Car30 так, чтобы его метод toString возвращал марку, модель и VIN.
 */

console.log(car33.toString());  // [object Object]

class Car50 extends Vehicle {
    static getNextVin() {
        return Car50.nextVin++;
    }

    constructor(make, model) {
        super();
        this.make = make;
        this.model = model;
        this.vin = Car50.getNextVin();
        console.log("Автомобиль создан");
    }

    deployAirbags() {
        console.log("БАБАХ!!!");
    }

    static areSimilar(car1, car2) {
        return car1.make === car2.make && car1.model === car2.model;
    }

    static areSame(car1, car2) {
        return car1.vin === car2.vin;
    }

    toString() {
        return `${this.make} ${this.model} : ${this.vin}`;
    }
}

Car50.nextVin = 0;


car55 = new Car50("Niva", "4");

console.log(car55.toString());

/*
Выведет:
Транспортное средство создано
Автомобиль создан
Niva 4 : 0

Теперь вызов метода toString для экземпляра Car50 дает немного больше информации об объекте.


Множественное наследование, примеси и интерфейсы*********

Некоторые объектно-ориентированные языки поддерживают множественное наследование (multiple inheritance), когда у одного класса может быть два прямых суперкласса (в отличие от одного суперкласса, у которого, в свою очередь, есть один суперкласс). 

Множественное наследование создает риск коллизий (collision) или конфликтов.

Таким образом, если нечто унаследовано от двух родителей и у обоих родителей есть метод greet, то от кого именно он будет унаследован производным классом? 
Во многих языках предпочитается одиночное наследование, при котором этой проблемы нет.

Но когда мы решаем реальные задачи, множественное наследование зачастую имеет смысл. 

Например, автомобили могли бы происходить как от транспортных средств, так и от "подлежащих страхованию" (вы можете застраховать и автомобиль,
и дом, но дом, безусловно, - не транспортное средство). 
В языках, где не поддерживается множественное наследование, зачастую вводится концепция интерфейса
(interface), чтобы обойти эту проблему. 

Класс (Car) может происходить только от одного родителя (Vehicle), но у него может быть несколько интерфейсов (InsuraЬle, Container и т.д.).

JavaScript - интересный гибрид. Технически это язык одиночного наследования, поскольку поиск по цепи прототипов не распространяется на несколько родителей,
но он предоставляет пути, которые иногда превосходят и множественное наследование, и интерфейсы (а иногда - нет).

Основной механизм решения проблемы множественного наследования - это концепция примеси (mixin). 

Примесь позволяет "подмешивать" функциональные
возможности по мере необходимости. Поскольку JavaScript позволяет чрезвычайно много и без контроля типов, вы можете подмешать почти любые функции к любому
объекту в любое время. 

Давайте создадим примесь "страхуемый", которую мы могли бы применить к автомобилям. Мы не будем усложнять пример, но в дополнение к примеси страхования необходимо создать класс InsurancePolicy. 
Примесь страхования нуждается в методах 
addinsurancePolicy, 
get insurancePolicy и (для удобства) 
isInsured.

Давайте рассмотрим, как это могло бы работать.
class InsurancePolicy() {}
*/

class InsurancePolicy { }

function makeInsurable(o) {
    o.addInsurancePolicy = function (p) { this.insurancePolicy = p; }
    o.getInsurancePolicy = function () { return this.insurancePolicy; }
    o.isInsured = function () { return !!this.insurancePolicy; }
}

/*
Теперь мы можем сделать любой объект подлежащим страхованию. Так как мы собираемся сделать подлежащим страхованию класс Car? Ваша первая мысль могла
бы быть такой.
*/
makeInsurable(Car50);
/*
Но вы были бы неприятно удивлены.
*/
const car56 = new Car50();
// car56.addInsurancePolicy(new InsurancePolicy()); // TypeError: car56.addInsurancePolicy is not a function

/*
Если вы подумали "Конечно, ведь 
addinsurancePolicy не находится в цепи прототипов': то будете совершенно правы. Делать класс Car50 подлежащим страхованию вообще плохая идея. 
Кроме того, это вообще не имеет смысла: абстрактная концепция автомобиля не подлежит страхованию, но конкретный автомобиль - подлежит.
Таким образом, наше следующее решение могло бы быть таким.
 */
console.log('insurance:');
const car57 = new Car50();
makeInsurable(car57);
car57.addInsurancePolicy(new InsurancePolicy()); // работает

/*
Выведет:
insurance:
Транспортное средство создано
Автомобиль создан

Это работает, но теперь нужно не забыть вызывать функцию 
makeInsurable
для каждого создаваемого нами автомобиля.
 Мы могли бы добавить этот вызов
в конструктор Car50, но тогда мы продублируем эту функцию для каждого созданного
автомобиля.
 К счастью, решение простое.
*/
makeInsurable(Car50.prototype);
const car58 = new Car50();
car58.addInsurancePolicy(new InsurancePolicy());
console.log(car58.isInsured());  // true

const car59 = new Car50();
console.log("car59: " + car59.isInsured());

/*
Выведет:
Транспортное средство создано
Автомобиль создан
car59: false

Теперь это выглядит так, как будто наши методы всегда были частью класса Car50. И с точки зрения JavaScript так и есть.
 С точки зрения разработчика мы облегчили поддержку этих двух важных классов. Группа разработчиков автомобилей создает и обслуживает класс Car50, а группа страхования занимается классом InsurancePolicy и примесью makeinsurable. В результате место для пересечения двух групп все таки имеется, но
это куда лучше, чем когда все работают над одним гигантским классом Car50. 

Примеси не устраняют проблему коллизий: 
если бы по каким-то причинам страховая группа должна была бы создать в своей примеси метод shift (в Car который переключает передачи "P", "N", "D", "R"), то это нарушило бы класс Car. Кроме того, мы не можем использовать instanceof для выявления
объектов, которые допускают страхование: 
в лучшем случае мы можем рассчитывать на утиную типизацию (если у объекта есть метод addinsurancePolicy, он, вероятно,
подлежит страхованию).
*/
console.log(car58 instanceof InsurancePolicy); // false 
console.log(car59 instanceof InsurancePolicy); // false

console.log(car58 instanceof Car50);  // true 
console.log(car59 instanceof Car50);  // true

console.log(car58.__proto__);
console.log(car59.__proto__);

/*
Выведет:
Vehicle {
  addInsurancePolicy: [Function (anonymous)],
  getInsurancePolicy: [Function (anonymous)],
  isInsured: [Function (anonymous)]
}
Vehicle {
  addInsurancePolicy: [Function (anonymous)],
  getInsurancePolicy: [Function (anonymous)],
  isInsured: [Function (anonymous)]
}
*/

console.log(Object.getPrototypeOf(car58));
console.log(Object.getPrototypeOf(car59));

/*
Vehicle {
  addInsurancePolicy: [Function (anonymous)],
  getInsurancePolicy: [Function (anonymous)],
  isInsured: [Function (anonymous)]
}
Vehicle {
  addInsurancePolicy: [Function (anonymous)],
  getInsurancePolicy: [Function (anonymous)],
  isInsured: [Function (anonymous)]
}
Проверим одинаковы ли свойста у этих машин
*/
console.log(Object.keys(car58));  // [ 'passengers', 'make', 'model', 'vin', 'insurancePolicy' ]
console.log(Object.keys(car59)); // [ 'passengers', 'make', 'model', 'vin' ]

/*
Мы можем сгладить некоторые из этих проблем, используя символы. 

Скажем,
страховая группа постоянно добавляет очень обобщенные методы, которые конфликтуют с методами класса Car. Вы могли бы попросить их использовать для всех
своих ключей символы. 
Теперь их примесь будет выглядеть следующим образом.
*/
class InsurancePolicies { }
const ADD_POLICY = Symbol();
const GET_POLICY = Symbol();
const IS_INSURED = Symbol();
const _POLICY = Symbol();
function madeInsurable(o) {
    o[ADD_POLICY] = function (p) { this[_POLICY] = p; }
    o[GET_POLICY] = function () { return this[_POLICY]; }
    o[IS_INSURED] = function () { return !!this[_POLICY]; }
}

/*
Поскольку символы уникальны, это гарантирует, что примесь никогда не будет конфликтовать с существующими функциями класса Car. 
В использовании это может быть немного неуклюже, но намного безопаснее. Компромиссный подход, возможно, подразумевал бы использование обычных строк для методов, а символов (таких, как POLICY) для свойств данных.

Заключение***********************************************

Объектно-ориентированное программирование - это чрезвычайно популярная парадигма и на то есть серьезные причины. Оно обеспечивает организацию и инкапсуляцию кода для решения многих реальных задач, что облегчает поддержку, отладку и исправление ошибок. Реализацию ООП в JavaScript серьезно критикуют - некоторые доходят до утверждения, что JavaScript даже не соответствует определению
объектно-ориентированного языка (обычно из-за нехватки контроля доступа к данным). Этот аргумент заслуживает внимания, но как только вы привыкнете к тому,
как в JavaScript реализовано ООП, вы найдете этот язык весьма гибким и мощным.
Он позволяет делать такие вещи, на которые другие объектно-ориентированные
языки не способны. 
*/
/*
В JavaScript есть два основных механизма для работы с прототипами объектов: `prototype` и `__proto__`.

1. prototype:
   - `prototype` является свойством функции.
   - Оно используется для определения прототипа объектов, созданных с использованием этой функции в качестве конструктора.
   - `prototype` используется для создания связи между объектом и его прототипом, что позволяет наследовать свойства и методы от прототипа.

2. __proto__:
   - `__proto__` является внутренним свойством каждого объекта в JavaScript.
   - Оно используется для установки прототипа объекта на другой объект.
   - `__proto__` позволяет объекту обращаться к своему прототипу для поиска свойств и методов, которые отсутствуют в самом объекте.

Таким образом, основное различие между `prototype` и `__proto__` заключается в их назначении и использовании: `prototype` используется для определения прототипа функции, а `__proto__` используется для установки прототипа объекта.
*/