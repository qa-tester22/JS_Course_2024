/*
OOP (MDN Web docs)

Объектно-ориентированного программирования

Объектно-ориентированное программирование (ООП) — это парадигма программирования, фундаментальная для многих языков программирования, включая Java и C++. 

 Мы опишем три основные концепции: 
 классы и экземпляры , 
 наследование и 
 инкапсуляция . 
 
 Сейчас мы будем описывать эти концепции без привязки конкретно к JavaScript, поэтому все примеры даны в псевдокоде .

Примечание. Если быть точным, описанные здесь функции относятся к определенному стилю ООП, называемому классовым или «классическим» ООП. Когда люди говорят об ООП, они обычно имеют в виду именно этот тип.

После этого на JavaScript мы рассмотрим, как конструкторы и цепочка прототипов связаны с этими концепциями ООП и чем они отличаются. 

Затем рассмотрим некоторые дополнительные возможности JavaScript, которые упрощают реализацию объектно-ориентированных программ.
********************************************************
OOP как общепринято!

Объектно-ориентированное программирование — это моделирование системы как набора объектов, где каждый объект представляет определенный аспект системы. 

Объекты содержат как функции (или методы), так и данные. Объект предоставляет общедоступный интерфейс для другого кода, который хочет его использовать, но сохраняет свое собственное внутреннее состояние; другим частям системы не нужно заботиться о том, что происходит внутри объекта.

*********************************************************
Классы и экземпляры

Когда мы моделируем проблему с точки зрения объектов в ООП, мы создаем абстрактные определения, представляющие типы объектов, которые мы хотим иметь в нашей системе. 

Например, если бы мы моделировали школу, мы могли бы захотеть, чтобы объекты представляли профессоров.
 - У каждого профессора есть некоторые общие свойства: у всех есть имя и предмет, который они преподают. 
 - Кроме того, каждый профессор может делать определенные вещи: все они могут оценивать работу и могут, например, представиться своим студентам в начале года.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Так Professor может быть класс в нашей системе. 
- В определении класса перечислены данные и методы, которыми обладает каждый профессор.

В псевдокоде Professor класс можно записать так:

class Professor
    properties
        name
        teaches
    methods
        grade(paper)
        introduceSelf()

Это определяет Professor класс с:

    - два свойства данных: 
        - name  и
        - teaches

    - два метода: 
        - grade()           оценить работу и 
        - introduceSelf()   представиться.

Сам по себе класс ничего не делает: это своего рода шаблон для создания конкретных объектов такого типа. 

Каждый конкретный профессор, которого мы создаем, называется ЭКЗЕМПЛЯРОМ КЛАССА Professor. 
= an instance of the Professor  

Процесс создания экземпляра выполняется специальной функцией, называемой КОНСТРУКТОР . 
= constructor.

Мы передаем конструктору значения для любого внутреннего состояния, которое хотим инициализировать в новом экземпляре.

Обычно конструктор записывается как часть определения класса и обычно имеет то же имя, что и сам класс:
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
class Professor
    properties
        name
        teaches
    constructor
        Professor(name, teaches)
    methods
        grade(paper)
        introduceSelf()

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Этот конструктор принимает два параметра, поэтому мы можем инициализировать свойства name и teaches при создании нового конкретного профессора.

Теперь, когда у нас есть конструктор, мы можем создать профессоров. 
Языки программирования часто используют это ключевое слово new для обозначения вызова конструктора.
*/

dunya = new Professor("Dunya", "Java");

frol = new Professor("Frol", "Python");

dunya.teaches; // получим "Java"
dunya.introduceSelf();  // получим "My name is Professor Dunya and I will be your Java Professor."

frol.teaches;  // получим "Python"
frol.introduceSelf() // получим "My name is Frol and I will be your Python Professor."

// При этом создаются два объекта, оба экземпляра класса Professor.
/*
*********************************************************

Inheritance
Наследование

Предположим, в нашей школе мы тоже хотим представлять учащихся. 
 В отличие от профессоров, студенты не могут оценивать работы, не преподают определенный предмет и принадлежат к определенному курсу.

Однако у учеников есть имя, и они могут захотеть представиться, поэтому мы могли бы записать определение класса учеников следующим образом:

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

class Student
    properties
        name
        year
    constructor
        Student(name, year)
    methods
        introduceSelf()

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Было бы полезно, если бы мы могли представить тот факт, что студенты и преподаватели имеют общие свойства, или, точнее, тот факт, что на каком-то уровне они представляют собой одно и то же .
 Наследование позволяет нам сделать это.

Мы начнем с того, что заметим, что студенты и преподаватели — 
    - оба люди, 
    - а у людей есть имена 
    - и они хотят представиться. 
    
Мы можем смоделировать это, определив новый класс Person, в котором мы определим все общие свойства людей. 
Тогда Professor и Student оба могут быть производными от Person, добавляя свои дополнительные свойства:

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

class Person
    properties
        name
    constructor
        Person(name)
    methods
        introduceSelf()

class Professor : extends Person
    properties
        teaches
    constructor
        Professor(name, teaches)
    methods
        grade(paper)
        introduceSelf()

class Student : extends Person
    properties
        year
    constructor
        Student(name, year)
    methods
        introduceSelf()

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!        
В этом случае мы бы сказали, что 
Person  - это СУПЕР КЛАСС или РОДИТЕЛЬСКИЙ КЛАСС
 для обоих Professor и Student.
 
 И наоборот, Professor и Student являются ПОДКЛАССАМИ  или ДОЧЕРНИМИ КЛАССАМИ Person.

Вы могли заметить, что introduceSelf() это определено во всех трех классах. Причина в том, что, хотя все люди хотят представиться, они делают это по-разному:

*/

dunya = new Professor("Dunya", "Java");
dunya.introduceSelf(); // "My name is Professor Dunya and I will be your Java Professor."


kondrat = new Student("Kondrat", 1);
kondrat.introduceSelf();  // "My name is Kondrat and I'm in the first year."

/*
У нас может быть реализация по умолчанию introduceSelf() для людей, которые не являются студентами или профессорами:
*/

fekla = new Person("Fekla");
fekla.introduceSelf();  // "My name is Fekla."

/*
Эта особенность — когда метод имеет одно и то же имя, но разную реализацию в разных классах — называется ПОЛИМОРФИЗМОМ . 
= polymorphism
Когда метод в подклассе заменяет реализацию суперкласса, мы говорим, что подкласс переопределяет версию в суперклассе.

*********************************************************

Encapsulation
Инкапсуляция

Объекты предоставляют интерфейс для другого кода, который хочет их использовать, но сохраняют свое собственное внутреннее состояние. 
= private = Внутреннее состояние объекта остается закрытым , что означает, что к нему могут получить доступ только собственные методы объекта, а не другие объекты. 

Сохранение конфиденциальности внутреннего состояния объекта и, как правило, четкое разделение между его общедоступным интерфейсом и частным внутренним состоянием называется ИНКАПСУЛЯЦИЯ
= encapsulation .

Это полезная функция, поскольку она позволяет программисту изменять внутреннюю реализацию объекта без необходимости искать и обновлять весь код, который его использует: она создает своего рода межсетевой экран между этим объектом и остальной частью системы.

Например, предположим, что студентам разрешено изучать стрельбу из лука, если они учатся на втором курсе или выше. Мы могли бы реализовать это, просто открыв property свойство студента year, а другой код мог бы проверить это, чтобы решить, может ли студент пройти курс:
*/

if (student.year > 1) {
  // allow the student into the class
}


/*
Проблема в том, что если мы решим изменить критерии, позволяющие учащимся изучать стрельбу из лука (например, потребовав от родителей или опекунов дать свое разрешение), нам придется обновить каждое место в нашей системе, где выполняется этот тест. 
Было бы лучше иметь canStudyArchery() метод для Student объектов, реализующий логику в одном месте:
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

class Student : extends Person
    properties
       year
    constructor
       Student(name, year)
    methods
       introduceSelf()
       canStudyArchery() { return this.year > 1 }

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


if (student.canStudyArchery()) {
    allow the student into the class
} 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

Таким образом, если мы хотим изменить правила изучения стрельбы из лука, нам нужно всего лишь обновить класс Student, и весь код, использующий его, по-прежнему будет работать.

********************************************************

Во многих языках ООП мы можем запретить другому коду доступ к внутреннему состоянию объекта, пометив некоторые свойства как private. 
Это вызовет ошибку, если код вне объекта попытается получить к ним доступ:

class Student : extends Person
    properties
       private year
    constructor
        Student(name, year)
    methods
       introduceSelf()
       canStudyArchery() { return this.year > 1 }

student = new Student('Pawa', 1)
student.year // error: 'year' is a private property of Student


В языках, которые не требуют такого доступа, программисты используют соглашения об именах, например, начинают имя с подчеркивания  _ , чтобы указать, что свойство следует считать частным.

********************************************************
JSJSJSJSJSJSJSJSJSJSJSJSJSJSJSJSJSJSJSJSJSJSJSJSJSJSJSJS

ООП и JavaScript

мы рассмотрели некоторые основные возможности объектно-ориентированного программирования на основе классов, реализованные в таких языках, как Java и C++.

Ранее мы рассмотрели пару основных функций JavaScript: конструкторы и прототипы . 
Эти функции, безусловно, имеют некоторое отношение к некоторым концепциям ООП, описанным выше.

- Конструкторы в JavaScript предоставляют нам что-то вроде определения класса, позволяя нам определить 
    - «форму» объекта, 
    - включая любые содержащиеся в нем методы, в одном месте. 
    
    Но прототипы можно использовать и здесь. 
    Например, если метод определен в свойстве конструктора prototype, то все объекты, созданные с использованием этого конструктора, получают этот метод через свой прототип, и нам не нужно определять его в конструкторе.

- цепочка прототипов кажется естественным способом реализации наследования. 

Например, если у нас есть Student объект, 
прототип которого равен Person, 
то он может наследовать name и переопределять introduceSelf().

Но стоит понимать РАЗЛИЧИЯ между этими возможностями и «классическими» концепциями ООП, сказанные ранее. 

Например, 

- Во-первых, в ООП на основе классов классы и объекты представляют собой две отдельные конструкции, 
а объекты всегда создаются как экземпляры классов. 

Кроме того, существует различие между функцией, используемой для определения класса (сам синтаксис класса), и функцией, используемой для создания экземпляра объекта (конструктор).

    !!! В JavaScript мы можем и часто создаем объекты без какого-либо отдельного определения класса, используя функцию или литерал объекта. 
    !!! Это может сделать работу с объектами намного более легкой, чем в классическом ООП.

- Во-вторых, хотя цепочка прототипов выглядит как иерархия наследования и в чем-то ведет себя так же, в чем-то она отличается. 

При создании экземпляра подкласса создается один объект, который объединяет свойства, определенные в подклассе, со свойствами, определенными выше по иерархии. 
При прототипировании каждый уровень иерархии представлен отдельным объектом, и они связаны между собой через свойство __proto__. 

Поведение цепочки прототипов меньше похоже на наследование, а больше на делегирование . 

= delegation = Делегирование — это шаблон программирования, при котором объект, когда его просят выполнить задачу, может выполнить задачу сам или попросить другой объект (его делегата delegate) выполнить задачу от его имени. 
Во многих отношениях делегирование является более гибким способом объединения объектов, чем наследование (во-первых, можно изменить или полностью заменить делегат во время выполнения).

    !!! Тем не менее, конструкторы и прототипы можно использовать для реализации шаблонов ООП на основе классов в JavaScript. 
    Но использовать их напрямую для реализации таких функций, как наследование, сложно, поэтому JavaScript предоставляет дополнительные функции, накладываемые поверх модели прототипа, которые более непосредственно соответствуют концепциям ООП на основе классов. 


*/