/**
 * Копирование объектов и ссылки
 * 
Одно из фундаментальных отличий объектов от примитивов заключается в том, что 
объекты хранятся и копируются «по ссылке», тогда как 
примитивные значения: строки, числа, логические значения и т.д. – всегда копируются «как целое значение».

Это легко понять, если мы немного заглянем под капот того, что происходит, когда мы копируем значение.

Давайте начнём с примитива, такого как строка.

Здесь мы помещаем копию message во phrase:
 */
let message = "Привет";
let phrase = message;

/**
 * В результате мы имеем две независимые переменные, каждая из которых хранит строку "Привет!".
 * 
 * Вполне очевидный результат, не так ли?

Объекты ведут себя иначе.

Переменная, которой присвоен объект, хранит не сам объект, а его «адрес в памяти» – другими словами, «ссылку» на него.

Давайте рассмотрим пример такой переменной:
 */

let user = {
    name: "John"
}

/**
 * И вот как это на самом деле хранится в памяти:
 * 
 * Объект {...} хранится где-то в памяти (справа от =), в то время как переменная user (слева от = ) имеет лишь «ссылку» на него.

Мы можем думать о переменной объекта, такой как user, как о листе бумаги с адресом объекта на нем.

Когда мы выполняем действия с объектом, к примеру, берём свойство user.name, движок JavaScript просматривает то, что находится по этому адресу, и выполняет операцию с самим объектом.

Теперь вот почему это важно.

При копировании переменной объекта копируется ссылка, но сам объект не дублируется.

Например:
 */

let admin = user;  // копируется ссылка

/**
 * Теперь у нас есть две переменные, каждая из которых содержит ссылку на один и тот же объект:
 * 
 */

admin.name = "Peter";   // изменено по ссылке из переменной "admin"
console.log(user.name);  // 'Peter', изменения видны по ссылке из переменной "user" 

/*
Это как если бы у нас был шкафчик с двумя ключами, и мы использовали один из них (admin), чтобы войти в него и внести изменения. А затем, если мы позже используем другой ключ (user), мы все равно открываем тот же шкафчик и можем получить доступ к изменённому содержимому.

Сравнение по ссылке

Два объекта равны только в том случае, если это один и тот же объект.

Например, здесь a и b ссылаются на один и тот же объект, поэтому они равны:
*/
let abc = {};
let bcd = abc;  // копирование по ссылке

console.log(abc == bcd); // true, обе переменные ссылаются на один и тот же объект
console.log(abc === bcd);  // true

let ab = {};
let bc = {};  // два независимых объекта

console.log(ab == bc);   // false

/*
Для сравнений типа obj1 > obj2 или для сравнения с примитивом obj == 5 объекты преобразуются в примитивы. Очень скоро мы изучим, как работают преобразования объектов, но, по правде говоря, такие сравнения требуются очень редко и обычно они появляются в результате ошибок программиста.

Клонирование и объединение, Object.assign

Итак, копирование объектной переменной создаёт ещё одну ссылку на тот же объект.

Но что, если нам всё же нужно дублировать объект? Создать независимую копию, клон?

Это тоже выполнимо, но немного сложнее, потому что в JavaScript для этого нет встроенного метода. Но на самом деле в этом редко возникает необходимость, копирования по ссылке в большинстве случаев вполне хватает.

Но если мы действительно этого хотим, то нам нужно создать новый объект и воспроизвести структуру существующего, перебрав его свойства и скопировав их на примитивном уровне.
*/

let user1 = {
    name: "John",
    age: 30
};

let clone = {};
// давайте скопируем все свойства user в него
for (let key in user1) {
    clone[key] = user1[key];
}

// теперь clone это полностью независимый объект с тем же содержимым
clone.name = "Pete"; // изменим в нём данные

console.log(user1.name); // все ещё John в первоначальном объекте

// Также мы можем использовать для этого метод Object.assign.

/*
 Синтаксис:

Object.assign(dest, [src1, src2, src3,...]);

Первый аргумент dest — целевой объект.
Остальные аргументы src1, ..., srcN (может быть столько, сколько необходимо) являются исходными объектами
Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest. Другими словами, свойства всех аргументов, начиная со второго, копируются в первый объект.
Возвращает объект dest.

Например, мы можем использовать его для объединения нескольких объектов в один:
*/

let user3 = { name: "John" };

let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

// копируем все свойства из permissions1 и permissions2 в user
Object.assign(user3, permissions1, permissions2);

console.log(user3);
// теперь user3 = { name: "John", canView: true, canEdit: true }

/*
Если скопированное имя свойства уже существует, оно будет перезаписано.

Мы также можем использовать Object.assign для замены цикла for..in для простого клонирования:

*/

let clone2 = Object.assign({}, user3);

console.log(clone2);  //{ name: 'John', canView: true, canEdit: true }

/**
 * Он копирует все свойства user в пустой объект и возвращает его.

Также существуют и другие методы клонирования объекта. Например, с использованием оператора расширения 
clone = {...user}, рассмотренного далее.

Вложенное клонирование

До сих пор мы предполагали, что все свойства user примитивныe. Но свойства могут быть и ссылками на другие объекты. Что с ними делать?

Например, есть объект:
 */

let user4 = {
    name: "John",
    sizes: {
      height: 182,
      width: 50
    }
  };
  
  console.log( user4.sizes.height ); // 182

  /**
   * Теперь недостаточно просто скопировать clone.sizes = user.sizes, потому что user.sizes – это объект, он будет скопирован по ссылке. Таким образом, clone и user будут иметь общий объект sizes:
   */

  let user5 = {
    name: "John",
    sizes: {
      height: 182,
      width: 50
    }
  };
  
  let clone3 = Object.assign({}, user5);
  
  console.log( user5.sizes === clone3.sizes ); // true, тот же объект
  
  // user5 и clone3 обладают общим свойством sizes
  user5.sizes.width++;       // изменяем свойства в первом объекте
  console.log(clone3.sizes.width); // 51, видим результат в другом

  /**
   * Чтобы исправить это, мы должны использовать цикл клонирования, который проверяет каждое значение user[key] и, если это объект, тогда также копирует его структуру. Это называется "ГЛУБОКИМ КЛОНИРОВАНИЕМ" «глубоким клонированием».

Мы можем реализовать глубокое клонирование, используя рекурсию. Или, чтобы не изобретать велосипед заново, возьмите готовую реализацию, например

_.cloneDeep(obj) из библиотеки JavaScript lodash.

Также мы можем использовать глобальный метод 

structuredClone(), который позволяет сделать полную копию объекта. К сожалению он поддерживается только современными браузерами. 
   */

/**
 * Объекты, объявленные как константа, могут быть изменены
 * 
Важным побочным эффектом хранения объектов в качестве ссылок является то, что объект, объявленный как const, может быть изменён.

Например:
*/
const user6 = {
  name: "John"
};

user6.name = "Peter"; // (*)

console.log(user6.name); // Peter

/*
Может показаться, что строка (*) вызовет ошибку, но, это не так. Значение user это константа, оно всегда должно ссылаться на один и тот же объект, но свойства этого объекта могут свободно изменяться.

Другими словами, const user выдаст ошибку только в том случае, если мы попытаемся задать user=... в целом.

Тем не менее, если нам действительно нужно создать постоянные свойства объекта, это тоже возможно, но с использованием совершенно других методов. 
 */

/*
Итого

Объекты присваиваются и копируются по ссылке.
 Другими словами, переменная хранит не «значение объекта», а «ссылку» (адрес в памяти) на это значение. Таким образом, копирование такой переменной или передача её в качестве аргумента функции копирует эту ссылку, а не сам объект.

Все операции с использованием скопированных ссылок (например, добавление/удаление свойств) выполняются с одним и тем же объектом.

Чтобы создать «реальную копию» (клон), мы можем использовать 
Object.assign для так называемой «поверхностной копии» (вложенные объекты копируются по ссылке) или функцию «глубокого клонирования», такую как 
_.cloneDeep(obj).
*/

