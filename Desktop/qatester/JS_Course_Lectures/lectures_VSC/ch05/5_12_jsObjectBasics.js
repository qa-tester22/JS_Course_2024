/*
Как и во многих случаях в JavaScript, создание объекта часто начинается с определения и инициализации переменной. 
*/
const people = {};

/*
Если вы введёте const people = {}; people в текстовое JS консоль и нажмёте клавишу Enter, должен получиться следующий результат: {}.

Поздравляем, вы только что создали ваш первый объект. 
Но это пустой объект, поэтому мы не можем с ним ничего сделать. Давайте обновим наш объект, чтобы он содержал данные. Но просто присвоить какие-то значения не получится для const
*/

/*
people = {
    age: 25;
}; 
/*
 people = {
    ^

    TypeError: Assignment to constant variable.
*/

newPeople = {
    name: ["Bob", "Smith"],
    age: 32,
    gender: "male",
    interests: ["JS", "testing"],
    bio: function () {
        
    return `${this.name[0]} ${this.name[1]} is ${this.age} years old. He likes ${this.interests[0]} and ${this.interests[1]}.`},

    greeting: function () {
       return "Hi! I'm " + this.name[0] + ".";
    },
};

console.log(newPeople.name);
console.log(newPeople.name[0]);
console.log(newPeople.age);
console.log(newPeople.interests[1]);
console.log(newPeople.bio());
console.log(newPeople.greeting());


/*
Итак что здесь происходит? Объект состоит из нескольких элементов, каждый из которых имеет своё название (пример name и age выше), и значение (пример ['Bob', 'Smith'] и 32). Каждая пара название/значение должны быть разделены запятой, а название и значение в каждом случае разделяются двоеточием. Синтаксис всегда следует этому образцу:
*/

const objectName = {
    "member1Name": "member1Value",
    "member2Name": "member2Value",
    "member3Name": "member3Value",
};

/*
Значение члена объекта может быть чем угодно — в нашем объекте newPeople есть строка, число, два массива, и две функции. 
Первые четыре элемента это элементы данных, относящиеся к свойствам объекта. Последние два элемента являются функциями, которые позволяют объекту что-то сделать с элементами данных, и называются методами объекта.

Такие объекты называются литералами объекта (object literal) — мы буквально вписали все содержимое объекта для его создания. Этот способ сильно отличается от объектов реализованных классами, которые мы рассмотрим позже.

Очень часто для создания объекта используется литерал объекта когда вам нужно каким-то образом перенести ряд структурированных, связанных элементов данных, например, отправляя запрос на сервер, для размещения их в базе данных. Отправка одного объекта намного эффективнее, чем отправка нескольких элементов по отдельности, и с ним легче работать чем с массивом, если требуется идентифицировать отдельные элементы по имени.
*/

/*
Точечная запись (Dot notation)

Мы получили доступ к свойствам и методам используя точечную запись (dot notation). Имя объекта (newPeople) действует как пространство имён (namespace) — оно должно быть введено первым, для того чтобы получить доступ ко всему что заключено (encapsulated) внутри объекта. Далее вы пишете точку, затем элемент, к которому хотите получить доступ — это может быть имя простого свойства, элемент массива, или вызов одного из методов объекта, 
*/

console.log(newPeople.age);
console.log(newPeople.interests[[1]]);
console.log(newPeople.bio());

/*
Внутренние пространства имён (Sub-namespaces)
Можно даже сделать значением элемента объекта другой объект. 
Например, попробуйте изменить значение свойства name с такого 
*/

{name: ["Bob", "Smith"]}

/* на такое */

newPeople.name = {
        first: "Bob",
        last: "Smith"
};

/*
Здесь мы фактически создаём внутреннее пространство имён (sub-namespace). Это звучит сложно, но на самом деле это не так — для доступа к этим элементам вам нужно сделать один дополнительный шаг с ещё одной точкой. 
*/

console.log(newPeople.name.first);
console.log(newPeople.name.last);

/*
Теперь также нужно будет пересмотреть код метода и изменить все экземпляры, иначе методы больше не будут работать.
*/

newPeople.bio = function () {
    return `${this.name.first} ${this.name.last} is ${this.age} years old. He likes ${this.interests[0]} and ${this.interests[1]}.`
};

newPeople.greeting = function () {
    return "Hi! I'm " + this.name.first + ".";
};

console.log(newPeople);

/*
Скобочная запись (Bracket notation)

Существует другой способ получить свойства объекта — использовать скобочную запись (bracket notation). Вместо написания этого кода:
*/

console.log(newPeople["age"]);  // 32
console.log(newPeople["name"]["first"]);  // Bob

/*
Это выглядит очень похоже на то, как вы получаете элементы массива, и в принципе это так и есть — вместо использования числовых индексов для выбора элемента, вы ассоциируете имя свойства для каждого значения. 
Ничего удивительного, что эти объекты иногда называют АССОЦИАТИВНЫМИ МАССИВАМИ — они сопоставляют строки со значениями так же, как массивы сопоставляют числовые индексы со значениями.
*/

/*
Запись элементов в объект

До сих пор мы рассматривали только возврат (или получение) элементов объекта — вы так же можете установить (обновить) значение элемента объекта просто объявив элемент, который вы хотите установить (используя точечную или скобочную запись), например:
*/

newPeople.age = 30;
newPeople["name"]["last"] = "Miller";

console.log(newPeople["age"]);  // 30
console.log(newPeople["name"]["last"]);  // Miller

/*
Вы можете не просто обновлять и устанавливать значения свойств и методов объекта, а так же устанавливать совершенно новые элементы.
*/

newPeople["eyes"] = "blue";
newPeople.farewell = function () {
    return "Bye everybody!";
};

console.log(newPeople["eyes"]);
console.log(newPeople["farewell"]);  // [Function (anonymous)] - не работает;
console.log(newPeople.farewell());  // Bye everybody!

/*
Одним из полезных аспектов скобочной записи является то, что с её помощью можно динамически задавать не только значения элементов, но и их имена. 
Предположим, что мы хотим, чтобы пользователи могли хранить пользовательские типы данных, введя имя и значение элемента в два следующих поля? Мы могли бы получить эти значения следующим образом:
*/

let myDataName = "nameInput.value";
let myDataValue = "nameValue.value";

/*
Затем мы можем добавить имя и значение этого нового элемента в объект person таким образом:
*/
newPeople[myDataName] = myDataValue;


// Добавляем свойства newPeople
const DataName = "height";
const DataValue = "1,75m";
newPeople[DataName] = DataValue;

console.log(newPeople.height);
console.log(newPeople);

/*
Добавление свойства объекта с использованием вышеописанного метода невозможно с использованием точечной записи, которая может принимать только литеральное имя элемента, а не значение переменной указывающее на имя.
*/

newPeople.DataName = DataValue;  // невозможно задать через точку
// закомментируем  newPeople[DataName] = DataValue;

console.log(newPeople.height);  // undefined

/****************************************************

Что такое "this"?

Возможно, вы заметили что-то странное в наших методах. Посмотрите на этот пример:
*/

newPeople.greeting = function() {
    return `Hi! I'm ${this.name.first}.`
};

console.log(newPeople.greeting());

/*
Что такое "this"? Ключевое слово this, ссылается на текущий объект, внутри которого пишется код — поэтому в нашем случае this равен объекту newPeople.
 Но почему просто не написать newPeople? 
 Как вы увидите далее в Object-oriented JavaScript for beginners (en-US) (Объектно-ориентированный JavaScript для начинающих), когда мы начинаем создавать конструкторы и т.д., 
 this очень полезен — он всегда будет гарантировать, что используется верное значение, когда контекст элемента изменяется (например, два разных экземпляра объекта newPeople могут иметь разные имена, но захотят использовать своё собственное имя при приветствии.

Давайте проиллюстрируем, что имеется в виду, с упрощённой парой объектов newPeople :
*/

const personFirst = {
    name: "Tom",
    greeting: function () {
        return `Hi! I'm ${this.name}.`;
    },
};

const personSecond = {
    name: "Ann",
    greeting: function () {
        return `Hi! I'm ${this.name}.`;
    },
};

console.log(personFirst.greeting());
console.log(personSecond.greeting());

/*
this равен объекту, внутри которого находится код — это не очень полезно, когда вы пишите литералы объектов вручную, но оно действительно помогает, когда вы генерируете объекты динамически (например используя конструкторы). Это станет понятнее чуть позже.
*/
/*************************************************
 * 
 * Все это время вы использовали объекты
 * 
Пока вы проходили эти примеры, вы вероятно заметили, что точечная запись, которую вы использовали, выглядит очень знакомо. 
Это потому, что вы использовали её на протяжении всего курса! 
Каждый раз, когда мы работаем над примером, использующим встроенный API браузера или объект JavaScript, мы использовали объекты, потому что такие функции построены с использованием тех же структур объектов, которые мы здесь рассматривали, хотя и более сложные, чем наши собственные пользовательские примеры.

Поэтому, когда вы использовали строковые методы, такие как:
 */
let myString = "Testing";

let splitMyString = myString.split("");

console.log(splitMyString);

/*
Вы использовали метод доступный в экземпляре класса String. Каждый раз создавая строку в вашем коде, эта строка автоматически создаётся как экземпляр String, и поэтому имеет несколько общих методов/свойств, доступных на нем.

Когда вы обращались к объектной модели документа (DOM), используя следующие строки в браузерной среде: в файле 5_10_object.html 
*/
/*
Вы использовали методы доступные в экземпляре класса Document. Для каждой загруженной веб-страницы создаётся экземпляр Document, называемый document, который представляет всю структуру страницы, её содержимое и другие функции, такие как URL-адрес. Опять же, это означает, что он имеет несколько общих методов/свойств, доступных на нем.

То же самое относится и к любому другому встроенному объекту/API, который вы использовали — Array, Math, и т. д.

Обратите внимание, что встроенные объекты/API не всегда создают экземпляры объектов автоматически. Как пример, Notifications API — который позволяет новым браузерам запускать системные уведомления, требует, чтобы вы создавали новый экземпляр объекта с помощью конструктора для каждого уведомления, которое вы хотите запустить. Попробуйте ввести следующее в консоль JavaScript:
*/

// const myNotification = new Notification("Hello!");

/*
 Опять же, мы рассмотрим конструкторы далее.
 Объекты позволяют нам безопасно хранить информацию в своём собственном блоке, вне опасности.
 */