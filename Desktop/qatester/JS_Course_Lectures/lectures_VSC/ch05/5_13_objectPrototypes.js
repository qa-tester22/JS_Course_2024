/*
Язык основанный на прототипах?

JavaScript часто описывают как язык прототипного наследования — каждый объект, имеет объект-прототип, который выступает как шаблон, от которого объект наследует методы и свойства. Объект-прототип так же может иметь свой прототип и наследовать его свойства и методы и так далее. Это часто называется цепочкой прототипов и объясняет почему одним объектам доступны свойства и методы которые определены в других объектах.

Точнее, свойства и методы определяются в свойстве prototype функции-конструктора объектов, а не в самих объектах.

В JavaScript создаётся связь между экземпляром объекта и его прототипом (свойство __proto__, которое является производным от свойства prototype конструктора), а свойства и методы обнаруживаются при переходе по цепочке прототипов.
*/
/*
Понимание прототипа объектов

Напишим функцию - наш конструктор Person().

В этом примере мы определим конструктору функцию, например:
*/

function PersonOO(first, last, age, gender, interests) {
    // Определения методов и свойств
    this.name = {
        first: first,
        last: last,
    };
    this.age = age;
    this.gender = gender;
    this.interests = interests;
    this.bio = function() {
         // First define a string, and make it equal to the part of
          // the bio that we know will always be the same.
          let string = this.name.first + " " + this.name.last + " is " + this.age + " years old. "
           // define a variable that will contain the pronoun part of
          // the second sentence
          let pronoun;

          // check what the value of gender is, and set pronoun
          // to an appropriate value in each case
          if(this.gender === "male" || this.gender === "Male" || this.gender === "m" || this.gender === "M") {
            pronoun = "He likes ";
          } else if(this.gender === "female" || this.gender === "Female" || this.gender === "f" || this.gender === "F") {
            pronoun = "She likes ";
          } else {
            pronoun = "They like ";
          };

          // add the pronoun string on to the end of the main string

          string += pronoun;

          // use another conditional to structure the last part of the
          // second sentence depending on whether the number of interests
          // is 1, 2, or 3

          if(this.interests.length === 1) {
            string += this.interests[0] + ".";
          } else if(this.interests.length === 2) {
            string += this.interests[0] + " and " + this.interests[1] + ".";
          } else {
            // if there are more than 2 interests, we loop through them
            // all, adding each one to the main string followed by a comma,
            // except for the last one, which needs an and & a full stop
            for(let i = 0; i < this.interests.length; i++) {
                if(i === this.interests.length - 1) {
                    string += "and " + this.interests[i] + ".";
                } else {
                    string += this.interests + ", "; 
                }
            }
          }

           // finally, with the string built, we alert() it - return
           return string;
    };
    this.greeting = function () {
        return "Hi! I'm " + this.name.first + ".";
    };
};

// Затем мы создаём экземпляр объекта следующим образом:

const personOO1 = new PersonOO("Bob", "Smith", 32, "male", ["JS", "testing", "skiing", "boxing"]);

console.log(personOO1);

/*
Если вы наберёте «personOO1.» в вашей консоли JavaScript, вы должны увидеть, что браузер пытается автоматически заполнить это с именами участников, доступных на этом объекте:

В этом списке вы увидите элементы, определённые в конструкторе personOO1 — Person() — name, age, gender, interests, bio, и greeting. Однако вы также увидите некоторые другие элементы —  valueOf и т. д. — они определены в объекте прототипа PersonOO (), который является Object.

Итак, что произойдёт, если вы вызываете метод в personOO1, который фактически определён в Object? Например:
*/
console.log(personOO1.valueOf());

/*
Этот метод — Object.valueOf()наследуется personOO1, потому что его конструктором является PersonOO(), а прототипом PersonOO() является Object(). 

valueOf() возвращает значение вызываемого объекта — попробуйте и убедитесь! В этом случае происходит следующее:

1) Сначала браузер проверяет, имеет ли объект personOO1 доступный в нем метод valueOf(), как определено в его конструкторе PersonOO().
2) Это не так, поэтому следующим шагом браузер проверяет, имеет ли прототип объекта (Object()) конструктора PersonOO() доступный в нем метод valueOf(). Так оно и есть, поэтому он вызывается, и все хорошо!
*/

/*********************************************************************************************************
Свойство prototype: Где определены унаследованные экземпляры

Итак, где определены наследуемые свойства и методы? Если вы посмотрите на страницу со ссылкой Object, вы увидите в левой части большое количество свойств и методов - это намного больше, чем количество унаследованных членов, доступных для объекта personOO1. Некоторые из них унаследованы, а некоторые нет - почему это?

Как упоминалось выше, наследованные свойства это те, что определены в свойстве prototype (вы можете называть это подпространством имён), то есть те, которые начинаются с Object.prototype., а не те, которые начинаются с простого Object. Значение свойства prototype - это объект, который в основном представляет собой контейнер для хранения свойств и методов, которые мы хотим наследовать объектами, расположенными дальше по цепочке прототипов.

Таким образом  Object.prototype.valueOf() и т. д. доступны для любых типов объектов, которые наследуются от Object.prototype, включая новые экземпляры объектов, созданные из конструктора PersonOO() .

Object.is(), Object.keys() и другие члены, не определённые в контейнере prototype, не наследуются экземплярами объектов или типами объектов, которые наследуются от Object.prototype. 
Это методы / свойства, доступные только в конструкторе Object().
*/
/*
Это кажется странным - как у вас есть метод, определённый для конструктора, который сам по себе является функцией? Ну, функция также является типом объекта.
*/

/*
Вы можете проверить существующие свойства прототипа для себя - вернитесь к нашему предыдущему примеру и попробуйте ввести следующее в браузерную консоль JavaScript: PersonOO.prototype;
*/

console.log(PersonOO.prototype);
/*
Результат покажет вам не много, ведь мы ничего не определили в прототипе нашего конструктора! По умолчанию prototype конструктора всегда пуст. Теперь попробуйте следующее: Object.prototype;
*/

console.log(Object.prototype);
/*
Вы увидите большое количество методов, определённых для свойства prototype Object'а , которые затем доступны для объектов, которые наследуются от Object, как показано выше.
*/

/*

Вы увидите другие примеры наследования цепочек прототипов по всему JavaScript - попробуйте найти методы и свойства, определённые на прототипе глобальных объектов String, Date, Number и Array, например. Все они имеют несколько элементов, определённых на их прототипе, поэтому, например, когда вы создаёте строку, вот так:
*/

let myString = "This is my string.";
/*
В myString сразу есть множество полезных методов, таких как split(), indexOf(), replace() 
*/

/*
Снова create()

Ранее мы показали, как метод Object.create() может использоваться для создания нового экземпляра объекта.

Например, попробуйте это в консоли JavaScript предыдущего примера:
*/

let personOO2 = Object.create(personOO1);

console.log(personOO2);

console.log(personOO2._proto_);  // undefined

// Копируем свойства из personOO1 в personOO2
for (let prop in personOO1) {
    if (personOO1.hasOwnProperty(prop)) {
        personOO2[prop] = personOO1[prop];
    }
};

console.log(personOO2);
personOO2._proto_;
console.log(personOO2._proto_);
/*
Это вернёт объект person1.
*/

/*
Свойство constructor

Каждая функция-конструктор имеет свойство prototype, значением которого является объект, содержащий свойство constructor. 
Это свойство constructor указывает на исходную функцию-конструктор. Далее рассмотрим, свойства, определённые в свойстве PersonOO.prototype (или в общем случае в качестве свойства прототипа функции конструктора, который является объектом, как указано в предыдущем разделе) становятся доступными для всех объектов экземпляра, созданных с помощью конструктор Person(). Следовательно, свойство конструктора также доступно для объектов personOO1 и personOO2.

Например, попробуйте эти команды в консоли:
*/
console.log(personOO1.constructor);  // [Function: PersonOO]
console.log(personOO2.constructor);  // [Function: PersonOO]

/*
в браузерной консоли после ввода команд
personOO1.constructor;
personOO2.constructor;
получим:
ƒ PersonOO(first, last, age, gender, interests) {
    // Определения методов и свойств
    this.name = {
        first: first,
        last: last,
    };
    this.age = age;
    this.gender = gender;
 …  - перенаправляет в файл с функцией PersonOO;
 */

 /*
 Они должны возвращать конструктор Person(), поскольку он содержит исходное определение этих экземпляров. Хитрый трюк заключается в том, что вы можете поместить круглые скобки в конец свойства constructor (содержащие любые требуемые параметры) для создания другого экземпляра объекта из этого конструктора. 
 Конструктор - это функция в конце концов, поэтому её можно вызвать с помощью круглых скобок; вам просто нужно включить ключевое слово new, чтобы указать, что вы хотите использовать эту функцию в качестве конструктора.
 */

const personOO3 = new personOO1.constructor("Jane", "Davis", 26, "female", [
    "playing drums", 
    "mountain climbing",
]);

// Теперь попробуем получить доступ к функциям вашего нового объекта, например:
console.log(personOO3.name.first);
console.log(personOO3.age);
console.log(personOO3.bio());

/*
Это хорошо работает. Вам не нужно будет использовать его часто, но это может быть действительно полезно, если вы хотите создать новый экземпляр и не имеете ссылки на исходный конструктор, который легко доступен по какой-либо причине.

Свойство constructor имеет другие применения. Например, если у вас есть экземпляр объекта и вы хотите вернуть имя конструктора этого экземпляра, вы можете использовать следующее:
*/

// instanceName.constructor.name;

personOO1.constructor.name;

console.log(personOO1.constructor.name);  // PersonOO

/*
Изменение прототипов

Давайте рассмотрим пример изменения свойства prototype функции-конструктора — методы, добавленные в прототип, затем доступны для всех экземпляров объектов, созданных из конструктора.

Вернитесь к нашему примеру и создайте локальную копию исходного кода. Ниже существующего JavaScript добавьте следующий код, который добавляет новый метод в свойство prototype конструктора:
*/

PersonOO.prototype.farewell = function () {
    return this.name.first + " has left the building. Bye for now!";
};

console.log(personOO1.farewell());

/*
Должно появиться всплывающее окно, с именем пользователя, определённым в конструкторе. Это действительно полезно, но ещё более полезно то, что вся цепочка наследования обновляется динамически, автоматически делая этот новый метод доступным для всех экземпляров объектов, полученных из конструктора.

Подумайте об этом на мгновение. В нашем коде мы определяем конструктор, затем мы создаём экземпляр объекта из конструктора, затем добавляем новый метод к прототипу конструктора: farewell()

Но метод farewell() по-прежнему доступен в экземпляре объекта personOO1 - его элементы были автоматически обновлены, чтобы включить недавно определённый метод farewell().
*/

/*
Вы редко увидите свойства, определённые в свойстве prototype, потому что они не очень гибки при таком определении. Например, вы можете добавить свойство следующим образом:
*/

PersonOO.prototype.fullName = "Bob Smith";

/*
Это не очень гибко, так как человека нельзя назвать так. Было бы намного лучше сделать это, создав fullName из name.first и name.last:
*/

// PersonOO.prototype.fullName = this.name.first + " " + this.name.last; // неправильно

/*
Однако это не работает, поскольку в этом случае this будет ссылаться на глобальную область, а не на область функции. 
Вызов этого свойства вернёт undefined undefined. Это отлично работало с методом, который мы определили ранее в прототипе, потому что он находится внутри области функций, которая будет успешно перенесена в область экземпляра объекта. Таким образом, вы можете определить постоянные свойства прототипа (т. е. те, которые никогда не нуждаются в изменении), но обычно лучше определять свойства внутри конструктора.
*/

console.log(personOO1.fullName); // TypeError: Cannot read properties of undefined (reading 'first')

/*
Фактически, довольно распространённый шаблон для большего количества определений объектов - это определение свойств внутри конструктора и методов в прототипе. Это упрощает чтение кода, поскольку конструктор содержит только определения свойств, а методы разделены на отдельные блоки. Например:
*/

function Test (a, b, c, d) {
     // определение свойств...
}

// Определение первого метода

Test.prototype.x = function () { . . .};

// Определение второго метода

Test.prototype.y = function () { . . .};

// и так далее ...